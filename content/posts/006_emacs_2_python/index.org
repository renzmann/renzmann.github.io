#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* Intro
** Not many great up-to date guides on Python in Emacs
** Most immediately tell you to install a bunch of packages like elpy, pyvenv, eglot, or lsp-mode
** Those packages do amazing things, but first we need to know what problem they solve.
** Going to get to =eglot= eventually, but first what can we do without it?

[[file:nothing_without_lsp.png]]


* Editing

Let's get our feet wet just bopping around some Python buffers first.  I'm
going to start up a new python file with =C-x C-f= and naming my file
=editing.py=.  Typing code as I usually do, I'm going to start by just adding
a couple variables and a print statement.

#+begin_src python :tangle editing.py :comments link
# We'll use these variabels to demonstrate some Emacs features later
hello_text = "Hello"
world_text = "world"

# Emacs 28.1+ has f-string syntax highlighting built in
print(f"{hello_text}, {world_text}!")
#+end_src

By visiting this file, Emacs automatically goes into =python-mode=,
offering a lot of new functionality that's only available while this
major mode is active.  If you're impatient like me and want to see
everything that's available right away, I'd start with =C-c C-h= from
the =editing.py= buffer to see key commands specific to =python-mode=,
and also use =C-h a .*python.* RET= to see /every/ command involving
the word "python" in some way.  Out of the box we also get syntax
highlighting, including within f-strings.

** Useful =C-c= commands

Emacs typically has commands that are specific to the /active/ major
mode bound to =C-c C-<letter>=.  What each <letter> does will depend
on the buffer you're currently in and what major mode is active.  In
our case, that's =python-mode=, which has a lot of handy shortcuts
already mapped out.

*** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python process".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i-!-
#+end_example

Where =-!-= is point (my cursor).  I then use =C-a= to move point back to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run-!- python3 -i
#+end_example

Leaving the =-i= isn't usually strictly necessary, but good if you
want to start by running a script, followed by dropping into the
REPL - useful for setting up some common variables or functions.

*** =C-c C-z= jumps to python REPL if already running
*** =C-c C-{c,e,r}= are the most common "chunk-sending" commands I use
*** =C-c C-v= or =M-x python-check=; more on these later

** =python-skeleton-...=
Using =C-c C-t d= and =C-c C-t c= it's easy to insert new =def= and
=class= statements.  (Think =t= for "template", =d= for "def", and =c= for "class")

#+begin_src python :tangle editing.py :comments link
import random
import matplotlib.pyplot as plt


def random_line(title: str = "", num_xs: int = 0):
    """My guy is ALWAYS there for me"""

    xs = list(range(num_xs))
    ys = [random.random.rand() for _ in xs]

    fig, ax = plt.subplots()
    ax.set(title=title)
    ax.plot(xs, ys)
    fig.show()


random_line()


class Wow:
    """My man!"""

    pass
#+end_src



** =imenu=
Collects symbol refrences in the current buffer so we can fuzzy-search
and jump to them.  Suppose we

* Running
** =M-&= to run simple commands like =poetry update= that don't require compiler parsing
*** =M-& python3 -m venv .venv=
*** =M-& .venv/bin/python -m pip install pyright=
** =.dir-locals.el= for setting virtual environment, language server preferences
** =C-u M-x run-python= and =C-u C-c C-p= to start python shell as =poetry run python=
** =python-shell-send-...=

** poetry install from a shell
** Running /as a script/ with =M-x compile=
This mode has built-in error parsing support, so it's superior when
trying to run a script for real and we want to quickly jump to any
error messages that come up.  Conversely, the =M-&= async shell
command does /not/ have error parsing, so it's not the right tool for
launching processes we have to debug.


* Debugging
** =M-x pdb=
** Create a simple python script with a few obvious errors

To start, let's make a python script that's riddled with errors

#+begin_src python :tangle errors.py :comments link
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

I want to set up an easy system for debugging, fixing, and re-running
this script.  A good setup should tell me:

1. Until we install it, =requests= is an unknown import
2. There's an unknown import =aaaaaaa=
3. =typing= doesn't have an attribute =fdafdsafdsafdsafdsafdsafdsa=
4. We can't add a =str= type to an =int= inside the body of =whatever=

The stack I'm going to use for this consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing /exact/ version
numbers for project collaborators to install.  All of these are
automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever - making their
notebook totally impossible to recreate.

** =M-x python-check= to run =poetry run pyright=
*** =mypy= error parsing appears to be supported out of the box
*** =conda= or vanilla version would be something like =.venv/bin/pyright=


* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py/
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors


* Also can use =M-x compile= for =poetry= commands
** How to fix the ansi color issue
*** GIF of running colors


* Org mode, babel, tangling, and untangling
** Demo using this document?


* =pyvenv= package is /absolutely/ necessary once we want seamless shell/lsp integration

[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
