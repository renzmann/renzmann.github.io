#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* Intro
** Not many great up-to date guides on Python in Emacs
** Most immediately tell you to install a bunch of packages like elpy, virtual environment wrappers, or lsp-mode
** Going to get to =eglot= eventually, but first what can we do without it?
*** (spiderman meme "nothing without LSP")

* Editing

Let's get our feet wet just bopping around some Python at first.  I'm
going to start up a new python file with =C-x C-f= and naming my file
=editing.py=.  Typing code as I usually do, I'm going to start by just adding
a simple variable and a print statement.

#+begin_src python :tangle editing.py :comments link
hello_text = "Hello, world!"

print(hello_text)
#+end_src

** python-mode

By visiting this file, Emacs automatically goes into =python-mode=,
offering a lot of new functionality that's only available while this
major mode is active.  If you're impatient like me and want to see
everything that's available right away, I'd start with =C-c C-h= from
the =editing.py= buffer to see key commands specific to =python-mode=,
and also use =C-h a .*python.* RET= to see /every/ command involving
python in some way.

** useful =C-c= commands
*** =C-c C-z= jumps to python REPL if already running
*** =C-c C-{c,e,r}= are the most common "chunk-sending" commands I use
*** =C-c C-v= or =M-x python-check=; more on these later

** =imenu=

* Running
** =python-shell-send-...=
** =python-skeleton-...=
** poetry install from a shell
** =C-u C-c C-p= to start python shell as =poetry run python=
** Running /as a script/ with =M-x compile=
This mode has built-in error parsing support, so it's superior when
trying to run a script for real and we want to quickly jump to any
error messages that come up.


* Debugging
** =M-x pdb=
** Create a simple python script with a few obvious errors

To start, let's make a python script that's riddled with errors

#+begin_src python :tangle errors.py :comments link
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

I want to set up an easy system for debugging, fixing, and re-running
this script.  A good setup should tell me:

1. Until we install it, =requests= is an unknown import
2. There's an unknown import =aaaaaaa=
3. =typing= doesn't have an attribute =fdafdsafdsafdsafdsafdsafdsa=
4. We can't add a =str= type to an =int= inside the body of =whatever=

The stack I'm going to use for this consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing /exact/ version
numbers for project collaborators to install.  All of these are
automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever - making their
notebook totally impossible to recreate.

** =M-x python-check= to run =poetry run pyright=
*** =conda= or vanilla version would be something like =.venv/bin/pyright=


* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py/
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors


* Also can use =M-x compile= for =poetry= commands
** How to fix the ansi color issue
*** GIF of running colors


* Org mode, babel, tangling, and untangling
** Demo using this document?

[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
