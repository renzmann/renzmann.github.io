#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* TODO Errata
Previously I said I'd use melpa-stable:
https://www.reddit.com/r/emacs/comments/etikbz/speaking_as_a_package_maintainer_please_do_not/
I think I should go back and change the previous article.  Even MELPA
says don't use it: https://stable.melpa.org/#/getting-started.  Should
also go over committing the ~/.emacs.d/elpa directory for reproducable
configs.

* Intro
** Not many great up-to date guides on Python in Emacs
** Most immediately tell you to install a bunch of packages like elpy, pyvenv, eglot, or lsp-mode
** Those packages do amazing things, but first we need to know what problem they solve.
** Going to get to =eglot= eventually, but first what can we do without it?

[[file:nothing_without_lsp.png]]


* Editing

Let's get our feet wet just bopping around some Python buffers first.  I'm
going to start up a new python file with =C-x C-f= and naming my file
=editing.py=.  Typing code as I usually do, I'm going to start by just adding
a couple variables and a print statement.

#+begin_src python :tangle editing.py :comments link
# We'll use these variabels to demonstrate some Emacs features later
hello_text = "Hello"
world_text = "world"

# Emacs 28.1+ has f-string syntax highlighting built in
print(f"{hello_text}, {world_text}!")
#+end_src

By visiting this file, Emacs automatically goes into =python-mode=,
which turns on a lot of Python-specific functionality while editing
this buffer.  If you're impatient like me and want to see everything
that's available right away, I'd start with =C-c C-h= from the
=editing.py= buffer to see key commands specific to =python-mode=, and
also use =C-h a .*python.* RET= to see /every/ command involving the
word "python" in some way.  Out of the box we also get syntax
highlighting, including within f-strings.

** Useful =C-c= commands

Emacs typically has commands that are specific to the /active/ major
mode bound to =C-c C-<letter>=.  What each <letter> does will depend
on the buffer you're currently in and what major mode is active.  In
our case, that's =python-mode=, which has a lot of handy shortcuts
already mapped out.

*** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python shell".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i█
#+end_example

Where =█= is point (my cursor).  I then use =C-a= to move point back
to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run █python3 -i
#+end_example

Leaving the =-i= isn't usually strictly necessary, but good if you
want to start by running a script, followed by dropping into the
REPL - useful for setting up some common variables or functions.

*** =C-c C-z= jumps to python REPL if already running

Once the REPL is running, this is a very handy one for swapping back
and forth between a file I'm actively editing and a running Python
process

*** =C-c C-{c,e,r}= for sending chunks to the REPL

A handy complement to =C-c C-z=, these commands are for taking pieces
of Python that I'm actively editing and sending them to the Python
buffer all at once.

*** =C-c C-v= or =M-x python-check=

More on these later...

*** =python-skeleton-...=

Using =C-c C-t d= and =C-c C-t c= it's easy to insert new =def= and
=class= statements (think =t= for "template", =d= for "def", and =c=
for "class").  Ater invoking one of these, Emacs will guide us through
the process of filling out each part needed to define a new function
or class via the minibuffer.

#+begin_src python :session :tangle editing.py :comments link
# editing.py
# --snip--
# Here we use `C-c C-t d` and follow the prompts to design a new
# function signature
def whatever(my_string: str = hello_text, my_integer: int = 0):
    """Whatever, man"""
    return f"{hello_text}, {my_integer}"


# Next, `C-c C-t c` to make a new class
class MyGuy:
    """My guy is ALWAYS there for me"""
    pass
#+end_src
**** TODO GIF here of using it?


* Running
Starting simple, we'll start by invoking the system Python for our
script, and add virtual environment complexity once that gets
comfortable.

** As a script with =M-x compile=
This mode has built-in error parsing support, so it's superior when
trying to run a script for real and we want to quickly jump to any
error messages that come up.  Conversely, the =M-&= async shell
command does /not/ have error parsing, so it's not the right tool for
launching processes we have to debug.  Take a hello world example:

#+begin_src python :session :tangle hello.py :comments link
# hello.py
print("Hello, world!")
#+end_src

If we run =M-x compile= and give it an argument of =python3 hello.py=, up pops the
=*compilation*= buffer, with the starting time, output of our program, and finish time.

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:50:39

python3 hello.py
Hello, world!

Compilation finished at Sun Aug 14 13:50:39
#+end_example

Now, let's add an error:

#+begin_src python :session :tangle hello_error.py :comments link
# hello_error.py
print("Not an error yet!")
fdafdsafdsafdsa
print("Shouldn't make it here...")
#+end_src

Now, =M-x compile= will error out:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:53:26

python3 hello_error.py
Not an error yet!
Traceback (most recent call last):
  File "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/hello_error.py", line 4, in <module>
    fdafdsafdsafdsa
NameError: name 'fdafdsafdsafdsa' is not defined

Compilation exited abnormally with code 1 at Sun Aug 14 13:53:26
#+end_example

Emacs is smart enough to understand and parse the error message.
After "compiling", we can use =M-g M-n= and =M-g M-p= to move between
error messages, or just use the link provided by the =*compilation*=
buffer directly.

If just parsing Python tracebacks doesn't excite you, =mypy= is also
supported out of the box.  Assuming =mypy= is already installed, =M-x
compile= with =mypy hello_error.py= as the command results in this:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:02:03

.venv/bin/mypy hello_error.py
hello_error.py:4: error: Name "fdafdsafdsafdsa" is not defined
Found 1 error in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:02:04
#+end_example

The =hello_error.py:4: error: ...= message will be a functional link, just as
before.  =mypy= is much more suitable for general error-checking though, so as
scripts (and bugs) grow, the =M-x compile= command can keep up:

#+begin_src python :tangle errors.py :comments link
# errors.py
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

#+begin_example
M-x compile mypy errors.py
#+end_example

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:06:55

.venv/bin/mypy errors.py
errors.py:6: error: Cannot find implementation or library stub for module named "aaaaaaa"
errors.py:6: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
errors.py:8: error: Name "foo" is not defined
errors.py:9: error: Module has no attribute "fdafdsafdsafdsafdsafdsafdsa"
errors.py:14: error: Unsupported operand types for + ("str" and "int")
Found 4 errors in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:06:55
#+end_example

Now, we can use =M-g M-n= and =M-g M-p= to quickly navigate between
the errors in our code, even after navigating away from the original
=errors.py= buffer - Emacs will remember what's going on in the
=*compilation*= buffer so we can hop all around the code base while
addressing errors one at a time.

* =M-&= to run simple commands like =poetry update= that don't require compiler parsing
* TODO =M-& python3 -m venv .venv=
* TODO =M-& c.venv/bin/python -m pip install pyright=
* TODO =.dir-locals.el= for setting virtual environment
  Setting both "mypy" as the check command and =.venv= as the virtualenv root:

  #+begin_src elisp
    # .dir-locals.el
    ((python-mode . ((python-check-commmand . "mypy")
		     (python-shell-virtualenv-root . "/home/robb/repos/project-name/.venv"))))
  #+end_src

  The virtualenv root part only affects running python as a shell
  within emacs, it does /not/ affect things like PATH, async commands,
  or =M-x compile=.  It's easy to add things to this via =M-x
  add-dir-local-variable=.

* Debugging
** using python builtin =breakpoint()= and sending things to shell
   This will automatically break into pdb/ipdb, jump to the breakpoint in the
   code, and put an arrow at the next line to execute.

** =M-x pdb=
** Create a simple python script with a few obvious errors

To start, let's make a python script that's riddled with errors

I want to set up an easy system for debugging, fixing, and re-running
this script.  Looking at the script above, a good setup should tell me:

1. Until we install it, =requests= is an unknown import
2. There's an unknown import =aaaaaaa=
3. =typing= doesn't have an attribute =fdafdsafdsafdsafdsafdsafdsa=
4. We can't add a =str= type to an =int= inside the body of =whatever=

Ideally, we'd also get all this error checking up front, and not
one-by-one from running the script multiple times.  The stack I'm
going to use for this consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing exact dependency
version numbers for project collaborators to install.  All of these
are automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever.

Starting out, we can use an asynchronous shell command to set up a
poetry environment for the project by using =M-&=, while =errors.py=
is still the active buffer:

#+begin_example
Async shell command: poetry init -n --python=^3.10
#+end_example

Assuming the poetry command ran without error, it plopped down the
=pyproject.toml= in the same directory as =errors.py=.  In a similar vein,
let's add a couple dependencies:

#+begin_example
Async shell command: poetry add pyright requests
#+end_example

The =*Async Shell Command*= buffer will update as poetry runs and
installs the required dependencies.  Following this, we should have
the =pyright= CLI installed to the virtual environment poetry set up
for us.  As a sanity check, I'll start up either =M-x shell= or =M-x
eshell= (whichever happens to be behaving better that day) to just get
a simple cross-platform shell running where I can try it out:

#+begin_example
~/tmp $ poetry run pyright errors.py
Creating virtualenv 006-emacs-2-python-QKcV4YYo-py3.10 in /home/robb/.cache/pypoetry/virtualenvs
No configuration file found.
pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python.
Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml
Pyproject file "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml" is missing "[tool.pyright]" section.
stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory.
Assuming Python platform Linux
Searching for source files
Found 1 source file
/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import "aaaaaaa" could not be resolved (reportMissingImports)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: "fdafdsafdsafdsafdsafdsafdsa" is not a known member of module (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" when expected type is "str" (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import "requests" could not be resolved from source (reportMissingModuleSource)
4 errors, 2 warnings, 0 informations
Completed in 1.033sec
#+end_example

Emacs actually has a couple ways of running error-checking tools like
this.  The typical one is =M-x compile=, which we saw earlier, but
there's also =C-c C-v= for =M-x python-check=.

** =M-X Python-check= to run =poetry run pyright=
*** =conda= or vanilla version would be something like =.venv/bin/pyright=

* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py/
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors

* Org mode, babel, tangling, and untangling
** Demo using this document?

* TODO completion using the process in the background
  python.el recommends using =C-c C-c= periodically.  =if __name__ ==
  "__main__"= blocks do /not/ execute when using =C-c C-c= without the
  universal argument =C-u C-c C-c=.  So if code is written with the
  main chunk inside the =if= statement, we can get completion without
  actually running the main part.

* TODO semantic-mode for more intelligent completion

* TODO setting up builtin completion

* TODO literate programming (ala Jupyter) with Org - builtin, but needs a couple lines of config
* =pyvenv= package is /absolutely/ necessary once we want seamless shell/lsp integration and can't use poetry

* Also can use =M-x compile= for =poetry= commands
** How to fix the ansi color issue

* Footnotes
[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
[fn:ddavis-workon] https://ddavis.io/posts/emacs-python-lsp/
