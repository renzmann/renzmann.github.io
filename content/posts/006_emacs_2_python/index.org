#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* Intro
There are a lot of great guides on getting set up with Python in
Emacs.  A lot of them have titles like "Emacs as a Python IDE", and
start off by installing =pyvenv= for virtual environment management,
=eglot= or =lsp-mode= for autocomplete/error checking, and maybe
a host of other non-python things, like the =helm= or =projectile=
packages.

This is not that guide.

This guide is for picky @#$%!s like me who need to understand and
exhaust every builtin capability before reaching out to external
dependencies I'll also have to learn and manage.  Once I /really/
understand what =pyvenv= is solving, then, and /only/ then, will I add
it to my =package-selected-packages=.

Despite the excellent swath of materials both new and old on how to
get IDE-like performance for Python out of Emacs, the collected
materials on just running "vanilla extract" are fairly scant.  This
guide is one attempt to introduce a reasonable workflow in Python
using nothing but the builtin capabilities of Emacs 28.1+.

[[file:nothing_without_lsp.png]]


* Editing
Let's get our feet wet just bopping around some Python buffers first.  I'm
going to start up a new python file with =C-x C-f= and naming my file
=editing.py=.  Typing code as I usually do, I'm going to start by just adding
a couple variables and a print statement.

#+begin_src python :tangle editing.py :comments link
# These funtions are a little basic and silly right now, but we'll use
# them to showcase some Emacs features later on.
def hello_text():
    """Just gives back 'Hello'"""
    return "Hello"


def world_text():
    """Just gives back 'world!'"""
    return "world!"


# Emacs 28.1+ has f-string syntax highlighting built in
print(f"{hello_text()}, {world_text()}!")
#+end_src

By visiting this file, Emacs automatically goes into =python-mode=,
which turns on a lot of Python-specific functionality.  If you're
impatient like me and want to see everything that's available right
away, I'd start with =C-c C-h= from the =editing.py= buffer to see key
commands specific to =python-mode=, and also use =C-h a .*python.*
RET= to see /every/ command involving the word "python" in some way.
Out of the box we also get syntax highlighting, including within
f-strings.

** Useful =C-c= commands

Emacs typically has commands that are specific to the /active/ major
mode bound to =C-c C-<letter>=.  What each <letter> does will depend
on the buffer you're currently in and what major mode is active.  In
our case, that's =python-mode=, which has a lot of handy shortcuts
already mapped out.

*** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python shell".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i█
#+end_example

Where =█= is point (my cursor).  I then use =C-a= to move point back
to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run█python3 -i
#+end_example

Leaving the =-i= isn't usually strictly necessary, but good if you
want to start by running a script, followed by dropping into the
REPL - useful for setting up some common variables or functions.

*** =C-c C-z= jumps to python REPL if already running

Once the REPL is running, this is a very handy one for swapping back
and forth between a file I'm actively editing and a running Python
process

*** =C-c C-{c,e,r}= for sending chunks to the REPL

A handy complement to =C-c C-z=, these commands are for taking pieces
of Python that I'm actively editing and sending them to the Python
buffer all at once.

*** =C-c C-v= or =M-x python-check=

More on these later...

*** =python-skeleton-...=

Using =C-c C-t d= and =C-c C-t c= it's easy to insert new =def= and
=class= statements (think =t= for "template", =d= for "def", and =c=
for "class").  Ater invoking one of these, Emacs will guide us through
the process of filling out each part needed to define a new function
or class via the minibuffer.

#+begin_src python :session :tangle editing.py :comments link
# editing.py
# --snip--
# Here we use `C-c C-t d` and follow the prompts to design a new
# function signature
def whatever(my_string: str = hello_text, my_integer: int = 0):
    """Whatever, man"""
    return f"{hello_text}, {my_integer}"


# Next, `C-c C-t c` to make a new class
class MyGuy:
    """My guy is ALWAYS there for me"""
    pass
#+end_src
**** TODO GIF here of using it?


* Running
Starting simple, we'll start by invoking the system Python for our
script, and add virtual environment complexity once that gets
comfortable.

** As a script with =M-x compile=
This mode has built-in error parsing support, so it's superior when
trying to run a script for real and we want to quickly jump to any
error messages that come up.  Conversely, the =M-&= async shell
command does /not/ have error parsing, so it's not the right tool for
launching processes we have to debug.  Take a hello world example:

#+begin_src python :session :tangle hello.py :comments link
# hello.py
print("Hello, world!")
#+end_src

If we run =M-x compile= and give it an argument of =python3 hello.py=, up pops the
=*compilation*= buffer, with the starting time, output of our program, and finish time.

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:50:39

python3 hello.py
Hello, world!

Compilation finished at Sun Aug 14 13:50:39
#+end_example

Now, let's add an error:

#+begin_src python :session :tangle hello_error.py :comments link
# hello_error.py
print("Not an error yet!")
fdafdsafdsafdsa
print("Shouldn't make it here...")
#+end_src

Now, =M-x compile= will error out:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:53:26

python3 hello_error.py
Not an error yet!
Traceback (most recent call last):
  File "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/hello_error.py", line 4, in <module>
    fdafdsafdsafdsa
NameError: name 'fdafdsafdsafdsa' is not defined

Compilation exited abnormally with code 1 at Sun Aug 14 13:53:26
#+end_example

Emacs is smart enough to understand and parse the error message.
After "compiling", we can use =M-g M-n= and =M-g M-p= to move between
error messages, or just use the link provided by the =*compilation*=
buffer directly.

If just parsing Python tracebacks doesn't excite you, =mypy= is also
supported out of the box.  Assuming =mypy= is already installed, =M-x
compile= with =mypy hello_error.py= as the command results in this:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:02:03

.venv/bin/mypy hello_error.py
hello_error.py:4: error: Name "fdafdsafdsafdsa" is not defined
Found 1 error in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:02:04
#+end_example

The =hello_error.py:4: error: ...= message will be a functional link, just as
before.  =mypy= is much more suitable for general error-checking though, so as
scripts (and bugs) grow, the =M-x compile= command can keep up:

#+begin_src python :tangle errors.py :comments link
# errors.py
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

#+begin_example
M-x compile mypy errors.py
#+end_example

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:06:55

.venv/bin/mypy errors.py
errors.py:6: error: Cannot find implementation or library stub for module named "aaaaaaa"
errors.py:6: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
errors.py:8: error: Name "foo" is not defined
errors.py:9: error: Module has no attribute "fdafdsafdsafdsafdsafdsafdsa"
errors.py:14: error: Unsupported operand types for + ("str" and "int")
Found 4 errors in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:06:55
#+end_example

Now, we can use =M-g M-n= and =M-g M-p= to quickly navigate between
the errors in our code, even after navigating away from the original
=errors.py= buffer - Emacs will remember what's going on in the
=*compilation*= buffer so we can hop all around the code base while
addressing errors one at a time.


** Also can use =M-x compile= for =poetry= commands
*** How to fix the ansi color issue

* TODO completion using the process in the background
Requires the "Editing" and "Running" sections before this.  python.el
recommends using =C-c C-c= periodically.  =if __name__ == "__main__"=
blocks do /not/ execute when using =C-c C-c= without the universal
argument =C-u C-c C-c=.  So if code is written with the main chunk
inside the =if= statement, we can get completion without actually
running the main part.

Using =C-c C-c=, of course, is unsafe compared to static analysis
tools like =pyflakes=, =mypy=, and =pyright=.


* Debugging
** using python builtin =breakpoint()= and sending things to shell
   This will automatically break into pdb/ipdb, jump to the breakpoint in the
   code, and put an arrow at the next line to execute.

** =M-x pdb=
** Create a simple python script with a few obvious errors

To start, let's make a python script that's riddled with errors

I want to set up an easy system for debugging, fixing, and re-running
this script.  Looking at the script above, a good setup should tell me:

1. Until we install it, =requests= is an unknown import
2. There's an unknown import =aaaaaaa=
3. =typing= doesn't have an attribute =fdafdsafdsafdsafdsafdsafdsa=
4. We can't add a =str= type to an =int= inside the body of =whatever=

Ideally, we'd also get all this error checking up front, and not
one-by-one from running the script multiple times.  The stack I'm
going to use for this consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing exact dependency
version numbers for project collaborators to install.  All of these
are automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever.

Starting out, we can use an asynchronous shell command to set up a
poetry environment for the project by using =M-&=, while =errors.py=
is still the active buffer:

#+begin_example
Async shell command: poetry init -n --python=^3.10
#+end_example

Assuming the poetry command ran without error, it plopped down the
=pyproject.toml= in the same directory as =errors.py=.  In a similar vein,
let's add a couple dependencies:

#+begin_example
Async shell command: poetry add pyright requests
#+end_example

The =*Async Shell Command*= buffer will update as poetry runs and
installs the required dependencies.  Following this, we should have
the =pyright= CLI installed to the virtual environment poetry set up
for us.  As a sanity check, I'll start up either =M-x shell= or =M-x
eshell= (whichever happens to be behaving better that day) to just get
a simple cross-platform shell running where I can try it out:

#+begin_example
~/tmp $ poetry run pyright errors.py
Creating virtualenv 006-emacs-2-python-QKcV4YYo-py3.10 in /home/robb/.cache/pypoetry/virtualenvs
No configuration file found.
pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python.
Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml
Pyproject file "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml" is missing "[tool.pyright]" section.
stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory.
Assuming Python platform Linux
Searching for source files
Found 1 source file
/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import "aaaaaaa" could not be resolved (reportMissingImports)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: "fdafdsafdsafdsafdsafdsafdsa" is not a known member of module (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" when expected type is "str" (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import "requests" could not be resolved from source (reportMissingModuleSource)
4 errors, 2 warnings, 0 informations
Completed in 1.033sec
#+end_example

Emacs actually has a couple ways of running error-checking tools like
this.  The typical one is =M-x compile=, which we saw earlier, but
there's also =C-c C-v= for =M-x python-check=.


*** =conda= or vanilla version would be something like =.venv/bin/pyright=

* Virtual Environments
** =M-&= to run simple commands like =poetry update= that don't require compiler parsing
** TODO =M-& python3 -m venv .venv=
** TODO =M-& c.venv/bin/python -m pip install pyright=
** =M-X python-check= to run =poetry run pyright=
** TODO =.dir-locals.el= for setting virtual environment
Setting both "mypy" as the check command and =.venv= as the virtualenv root:

#+begin_src elisp
# .dir-locals.el
((python-mode . ((python-check-commmand . "mypy")
		 (python-shell-virtualenv-root . ".venv"))))
#+end_src

The virtualenv root part only affects running python as a shell
within emacs, it does /not/ affect things like PATH, async commands,
or =M-x compile=.  It's easy to add things to this via =M-x
add-dir-local-variable=.



* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors

* Org mode, babel, tangling, and untangling
** Demo using this document?


* TODO semantic-mode for more intelligent completion
  This looks like an aborted first attempt at what would eventually
  become the language server protocol.  It flat out doesn't work on
  Windows, even after extensive searches for how to fix it.

* TODO All things considered: =pyvenv=
  My use case typically consists of working on many small, isolated
  python projects, each in their own environment.  The vanilla python
  experience is well suited for writing and running system-level
  python scripts, which is one completley valid way of using Python.
  Data science is a different beast, however.  This is an easy way to
  ensure that our language server is running off the correct
  environment.

  If =poetry= is out the door, then this goes from
  nice-to-have to /absolutely necessary./

* TODO literate programming (ala Jupyter) with Org - builtin, but needs a couple lines of config
* TODO =pyvenv= package is /absolutely/ necessary once we want seamless shell/lsp integration and can't use poetry


* Footnotes
[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
[fn:ddavis-workon] https://ddavis.io/posts/emacs-python-lsp/
