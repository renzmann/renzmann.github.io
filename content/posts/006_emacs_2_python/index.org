#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* Intro
There are a lot of great guides on getting set up with Python in
Emacs.  Many of them have titles like "Emacs as a Python IDE", and
start off by installing =pyvenv= for virtual environment management,
=eglot= or =lsp-mode= for autocomplete/error checking, and maybe
a host of other non-python things, like the =helm= or =projectile=
packages.

This is not that guide.

This guide is for picky @#$%!s like me who need to understand and
exhaust every builtin capability before reaching out to external
dependencies.  Dependencies that, in turn, I will also have to learn
and manage.  Once I /really/ understand what =pyvenv= is solving,
then, and /only/ then, will I add it to my
=package-selected-packages=.

Despite the excellent swath of materials both new and old on how to
get IDE-like performance for Python out of Emacs, the collected
materials on just running "vanilla extract" are fairly scant.  The
builtin =python.el= documentation is thorough, the keybindings easily
discoverable, but not all documentation is collated into a single
place.  This guide is one attempt to remedy that, and introduce a
reasonable workflow in Python using nothing but the builtin
capabilities of Emacs 28.1+.  That all said, the examples and
walkthroughs presented here are designed for =emacs -q= -
i.e. starting emacs without any user configuration or your
distribution's =default.el=.


[[file:nothing_without_lsp.png]]


* Editing

Let's get our feet wet by bopping around some Python buffers first.
I'm going to start up a new python file with =C-x C-f= and naming my
file =editing.py=.  I'm going to start by just adding a couple
functions and a print statement, obfuscating the typical "Hello, world!" example a bit
by introducing some functions and a "main" section right away.

#+begin_src python :tangle editing.py :comments link
# These funtions are a little basic and silly right now, but we'll use
# them to showcase some Emacs features later on.
def hello_text():
    """Just gives back 'Hello'"""
    return "Hello"


def world_text():
    """Just gives back 'world!'"""
    return "world!"


if __name__ == "__main__":
    # Emacs 28.1+ has f-string syntax highlighting built in
    print(f"{hello_text()}, {world_text()}!")
#+end_src

By visiting this file, Emacs automatically goes into =python-mode=,
which turns on a lot of Python-specific functionality.  If you're
impatient like me and want to see everything that's available right
away, I'd start with =C-c C-h= from the =editing.py= buffer to see key
commands specific to =python-mode=, and also use =C-h a .*python.*
RET= to see /every/ command involving the word "python" in some way.
Out of the box we also get syntax highlighting, including within
f-strings.

** Useful =C-c= commands

Emacs typically has commands that are specific to the /active/ major
mode bound to =C-c C-<letter>=.  What each <letter> does will depend
on the buffer you're currently in and what major mode is active.  In
our case, that's =python-mode=, which has a lot of handy shortcuts
already mapped out.

*** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python shell".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i█
#+end_example

Where =█= is point (my cursor).  I then use =C-a= to move point back
to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run█python3 -i
#+end_example

Emacs is typically smart enough to figure out what to do even if we
leave off the =-i=, but generally it's good to leave it in there.

*** =C-c C-z= jumps to python REPL if already running

Once the REPL is running, this is a very handy one for swapping back
and forth between a file I'm actively editing and a running Python
process

*** =C-c C-{c,e,r}= for sending chunks to the REPL

A handy complement to =C-c C-z=, these commands are for taking pieces
of Python that I'm actively editing and sending them to the Python
buffer all at once.

*** =C-c C-v= or =M-x python-check=

More on this later...

*** =C-c C-t ...= or =python-skeleton-...=

Using =C-c C-t d= and =C-c C-t c= it's easy to insert new =def= and
=class= statements (think =t= for "template", =d= for "def", and =c=
for "class").  Ater invoking one of these, Emacs will guide us through
the process of filling out each part needed to define a new function
or class via the minibuffer.  Using =C-g= at any point while editing
the template wil revert the buffer back to its original state, as if
you never started filling out the skeleton.

#+begin_src python :session :tangle editing.py :comments link
# editing.py
# --snip--
# Here we use `C-c C-t d` and follow the prompts to design a new
# function signature.
def whatever(my_string: str = hello_text, my_integer: int = 0):
    """Whatever, man"""
    return f"{hello_text}, {my_integer}"

# Next, `C-c C-t c` to make a new class
class MyGuy:
    """My guy is ALWAYS there for me"""
    pass
# --snip-- "__main__"
#+end_src


** =C-c C-j= or =M-x imenu=
The nimble, builtin =imenu= is a way to quickly navigate between major
symbol definitions in the current buffer - especially those off
screen.  In our =editing.py= we now have three functions,
=hello_text()=, =world_text()=, and =whatever()=, and one class
=MyGuy=.  If we use =C-c C-j=, a minibuffer menu like this comes up:

#+begin_example
1/5 Index item: █
*Rescan*
MyGuy.(class)
whatever.(def)
world_text.(def)
hello_text.(def)
#+end_example

My minibuffer displays a vertical preview of the options because I've
set =(fido-mode)= and =(vertical-fido-mode)= in my =init.el=, both of
which are included in Emcacs 28.1 or later.  Then, if I partially type out a result the list will filter down to possible completions:

#+begin_example
1/1 Index item: My█
MyGuy.(class)
#+end_example

=imenu= is very, very handy across Emacs, not just for Python, so it's
worth trying in a variety of major modes.

* Running

Now its time to actually start executing some code.  We'll start simple
by invoking the system Python for our script, and add virtual
environment complexity once that feels comfortable.

** As a script with =M-x compile=
This mode has built-in error parsing, so it's the best way to run a
script for real if we want to quickly navigate any traceback messages
that come up.  Conversely, the =M-&= async shell command does /not/
have error parsing, so it's not the right tool for launching processes
we have to debug.  Same goes for booting up a shell and running python
from there.  Taking our script from the previous section, if we run
=M-x compile= and give it an argument of =python3 editing.py=, up pops
the =*compilation*= buffer, with the starting time, output of our
program, and finish time.

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:50:39

python3 editing.py
Hello, world!

Compilation finished at Sun Aug 14 13:50:39
#+end_example

Now, let's try a different script, with an error in it:

#+begin_src python :session :tangle hello_error.py :comments link
# hello_error.py
print("Not an error yet!")
fdafdsafdsafdsa
print("Shouldn't make it here...")
#+end_src

Now, =M-x compile= will error out:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 13:53:26

python3 hello_error.py
Not an error yet!
Traceback (most recent call last):
  File "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/hello_error.py", line 4, in <module>
    fdafdsafdsafdsa
NameError: name 'fdafdsafdsafdsa' is not defined

Compilation exited abnormally with code 1 at Sun Aug 14 13:53:26
#+end_example

Emacs will parse the error message, so that after "compiling", we can
use =M-g M-n= and =M-g M-p= to move between error messages, or just
click the link provided by the =*compilation*= buffer directly.

If just parsing Python tracebacks doesn't excite you, =mypy= is also
supported out of the box.  Assuming =mypy= is already installed, =M-x
compile= with =mypy hello_error.py= as the command results in this:

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:02:03

.venv/bin/mypy hello_error.py
hello_error.py:4: error: Name "fdafdsafdsafdsa" is not defined
Found 1 error in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:02:04
#+end_example

The =hello_error.py:4: error: ...= message will be a functional link, just as
before.  =mypy= is much more suitable for general error-checking though, so as
scripts (and bugs) grow, the =M-x compile= command can keep up:

#+begin_src python :tangle errors.py :comments link
# errors.py
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

#+begin_example
M-x compile RET mypy errors.py
#+end_example

#+begin_example
-*- mode: compilation; default-directory: "~/repos/renzmann.github.io/content/posts/006_emacs_2_python/" -*-
Compilation started at Sun Aug 14 14:06:55

.venv/bin/mypy errors.py
errors.py:6: error: Cannot find implementation or library stub for module named "aaaaaaa"
errors.py:6: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports
errors.py:8: error: Name "foo" is not defined
errors.py:9: error: Module has no attribute "fdafdsafdsafdsafdsafdsafdsa"
errors.py:14: error: Unsupported operand types for + ("str" and "int")
Found 4 errors in 1 file (checked 1 source file)

Compilation exited abnormally with code 1 at Sun Aug 14 14:06:55
#+end_example

Now, we can use =M-g M-n= and =M-g M-p= to quickly navigate between
the errors in our code, even after navigating away from the original
=errors.py= buffer - Emacs will remember what's going on in the
=*compilation*= buffer so we can hop all around the code base while
addressing errors one at a time.

** Interactively with the Python shell

=python-mode= centers heavily around the use of an active, running
Python session for some of its features, as we'll see in the [[*Code
Completion]] section.  Its documentation recommends regular use of =C-c
C-c=, which sends the entire buffer to the active inferior Python
process.  That means actually /executing/ Python code, which may feel
a bit dangerous for those of us who grew up with static
analysis tools.  So the first thing we need to make sure we don't
accidentally kick off our whole script is ensure that the main part of
our program is properly encased.

#+begin_src python
# editing.py
# --snip--
if __name__ == "__main__":
    print(f"{hello_text()}, {world_text()}!")
#+end_src

** Also can use =M-x compile= for =poetry= commands
*** How to fix the ansi color issue

* TODO Code Completion
Requires the "Editing" and "Running" sections before this.  python.el
recommends using =C-c C-c= periodically.  =if __name__ == "__main__"=
blocks do /not/ execute when using =C-c C-c=.  To send all code in the
current buffer, including the =__main__= block, instead we must use
=C-u C-c C-c=.

I tend to prefer just being able to hit =TAB= instead of the more
cumbersome =C-M-i= or =M-TAB= for =completion-at-point=, so I use this snippet in my
=init.el=:

#+begin_src elisp
;; init.el
;; Use TAB in place of C-M-i for completion-at-point
(setq tab-always-indent 'complete)
#+end_src

Next, in our python file =editing.py=, I know we have a function
called =hello_text()=.  Within the main block, I might have been
typing something that looked like this:

#+begin_src python
if __name__ == "__main__":
    print("{hell█
#+end_src

Where █ is where point currently sits.  Attempting a
=completion-at-point= using =C-M-i= (or just =TAB= as I have re-bound
it above) will yield ... nothing.  Maybe the indentation cycles, or it
says "No match", or just - no response.  What we require is an
inferior Python process that knows how to complete symbols before
=completion-at-point= starts working.  After booting up Python with
=C-c C-p= and sending all the current buffer contents with =C-c C-c=,
hitting =TAB= completes the =hell= into =hello_text=:

#+begin_src python
if __name__ == "__main__":
    print("{hello_text█
#+end_src

In the case that the completion is ambiguous, a =*completions*= buffer
will pop up, prompting for input on how to continue.  Another nice
thing about this completion method is that it respects your
=completion-styles= setting.  Personally, I keep mine globally set to
include the =flex= style:

#+begin_src elisp
;; init.el
(setq completion-styles '(flex basic partial-completion emacs22))
#+end_src

This allows me to type something like =hltx=, hit =TAB= and it
completes to =hello_text=, using the familiar "fuzzy" style of
matching many of us have become used to in other editors.

* Debugging
** using python builtin =breakpoint()= and sending things to shell

This will automatically break into pdb/ipdb, jump to the breakpoint in
the code, and put an arrow at the next line to execute.

** =M-x pdb=

Simply populates the command to run with =python -m pdb=.  Can be
configured with the variable =gud-pdb-command-name=

** The =poetry= + =pyright= stack

The stack I use most frequently (as of writing) consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing exact dependency
version numbers for project collaborators to install.  All of these
are automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever.

Earlier we mentioned that running our Python scripts via the =M-&=
async shell command interface wasn't a great use case for it.
However, using it to set up a poetry environment is a fantastic
example of when it is appropriate.

#+begin_example
Async shell command: poetry init -n --python=^3.10
#+end_example

Assuming the poetry command ran without error, it plopped down the
=pyproject.toml= in the same directory as =errors.py=.  In a similar
vein, we can add project dependencies using =M-&=

#+begin_example
Async shell command: poetry add pyright requests
#+end_example

The =*Async Shell Command*= buffer will update as poetry runs and
installs the required dependencies.  Following this, we should have
the =pyright= CLI installed to the virtual environment poetry set up
for us.  As a sanity check, I'll start up either =M-x shell= or =M-x
eshell= (whichever happens to be behaving better that day) to just get
a simple cross-platform shell running where I can try it out:

#+begin_example
~/tmp $ # using the same `errors.py` as in the earlier sectons
~/tmp $ poetry run pyright errors.py
No configuration file found.
pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python.
Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml
Pyproject file "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml" is missing "[tool.pyright]" section.
stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory.
Assuming Python platform Linux
Searching for source files
Found 1 source file
/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import "aaaaaaa" could not be resolved (reportMissingImports)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: "fdafdsafdsafdsafdsafdsafdsa" is not a known member of module (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" when expected type is "str" (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import "requests" could not be resolved from source (reportMissingModuleSource)
4 errors, 2 warnings, 0 informations
Completed in 1.033sec
#+end_example

Emacs actually has a couple ways of running error-checking tools like
this.  The typical one is =M-x compile=, which we saw earlier, but
there's also =C-c C-v= for =M-x python-check=.  The latter will
automatically check for tools like =pyflakes= or =flake8=, but can be
configured with the =python-check-command= variable to pre-populate
the command to run.  Like =M-x compile=, =M-x python-check= will use a
buffer that looks identical to =*compilation*= in every way except
name: it will be called the =*Python check: <command you ran>*=
buffer.

For me, that means I typically have something like

#+begin_src elisp
(setq python-check-command "poetry run pyright")
#+end_src

and then =C-c C-v= from a python buffer will prompt like this while
=errors.py= is my active buffer

#+begin_example
Check command: poetry run pyright errors.py
#+end_example

*** =conda= or vanilla version would be something like =.venv/bin/pyright=

* Virtual Environments
** =M-&= to run simple commands like =poetry update= that don't require compiler parsing
** TODO =M-& python3 -m venv .venv=
** TODO =M-& c.venv/bin/python -m pip install pyright=
** =M-X python-check= to run =poetry run pyright=
** TODO =.dir-locals.el= for setting virtual environment
Setting both "mypy" as the check command and =.venv= as the virtualenv root:

#+begin_src elisp :tangle .dir-locals.el
;; .dir-locals.el
((python-mode . ((python-check-command . "mypy")
                 (python-shell-virtualenv-root . ".venv"))))
#+end_src

The virtualenv root part only affects running python as a shell
within emacs, it does /not/ affect things like PATH, async commands,
or =M-x compile=.  It's easy to add things to this via =M-x
add-dir-local-variable=.


* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors

* Org mode, babel, tangling, and untangling
** Demo using this document?


* TODO semantic-mode for more intelligent completion
  This looks like an aborted first attempt at what would eventually
  become the language server protocol.  It flat out doesn't work on
  Windows, even after extensive searches for how to fix it.

* TODO All things considered: =pyvenv=
  My use case typically consists of working on many small, isolated
  python projects, each in their own environment.  The vanilla python
  experience is well suited for writing and running system-level
  python scripts, which is one completley valid way of using Python.
  Data science is a different beast, however.  This is an easy way to
  ensure that our language server is running off the correct
  environment.

  If =poetry= is out the door, then this goes from
  nice-to-have to /absolutely necessary./

* TODO literate programming (ala Jupyter) with Org - builtin, but needs a couple lines of config
* TODO =pyvenv= package is /absolutely/ necessary once we want seamless shell/lsp integration and can't use poetry


* Footnotes
[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
[fn:ddavis-workon] https://ddavis.io/posts/emacs-python-lsp/
