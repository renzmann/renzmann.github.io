#+title: Emacs Part 2: Python (Vanilla is a Powerful Flavor)
#+date: 2022-08-08
#+startup: inlineimages

* Intro
** Not many great up-to date guides on Python in Emacs
** Most immediately tell you to install a bunch of packages like elpy, pyvenv, eglot, or lsp-mode
** Those packages do amazing things, but first we need to know what problem they solve.
** Going to get to =eglot= eventually, but first what can we do without it?

[[file:nothing_without_lsp.png]]


* Editing

Let's get our feet wet just bopping around some Python buffers first.  I'm
going to start up a new python file with =C-x C-f= and naming my file
=editing.py=.  Typing code as I usually do, I'm going to start by just adding
a couple variables and a print statement.

#+begin_src python :tangle editing.py :comments link
# We'll use these variabels to demonstrate some Emacs features later
hello_text = "Hello"
world_text = "world"

# Emacs 28.1+ has f-string syntax highlighting built in
print(f"{hello_text}, {world_text}!")
#+end_src

By visiting this file, Emacs automatically goes into =python-mode=,
offering a lot of new functionality that's only available while this
major mode is active.  If you're impatient like me and want to see
everything that's available right away, I'd start with =C-c C-h= from
the =editing.py= buffer to see key commands specific to =python-mode=,
and also use =C-h a .*python.* RET= to see /every/ command involving
the word "python" in some way.  Out of the box we also get syntax
highlighting, including within f-strings.

** Useful =C-c= commands

Emacs typically has commands that are specific to the /active/ major
mode bound to =C-c C-<letter>=.  What each <letter> does will depend
on the buffer you're currently in and what major mode is active.  In
our case, that's =python-mode=, which has a lot of handy shortcuts
already mapped out.

*** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python process".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i-!-
#+end_example

Where =-!-= is point (my cursor).  I then use =C-a= to move point back
to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run-!- python3 -i
#+end_example

Leaving the =-i= isn't usually strictly necessary, but good if you
want to start by running a script, followed by dropping into the
REPL - useful for setting up some common variables or functions.

*** =C-c C-z= jumps to python REPL if already running

Once the REPL is running, this is a very handy one for swapping back
and forth between a file I'm actively editing and a running Python
process

*** =C-c C-{c,e,r}= for sending chunks to the REPL

A handy complement to =C-c C-z=, these commands are for taking pieces
of Python that I'm actively editing and sending them to the Python
buffer all at once.

*** =C-c C-v= or =M-x python-check=

More on these later...

*** =python-skeleton-...=

Using =C-c C-t d= and =C-c C-t c= it's easy to insert new =def= and
=class= statements (think =t= for "template", =d= for "def", and =c=
for "class").  Ater invoking one of these, Emacs will guide us through
the process of filling out each part needed to define a new function
or class via the minibuffer.

#+begin_src python :session :tangle editing.py :comments link
# editing.py
# --snip--
# Here we use `C-c C-t d` and follow the prompts to design a new
# function signature
def whatever(my_string: str = hello_text, my_integer: int = 0):
    """Whatever, man"""
    return f"{hello_text}, {my_integer}"


# Next, `C-c C-t c` to make a new class
class MyGuy:
    """My guy is ALWAYS there for me"""
    pass
#+end_src
**** TODO GIF here of using it?


* Running
Starting simple, we'll start by invoking the system Python for our
script, and add virtual environment complexity once that gets
comfortable.

** Running /as a script/ with =M-x compile=
This mode has built-in error parsing support, so it's superior when
trying to run a script for real and we want to quickly jump to any
error messages that come up.  Conversely, the =M-&= async shell
command does /not/ have error parsing, so it's not the right tool for
launching processes we have to debug.
** =M-&= to run simple commands like =poetry update= that don't require compiler parsing
*** =M-& python3 -m venv .venv=
*** =M-& .venv/bin/python -m pip install pyright=
** =.dir-locals.el= for setting virtual environment
Need to try this when working in a subdirectory.

** =C-u M-x run-python= and =C-u C-c C-p= to start python shell as =poetry run python=
** =python-shell-send-...=
** =C-c C-p= or =M-x run-python= to start a python REPL

This boots up what Emacs calls an "inferior Python process".
"Inferior" here just means that Python is running as a subprocess of
Emacs; not that there's some other, "superior" method of running a
Python process.  If you need to control the exact command Emacs runs
to start the shell, you can use the universal =C-u= prefix before
either =C-c C-p= or =M-x run-python= to edit the command Emacs runs.
Based on the [[https://robbmann.io/posts/005_emacs_1_packages/][previous article]], what I'm frequently doing is holding
down the Ctrl key with my left little finger, then rapidly typing =u=,
=c=, and =p= to get =C-u C-c C-p=, bringing up a minibuffer prompt
like this:

#+begin_example
Run Python: python3 -i-!-
#+end_example

Where =-!-= is point (my cursor).  I then use =C-a= to move point back
to the start and add a =poetry run=:

#+begin_example
Run Python: poetry run-!- python3 -i
#+end_example

Leaving the =-i= isn't usually strictly necessary, but good if you
want to start by running a script, followed by dropping into the
REPL - useful for setting up some common variables or functions.

** =C-c C-z= jumps to python REPL if already running

Once the REPL is running, this is a very handy one for swapping back
and forth between a file I'm actively editing and a running Python
process

** =C-c C-{c,e,r}= for sending chunks to the REPL

A handy complement to =C-c C-z=, these commands are for taking pieces
of Python that I'm actively editing and sending them to the Python
buffer all at once.  These can also be accessed via =M-x
python-shell-send-= prefixed-commands.

** =C-c C-v= or =M-x python-check=

** poetry install from a shell


* Debugging
** =M-x pdb=
** Create a simple python script with a few obvious errors

To start, let's make a python script that's riddled with errors

#+begin_src python :tangle errors.py :comments link
import typing

import requests
import aaaaaaa

foo
print(typing.fdafdsafdsafdsafdsafdsafdsa)


def whatever(x: str) -> str:
    """Here's a docstring!"""
    return x + 1
#+end_src

I want to set up an easy system for debugging, fixing, and re-running
this script.  Looking at the script above, a good setup should tell me:

1. Until we install it, =requests= is an unknown import
2. There's an unknown import =aaaaaaa=
3. =typing= doesn't have an attribute =fdafdsafdsafdsafdsafdsafdsa=
4. We can't add a =str= type to an =int= inside the body of =whatever=

Ideally, we'd also get all this error checking up front, and not
one-by-one from running the script multiple times.  The stack I'm
going to use for this consists of:

1. =python3.10= as the Python runtime
2. =poetry= for dependency and environment management[fn:poetry]
3. =pyright= for error checking[fn:pyright]
4. =emacs= for everything else

Each component should, in theory, be easy to replace.  That is, if I
want =conda= as a package manager and =flake8= or =mypy= for
linting/type checking, it should be easy to do a drop-in replacement
for them.

For those who haven't heard the good news of =poetry=, it takes care
of a /lot/ of headaches that every pythonista regularly deals with.
It manages your virtual environment (creation and update),
=pyproject.toml= specification, and a =poetry.lock= file that serves
as a replacement for =requirements.txt=, housing exact dependency
version numbers for project collaborators to install.  All of these
are automatically kept in sync, so you never have the case like with
=conda= where someone does a =conda= or =pip= install into their
environment but never bothers to update the =setup.py=,
=environment.yml=, =requirements.txt= or whatever.

Starting out, we can use an asynchronous shell command to set up a
poetry environment for the project by using =M-&=, while =errors.py=
is still the active buffer:

#+begin_example
Async shell command: poetry init -n --python=^3.10
#+end_example

In the case we get an error about Emacs not finding =poetry=, but it's
definitely in a well-known place like =~/.local/bin= after running
it's install script, we may have to edit a PATH variable or two.  I
take care of this on *nix machines in my =init.el= with a short block
like this:

#+begin_src elisp
;; Add ~/.local/bin to Eshell PATH when on *nix
(defun renz/eshell-local-bin ()
  "Ensure ~/.local/bin is on PATH when starting eshell"
  (unless (eq system-type 'windows-nt)
    (eshell/addpath "~/.local/bin")))

;; eshell/addpath is buffer-local, so we have to run this as a hook
(add-hook 'eshell-mode-hook 'renz/eshell-local-bin)
#+end_src

Assuming the poetry command ran without error, it plopped down the
=pyproject.toml= in the same directory as =errors.py=.  In a similar vein,
let's add a couple dependencies:

#+begin_example
Async shell command: poetry add pyright requests
#+end_example

The =*Async Shell Command*= buffer will update as poetry runs and
installs the required dependencies.  Following this, we should have
the =pyright= CLI installed to the virtual environment poetry set up
for us.  As a sanity check, I'll start up either =M-x shell= or =M-x
eshell= (whichever happens to be behaving better that day) to just get
a simple cross-platform shell running where I can try it out:

#+begin_example
~/tmp $ poetry run pyright errors.py
Creating virtualenv 006-emacs-2-python-QKcV4YYo-py3.10 in /home/robb/.cache/pypoetry/virtualenvs
No configuration file found.
pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python.
Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml
Pyproject file "/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml" is missing "[tool.pyright]" section.
stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory.
Assuming Python platform Linux
Searching for source files
Found 1 source file
/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import "aaaaaaa" could not be resolved (reportMissingImports)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: "fdafdsafdsafdsafdsafdsafdsa" is not a known member of module (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" when expected type is "str" (reportGeneralTypeIssues)
  /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import "requests" could not be resolved from source (reportMissingModuleSource)
4 errors, 2 warnings, 0 informations
Completed in 1.033sec
#+end_example

Emacs actually has a couple ways of running error-checking tools like
this.  The typical one is =M-x compile=, which we saw earlier, but
there's also =C-c C-v= for =M-x python-check=.

** =M-x python-check= to run =poetry run pyright=
*** =mypy= error parsing appears to be supported out of the box
*** =conda= or vanilla version would be something like =.venv/bin/pyright=


* Add error parsing to the pyright compile output
If we save the contents of this python example to a file named
=errors.py=, and then run =pyright errors.py= from any shell, we'll
get this as an output:

#+begin_example
/home/robb/tmp/errors.py/
  /home/robb/tmp/errors.py:1:1 - error: "foo" is not defined (reportUndefinedVariable)
  /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression)
  /home/robb/tmp/errors.py:4:12 - error: Operator "+" not supported for types "str" and "Literal[1]"
    Operator "+" not supported for types "str" and "Literal[1]" (reportGeneralTypeIssues)
2 errors, 1 warning, 0 informations
#+end_example

** The regexp alist and alist-alist ... yeah
** Building the regex with re-builder from the compiler output screen
*** GIF of building regex
** Adding the regex to init.el
** Using the =M-g M-p= and =M-g M-n= to navigate errors
*** GIF of navigating errors


* Also can use =M-x compile= for =poetry= commands
** How to fix the ansi color issue
*** GIF of running colors


* Org mode, babel, tangling, and untangling
** Demo using this document?


* =pyvenv= package is /absolutely/ necessary once we want seamless shell/lsp integration

[fn:pyright] https://github.com/microsoft/pyright#command-line
[fn:poetry] https://python-poetry.org/docs/#installation
