[{"content":"Recently, /u/casouri posted a guide to getting started with the new built-in tree-sitter capabilities for Emacs 29. In that post, they mention that there will be no automatic major-mode fallback for Emacs 29. That means I would have to use M-x python-ts-mode manually, or change the entry in auto-mode-alist to use python-ts-mode, in order to take advantage of the new tree-sitter functionality. Of course, that would still leave the problem of when the Python tree-sitter grammar isn\u0026rsquo;t installed, in which case python-ts-mode is going to fail.\nTo solve this issue, I wrote a very small package that adjusts the new major-mode-remap-alist variable based on what grammars are ready on your machine. If a language\u0026rsquo;s tree-sitter grammar is installed, it will use that mode. If not, it will use the original major mode. Simple as that!\nFor the impatient: treesit-auto.el # The package I wound up with is available on GitHub and MELPA as treesit-auto.el. So long as MELPA is on your package-archives list like this:\n(add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) Then you can use M-x package-refresh-contents followed by M-x package-install RET treesit-auto.\nIf you also like having a local copy of the git repository itself, then package-vc-install is a better fit:\nM-x package-vc-install RET https://github.com/renzmann/treesit-auto.el Then, in your configuration file:\n(use-package treesit-auto :demand t :config (global-treesit-auto-mode)) See the README on GitHub for all the goodies you can put in the :config block.\nOrigins of treesit-auto.el # The recommendation in Yuan\u0026rsquo;s article was to use define-derived-mode along with treesit-ready-p. In the NEWS (C-h n), however, I noticed a new variable major-mode-remap-alist, which at a glance appears suitable for a similar cause. For my Emacs configuration, I had two things I wanted to accomplish:\nSet all of the URLs for treesit-language-source-alist up front, so that I need only use treesit-install-language-grammar RET python RET, instead of writing out everything interactively Use the same list of available grammars to remap between tree-sitter modes and their default fallbacks Initially, I tried Yuan\u0026rsquo;s suggested approach with define-derived-mode, but I didn\u0026rsquo;t want to repeat code for every major mode I wanted fallback for. Trying to expand the major mode names correctly in a loop wound up unwieldy, because expanding the names properly for the define-derived-mode macro was too challenging for my current skill level with Emacs lisp, and wound up cluttering the global namespace more than I liked when auto-completing through M-x. Instead, I decided take a two step approach:\nSet up treesit-language-source-alist with the grammars I\u0026rsquo;ll probably use Loop over the keys in this alist to define the association between a tree-sitter mode and its default fallback through major-mode-remap-alist This makes the code we need to actually write a little simpler, since an association like python-mode to python-ts-mode can be automatic (since they share a name), and we can use a customizable alist for specifying the edge cases, such as toml-ts-mode falling back to conf-toml-mode.\nTo start with, I just had this:\n(setq treesit-language-source-alist \u0026#39;((bash \u0026#34;https://github.com/tree-sitter/tree-sitter-bash\u0026#34;) (c \u0026#34;https://github.com/tree-sitter/tree-sitter-c\u0026#34;) (cmake \u0026#34;https://github.com/uyha/tree-sitter-cmake\u0026#34;) (common-lisp \u0026#34;https://github.com/theHamsta/tree-sitter-commonlisp\u0026#34;) (cpp \u0026#34;https://github.com/tree-sitter/tree-sitter-cpp\u0026#34;) (css \u0026#34;https://github.com/tree-sitter/tree-sitter-css\u0026#34;) (csharp \u0026#34;https://github.com/tree-sitter/tree-sitter-c-sharp\u0026#34;) (elisp \u0026#34;https://github.com/Wilfred/tree-sitter-elisp\u0026#34;) (go \u0026#34;https://github.com/tree-sitter/tree-sitter-go\u0026#34;) (go-mod \u0026#34;https://github.com/camdencheek/tree-sitter-go-mod\u0026#34;) (html \u0026#34;https://github.com/tree-sitter/tree-sitter-html\u0026#34;) (js . (\u0026#34;https://github.com/tree-sitter/tree-sitter-javascript\u0026#34; \u0026#34;master\u0026#34; \u0026#34;src\u0026#34;)) (json \u0026#34;https://github.com/tree-sitter/tree-sitter-json\u0026#34;) (lua \u0026#34;https://github.com/Azganoth/tree-sitter-lua\u0026#34;) (make \u0026#34;https://github.com/alemuller/tree-sitter-make\u0026#34;) (markdown \u0026#34;https://github.com/ikatyang/tree-sitter-markdown\u0026#34;) (python \u0026#34;https://github.com/tree-sitter/tree-sitter-python\u0026#34;) (r \u0026#34;https://github.com/r-lib/tree-sitter-r\u0026#34;) (rust \u0026#34;https://github.com/tree-sitter/tree-sitter-rust\u0026#34;) (toml \u0026#34;https://github.com/tree-sitter/tree-sitter-toml\u0026#34;) (tsx . (\u0026#34;https://github.com/tree-sitter/tree-sitter-typescript\u0026#34; \u0026#34;master\u0026#34; \u0026#34;tsx/src\u0026#34;)) (typescript . (\u0026#34;https://github.com/tree-sitter/tree-sitter-typescript\u0026#34; \u0026#34;master\u0026#34; \u0026#34;typescript/src\u0026#34;)) (yaml \u0026#34;https://github.com/ikatyang/tree-sitter-yaml\u0026#34;))) At this point, I can just use M-x treesit-install-language-grammar RET bash to get the Bash grammar, and similarly for other languages.\nThen, I made an alist of the \u0026ldquo;weird\u0026rdquo; cases:\n(setq treesit-auto-fallback-alist \u0026#39;((toml-ts-mode . conf-toml-mode) ;; I don\u0026#39;t actually know if the future tree-sitter mode for HTML will be ;; called html-ts-mode or mhtml-ts-mode, but if it\u0026#39;s the former I\u0026#39;d include this (html-ts-mode . mhtml-mode) ;; See the note in their README: https://github.com/emacs-typescript/typescript.el#a-short-note-on-development-halt (typescript-ts-mode . nil) (tsx-ts-mode . nil))) Setting the CDR to nil explicitly means I didn\u0026rsquo;t want any type of fallback to be attempted whatsoever for a given tree-sitter mode, even if something similarly named might be installed.\nFinally, I had a simple loop where I constructed the symbols for the mode and the tree-sitter mode via intern and concat, and check whether the tree-sitter version is available through treesit-ready-p. If it is, we remap the base mode to the tree-sitter one in major-mode-remap-alist. If it isn\u0026rsquo;t ready, then we do the opposite: remap the tree-sitter mode to the base version.\n(dolist (language-source treesit-language-source-alist) (let* ((name (car language-source)) (name-ts-mode (intern (concat (symbol-name name) \u0026#34;-ts-mode\u0026#34;))) (fallback-assoc (assq name-ts-mode treesit-auto-fallback-alist)) (fallback-name (cdr fallback-assoc)) (name-mode (or fallback-name (intern (concat (symbol-name name) \u0026#34;-mode\u0026#34;)))) (name-mode-bound-p (fboundp name-mode)) (skip-remap-p (and fallback-assoc (not (cdr fallback-assoc))))) (and (not skip-remap-p) (fboundp name-ts-mode) (if (treesit-ready-p name t) (add-to-list \u0026#39;major-mode-remap-alist `(,name-mode . ,name-ts-mode)) (when name-mode-bound-p (add-to-list \u0026#39;major-mode-remap-alist `(,name-ts-mode . ,name-mode))))))) Of course, the actual code has a bit more wrapped around it, but the core idea is more or less the same.\n","date":"22 January 2023","permalink":"/posts/emacs-treesit-auto/","section":"Posts","summary":"Recently, /u/casouri posted a guide to getting started with the new built-in tree-sitter capabilities for Emacs 29.","title":"Getting Emacs 29 to Automatically Use Tree-sitter Modes"},{"content":"I\u0026rsquo;ve got a (relatively) stable version of my Emacs configuration as a literate document now. It\u0026rsquo;s easy to read either on my GitHub or my website. The website version may lag behind my GitHub verison a bit, but they should be pretty close. Many thanks to the maintainers of ox-hugo for making it possible.\n","date":"21 November 2022","permalink":"/posts/emacs-literate-announcement/","section":"Posts","summary":"I\u0026rsquo;ve got a (relatively) stable version of my Emacs configuration as a literate document now.","title":"Moving My Emacs Configuration to a Literate Programming Document"},{"content":"Motivation # My most reliable setup for developing Python projects on remote hosts with LSP support so far has been with eglot and pyright. I\u0026rsquo;ve also tried lsp-mode with pyright, and both of lsp-mode and eglot with the python-lsp-server, however I\u0026rsquo;ve landed on eglot + pyright for a few reasons:\neglot requires zero configuration to work over Tramp, unlike lsp-mode. Fewest number of Tramp hangs. This could just be a symptom of my particular setup, though. eglot will have built-in support in future Emacs versions. This may or may not be worth a damn to other Emacs users. pyright has been strictly faster at error checking and diagnostic updates as compared to python-language-server in the machines I\u0026rsquo;m using. One hiccup remained though: pyright is typically a system or user installation, not something you install per virtual environment. Getting pyright to see the virtual environment of my choosing , and correctly report which dependencies are installed was a bit of a hassle, but I think my favorite solution so far has been to configure the virtual environment through the pyrightconfig.json file at the root of my project, and just have this file ignored by git. Typically, pyrightconfig.json looks like this:\n{ \u0026#34;venvPath\u0026#34;: \u0026#34;/absolute/path/to/dir/\u0026#34;, \u0026#34;venv\u0026#34;: \u0026#34;.venv\u0026#34; } I\u0026rsquo;m pretty happy with the other default configurations for pyright, so I leave those be, and just configure the virtual environment path this way. What was annoying me, though, is that I\u0026rsquo;d need to write out this absolute path for each machine I clone a project into, since relative paths and shortcuts using ~ aren\u0026rsquo;t supported. Much better if we can just have Emacs do it for us.\nIn the spirit of other Emacs/Python tools like pythonic and pyvenv for activating virtual environments, I wanted something that would just prompt for a directory using completing-read, and then populate the contents of pyrightconfig.json automatically based on my selection.\nGetting Functions That Write pyrightconfig.json # Edit 2022-11-20: Thanks to Mickey Petersen of mastering emacs for pointing out that json-encode exists. I originally had my own function pyrightconfig--json-contents here, but I\u0026rsquo;ve modified the function below to use this built-in version instead.\nWe really just need to do three things:\nPrompt for a directory that houses a Python virtual environment Break the result into an absolute parent path + base name, cleaning any Tramp prefix in the process Write the contents of pyrightconfig--json-contents using the previous result to a file in the version control root. It\u0026rsquo;s worth mentioning that we must put this file in the VC root, otherwise eglot just won\u0026rsquo;t pick it up. For my purposes, the VC system will always be git, so I\u0026rsquo;m going to make an assumption here and use vc-git-root instead of something more generic.\n(defun pyrightconfig-write (virtualenv) (interactive \u0026#34;DEnv: \u0026#34;) (let* (;; file-truename and tramp-file-local-name ensure that neither `~\u0026#39; nor ;; the Tramp prefix (e.g. \u0026#34;/ssh:my-host:\u0026#34;) wind up in the final ;; absolute directory path. (venv-dir (tramp-file-local-name (file-truename virtualenv))) ;; Given something like /path/to/.venv/, this strips off the trailing `/\u0026#39;. (venv-file-name (directory-file-name venv-dir)) ;; Naming convention for venvPath matches the field for ;; pyrightconfig.json. `file-name-directory\u0026#39; gets us the parent path ;; (one above .venv). (venvPath (file-name-directory venv-file-name)) ;; Grabs just the `.venv\u0026#39; off the end of the venv-file-name. (venv (file-name-base venv-file-name)) ;; Eglot demands that `pyrightconfig.json\u0026#39; is in the project root ;; folder. (base-dir (vc-git-root default-directory)) (out-file (expand-file-name \u0026#34;pyrightconfig.json\u0026#34; base-dir)) ;; Finally, get a string with the JSON payload. (out-contents (json-encode (list :venvPath venvPath :venv venv)))) ;; Emacs uses buffers for everything. This creates a temp buffer, inserts ;; the JSON payload, then flushes that content to final `pyrightconfig.json\u0026#39; ;; location (with-temp-file out-file (insert out-contents)))) Here\u0026rsquo;s a quick demo where I interactively choose a virtual environment directory, write the pyrightconfig.json, launch eglot, and use M-. to leverage the LSP\u0026rsquo;s jump-to-definition of a library, then show that the library we jumped to is indeed inside the virtual environment.\nFollow-ups # Feel free to take this package and modify it to suit your needs. Over time I might make some modifications to it:\nMaybe integrate with the variety of activate functions? So activating or setting a venv root for use with run-python automatically sets this. Support other VC roots than just git I\u0026rsquo;d love to get to VSCode-like intelligence about common venv locations and just prompt for those automatically through completing-read, instead of going through the pathing processing myself. Maybe that would become a function like pyrightconfig-suggest. ","date":"19 November 2022","permalink":"/posts/emacs-eglot-pyrightconfig/","section":"Posts","summary":"Motivation # My most reliable setup for developing Python projects on remote hosts with LSP support so far has been with eglot and pyright.","title":"Virtual Environments with Eglot, Tramp, and Pyright"},{"content":"There\u0026rsquo;s been a lot of talk about how eglot and tree-sitter will be distributed with Emacs 29, but I\u0026rsquo;ve seen less buzz around the new functionality coming to the vanilla ∗Completions∗ buffer. Now, I\u0026rsquo;ve been an ardent vertico + orderless + marginalia + corfu user since seriously picking up Emacs over the summer, and when initially looking for options I found Prot\u0026rsquo;s MCT pretty alluring. I didn\u0026rsquo;t choose it since he had already decided to discontine development given upcoming changes in Emacs 29, and as of writing even he opted for vertico and corfu.\nThere is still that tempting, bitter fruit on the horizon though - maximizing everything I can out of the vanilla Emacs experience. Getting to that mythical \u0026ldquo;vanilla extract\u0026rdquo; that keeps my muscle memory nearly entirely intact between emacs -Q and my config (check out \u0026ldquo;Goals\u0026rdquo; in my .emacs.d to see the reasoning behind why I would want this).\nNow that treesit.el, use-package, and eglot are all merged into the emacs-29 branch, I finally decided to give our good old friend the ∗Completions∗ buffer another try, so that you don\u0026rsquo;t have to.\n(Some verbiage below is taken directly from C-h n (view-emacs-news))\nNew \u0026lsquo;visible\u0026rsquo; and \u0026lsquo;always\u0026rsquo; values for \u0026lsquo;completion-auto-help\u0026rsquo; # There are two new values to control the way the \u0026ldquo;∗Completions∗\u0026rdquo; buffer behaves after pressing a \u0026lsquo;TAB\u0026rsquo; if completion is not unique.\nThe (old) default value t always hides the completion buffer after some completion is made.\n(setq completion-auto-help t) The value \u0026lsquo;always\u0026rsquo; updates or shows the ∗Completions∗ buffer after any attempt to complete, including the first time we press TAB. Comparing to the one above, notice that the buffer pops up as soon as I complete ~/.emacs.d/. Before, I had to start another completion by typing tra\u0026lt;TAB\u0026gt;. Also, after completing transient/, the buffer once again updates with the contents of that directory.\n(setq completion-auto-help \u0026#39;always) The value \u0026lsquo;visible\u0026rsquo; is like \u0026lsquo;always\u0026rsquo;, but only updates the completions if they are already visible. The main difference in this one is that we don\u0026rsquo;t get the ∗Completions∗ buffer on the first TAB for ~/.emacs.d/:\n(setq completion-auto-help \u0026#39;visible) If your goal is reduction of visual noise because you already know how a chain of TAB\u0026rsquo;s are going to complete, then \u0026lsquo;visible\u0026rsquo; seems like a good option.\nThe ∗Completions∗ buffer can now be automatically selected. # This was my biggest gripe with ∗Completions∗ and what made it downright unusable for completion-at-point. Here\u0026rsquo;s what the current behavior looks like with completion in a buffer:\n(setq completion-auto-select nil) In the minibuffer, we\u0026rsquo;ve always had M-v to switch to ∗Completions∗, but there was no analogue for completion-in-region. Now, in Emacs 29, we can set completion-auto-select to one of t or second-tab to enable automatic selection of the \u0026ldquo;∗Completions∗\u0026rdquo; buffer\n(setq completion-auto-select t) If the value is \u0026lsquo;second-tab\u0026rsquo;, then the first TAB will display \u0026ldquo;∗Completions∗\u0026rdquo;, and the second one will switch to the \u0026ldquo;∗Completions∗\u0026rdquo; buffer.\n(setq completion-auto-select \u0026#39;second-tab) With \u0026lsquo;second-tab\u0026rsquo;, I can use the \u0026ldquo;∗Completions∗\u0026rdquo; buffer a lot like how I would use corfu: type a bit, request completion with TAB, examine the list, and keep typing to narrow the candidates, and request completion again. If I see the option I like, I just hit TAB a few times to get it.\nNew commands for navigating completions from the minibuffer. # M-\u0026lt;up\u0026gt; and M-\u0026lt;down\u0026gt; for minibuffer-next-completion and minibuffer-previous-completion M-RET to choose active candidate C-u M-RET to insert active candidate without exiting minibuffer C-x \u0026lt;up\u0026gt; (minibuffer-complete-history) is like minibuffer-complete but completes on the history items instead of the default completion table. C-x \u0026lt;down\u0026gt; (minibuffer-complete-defaults) is like minibuffer-complete, but completes on the default items instead of the completion table. The first two also work for completion-at-point (in-buffer completion).\nSome may find the arrow keys an unfortunate choice, though, and bind something more convenient:\n;; Up/down when completing in the minibuffer (define-key minibuffer-local-map (kbd \u0026#34;C-p\u0026#34;) #\u0026#39;minibuffer-previous-completion) (define-key minibuffer-local-map (kbd \u0026#34;C-n\u0026#34;) #\u0026#39;minibuffer-next-completion) ;; Up/down when competing in a normal buffer (define-key completion-in-region-mode-map (kbd \u0026#34;C-p\u0026#34;) #\u0026#39;minibuffer-previous-completion) (define-key completion-in-region-mode-map (kbd \u0026#34;C-n\u0026#34;) #\u0026#39;minibuffer-next-completion) My apologies to Mohamed Suliman, since I was also not able to figure out a fix for eshell that permits the use of M-\u0026lt;up\u0026gt; and M-\u0026lt;down\u0026gt; with M-RET. The issue there, it seems, is that eshell uses its own pcomplete instead of completion-at-point, which comes from minibuffer.el. I have, however, had success simply using TAB and BACKTAB with RET, by setting completion-auto-select to 'second-tab, as shown above.\nNew user option \u0026lsquo;completions-sort\u0026rsquo;. # Much like how oantolin\u0026rsquo;s live-completions gave us a way to sort candidates in ∗Completions∗, we now have a built-in method for specifying the sorting function. I took inspiration from Prot\u0026rsquo;s MCT documentation here to put candidates I use frequently near the top, followed by the length of their name.\n(defun renz/sort-by-alpha-length (elems) \u0026#34;Sort ELEMS first alphabetically, then by length.\u0026#34; (sort elems (lambda (c1 c2) (or (string-version-lessp c1 c2) (\u0026lt; (length c1) (length c2)))))) (defun renz/sort-by-history (elems) \u0026#34;Sort ELEMS by minibuffer history. Use `mct-sort-sort-by-alpha-length\u0026#39; if no history is available.\u0026#34; (if-let ((hist (and (not (eq minibuffer-history-variable t)) (symbol-value minibuffer-history-variable)))) (minibuffer--sort-by-position hist elems) (renz/sort-by-alpha-length elems))) (defun renz/completion-category () \u0026#34;Return completion category.\u0026#34; (when-let ((window (active-minibuffer-window))) (with-current-buffer (window-buffer window) (completion-metadata-get (completion-metadata (buffer-substring-no-properties (minibuffer-prompt-end) (max (minibuffer-prompt-end) (point))) minibuffer-completion-table minibuffer-completion-predicate) \u0026#39;category)))) (defun renz/sort-multi-category (elems) \u0026#34;Sort ELEMS per completion category.\u0026#34; (pcase (renz/completion-category) (\u0026#39;nil elems) ; no sorting (\u0026#39;kill-ring elems) (\u0026#39;project-file (renz/sort-by-alpha-length elems)) (_ (renz/sort-by-history elems)))) (setq completions-sort #\u0026#39;renz/sort-multi-category) Other Niceties # completions-max-height limits the height of the \u0026ldquo;∗Completions∗\u0026rdquo; buffer completions-header-format is a string to control the heading line to show in the \u0026ldquo;∗Completions∗\u0026rdquo; buffer before the list of completions Do We Stick With Vanilla Extract? # Now the fun part - let\u0026rsquo;s tally pros and cons to see if I should abandon everything for the Vanilla behavior:\nproperty score Consistent minibuffer + CAP +1 Vanilla GUI + TTY support +1 No marginalia for sole completion -0.5 Extra key press to cycle/complete -0.5 Candidates not buffered until requested -2 Eyes shift focus to another part of screen for CAP -0.5 Total -1.5 In my typical day, I need to have a working TTY and GUI version of Emacs, so when something just works for both, that\u0026rsquo;s a +1 for me. Corfu does have corfu-terminal, but it\u0026rsquo;s maintained separately. Also, having a consistent interface for both the minibuffer and completion-at-point shrinks the configuration domain, making it easier to maintain my config over time.\nUnfortunately, in the case that there\u0026rsquo;s only one completion candidate, marginalia isn\u0026rsquo;t triggered, so I don\u0026rsquo;t get to see a key binding or flavor text alongside the candidate I choose. Vanilla Emacs will remind me about what key combination I could have used, which I can check any time with C-h e (the ∗Messages∗ buffer), and I can use C-h f directly from the minibuffer, so this only get -0.5. The fact that I need extra key strikes compared to something like Corfu\u0026rsquo;s Tab-N-Go is an annoyance, but just requires a bit of muscle memory change. The real impasse here, though, is that candidates aren\u0026rsquo;t shown until requested. I think Prot summed it up best here:\nVertico has official extensions which can make it work exactly like MCT without any of MCT’s drawbacks. These extensions can also expand Vertico’s powers such as by providing granular control over the exact style of presentation for any given completion category (e.g. display Imenu in a separate buffer, show the switch-to-buffer list horizontally in the minibuffer, and present find-file in a vertical list—whatever the user wants).\nSo will I stick with just ∗Completions∗? No, probably not. But these changes do put the default completion system squarely in the \u0026ldquo;usable\u0026rdquo; category, which I\u0026rsquo;m not sure I could have said before Emacs 29. I will give it an honest chance to see just how far I can push it, much in the spirit of MCT, before switching Vertico and Corfu back on.\n","date":"6 January 2023","permalink":"/posts/emacs-29-completions/","section":"Posts","summary":"There\u0026rsquo;s been a lot of talk about how eglot and tree-sitter will be distributed with Emacs 29, but I\u0026rsquo;ve seen less buzz around the new functionality coming to the vanilla ∗Completions∗ buffer.","title":"The *Completions* Buffer Gets a Big Upgrade in Emacs 29"},{"content":" Intro There are a lot of great guides on getting set up with Python in Emacs. Many of them have titles like \u0026#34;Emacs as a Python IDE\u0026#34; and start off by installing pyvenv for virtual environment management, eglot or lsp-mode for autocomplete/error checking, and maybe a host of other non-python things, like the helm or projectile packages.\nThis is not that guide.\nThis guide is for picky @#$%!s like me who want to exhaust every builtin capability before reaching out to external dependencies. Dependencies that, in turn, I will also have to learn and manage. Once I really understand what pyvenv is solving, then, and only then, will I add it to my package-selected-packages.\nDespite the excellent swath of materials both new and old on how to get IDE-like performance for Python out of Emacs, the collected materials on just running \u0026#34;vanilla extract\u0026#34; are fairly scant. The builtin python.el documentation is thorough and the keybindings easily discoverable, but not all documentation is collated into a single place. This guide started out as just my working notes as I began primarily working in emacs for my Python projects, and has grown into a workflow guide using nothing but the builtin capabilities of Emacs 28.1+. With that in mind, the examples and walkthroughs presented here are designed for emacs -q - i.e. starting emacs without any user configuration or your distribution\u0026#39;s default.el.\nEditing Let\u0026#39;s get our feet wet by bopping around some Python buffers first. I\u0026#39;m going to start up a new python file with C-x C-f and naming my file editing.py. I\u0026#39;m going to start by just adding a couple functions and a print statement, obfuscating the typical \u0026#34;Hello, world!\u0026#34; example a bit by introducing some functions and a \u0026#34;main\u0026#34; section right away.\n# These funtions are a little basic and silly right now, but we\u0026#39;ll use # them to showcase some Emacs features later on. def hello_text(): \u0026#34;\u0026#34;\u0026#34;Just gives back \u0026#39;Hello\u0026#39;\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Hello\u0026#34; def world_text(): \u0026#34;\u0026#34;\u0026#34;Just gives back \u0026#39;world!\u0026#39;\u0026#34;\u0026#34;\u0026#34; return \u0026#34;world!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: # Emacs 28.1+ has f-string syntax highlighting built in print(f\u0026#34;{hello_text()}, {world_text()}!\u0026#34;) By visiting this file, Emacs automatically goes into python-mode, which turns on a lot of Python-specific functionality. If you\u0026#39;re impatient like me and want to see everything that\u0026#39;s available right away, I\u0026#39;d start with C-c C-h from the editing.py buffer to see key commands specific to python-mode, and also use C-h a python to see every command involving the word \u0026#34;python\u0026#34; in some way. Out of the box we also get syntax highlighting, including within f-strings.\nUseful C-c commands Emacs typically has commands that are specific to the active major mode bound to C-c C-\u0026lt;letter\u0026gt;. What each \u0026lt;letter\u0026gt; does will depend on the buffer you\u0026#39;re currently in and what major mode is active. In our case, that\u0026#39;s python-mode, which has a lot of handy shortcuts already mapped out. For any of the keyboard shortcuts you can always use C-h k, or C-h f for the function names (prefixed by M-x below) to get the official documentation.\nC-c C-p or M-x run-python to start a python REPL This boots up what Emacs calls an \u0026#34;inferior Python shell\u0026#34;. \u0026#34;Inferior\u0026#34; here just means that Python is running as a subprocess of Emacs; not that there\u0026#39;s some other, \u0026#34;superior\u0026#34; method of running a Python process. If you need to control the exact command Emacs runs to start the shell, you can use the universal C-u prefix before either C-c C-p or M-x run-python to edit the command Emacs runs. Based on the previous article, what I\u0026#39;m frequently doing is holding down the Ctrl key with my left little finger, then rapidly typing u, c, and p to get C-u C-c C-p, bringing up a minibuffer prompt like this:\nRun Python: python3 -i█ Where █ is point (my cursor). I then use C-a to move point back to the start and add a poetry run:\nRun Python: poetry run█python3 -i Emacs is typically smart enough to figure out what to do even if we leave off the -i, but generally it\u0026#39;s good to leave it in there.\nC-c C-z jumps to python REPL if already running Once the REPL is running, this is a very handy one for swapping back and forth between a file I\u0026#39;m actively editing and a running Python process\nC-c C-{c,e,r} for sending chunks to the REPL A handy complement to C-c C-z, these commands are for taking pieces of Python that I\u0026#39;m actively editing and sending them to the Python buffer all at once.\nC-c C-v or M-x python-check More on this later…\nC-c C-t ... or python-skeleton-... Using C-c C-t d and C-c C-t c it\u0026#39;s easy to insert new def and class statements (think t for \u0026#34;template\u0026#34;, d for \u0026#34;def\u0026#34;, and c for \u0026#34;class\u0026#34;). Ater invoking one of these, Emacs will guide us through the process of filling out each part needed to define a new function or class via the minibuffer. Using C-g at any point while editing the template wil revert the buffer back to its original state, as if you never started filling out the skeleton.\n# editing.py # --snip-- # Here we use `C-c C-t d` and follow the prompts to design a new # function signature. def whatever(my_string: str = hello_text, my_integer: int = 0): \u0026#34;\u0026#34;\u0026#34;Whatever, man\u0026#34;\u0026#34;\u0026#34; return f\u0026#34;{hello_text}, {my_integer}\u0026#34; # Next, `C-c C-t c` to make a new class class MyGuy: \u0026#34;\u0026#34;\u0026#34;My guy is ALWAYS there for me\u0026#34;\u0026#34;\u0026#34; pass # --snip-- \u0026#34;__main__\u0026#34; C-c C-j or M-x imenu The nimble, builtin imenu is a way to quickly navigate between major symbol definitions in the current buffer - especially those off screen. In our editing.py we now have three functions, hello_text(), world_text(), and whatever(), and one class MyGuy. If we use C-c C-j, a minibuffer menu like this comes up:\n1/5 Index item: █ *Rescan* MyGuy.(class) whatever.(def) world_text.(def) hello_text.(def) My minibuffer displays a vertical preview of the options because I\u0026#39;ve set (fido-mode) and (vertical-fido-mode) in my init.el, both of which are included in Emcacs 28.1 or later. Then, if I partially type out a result the list will filter down to possible completions:\n1/1 Index item: My█ MyGuy.(class) imenu is very, very handy across Emacs, not just for Python, so it\u0026#39;s worth trying in a variety of major modes.\nRunning Now its time to actually start executing some code. Before getting to all the complexity of virtual environments, we\u0026#39;ll start simply by just invoking the system Python for our script. Once that feels comfortable, we\u0026#39;ll throw in all the venv goodies.\nAs a script with M-x compile This mode has built-in error parsing, so it\u0026#39;s the best way to run a script for real if we want to quickly navigate any traceback messages that come up. Conversely, the M-\u0026amp; async shell command does not have error parsing, so it\u0026#39;s not the right tool for launching processes we have to debug. Same goes for booting up a shell and running Python from there. Taking our script from the previous section, if we run M-x compile and give it an argument of python3 editing.py, up pops the *compilation* buffer, with the starting time, output of our program, and finish time.\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 13:50:39 python3 editing.py Hello, world! Compilation finished at Sun Aug 14 13:50:39 Now, let\u0026#39;s try a different script, with an error in it:\n# hello_error.py print(\u0026#34;Not an error yet!\u0026#34;) fdafdsafdsafdsa print(\u0026#34;Shouldn\u0026#39;t make it here...\u0026#34;) Now, M-x compile will error out:\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 13:53:26 python3 hello_error.py Not an error yet! Traceback (most recent call last): File \u0026#34;/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/hello_error.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; fdafdsafdsafdsa NameError: name \u0026#39;fdafdsafdsafdsa\u0026#39; is not defined Compilation exited abnormally with code 1 at Sun Aug 14 13:53:26 Emacs will parse the error message, so that after \u0026#34;compiling\u0026#34;, we can use M-g M-n and M-g M-p to move between error messages, or just click the link provided by the *compilation* buffer directly.\nIf just parsing Python tracebacks doesn\u0026#39;t excite you, mypy is also supported out of the box. Assuming mypy is already installed, M-x compile with mypy hello_error.py as the command results in this:\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 14:02:03 .venv/bin/mypy hello_error.py hello_error.py:4: error: Name \u0026#34;fdafdsafdsafdsa\u0026#34; is not defined Found 1 error in 1 file (checked 1 source file) Compilation exited abnormally with code 1 at Sun Aug 14 14:02:04 The hello_error.py:4: error: ... message will be a functional link, just as before. mypy is much more suitable for general error-checking though, so as scripts (and bugs) grow, the M-x compile command can keep up:\n# errors.py import typing import requests import aaaaaaa foo print(typing.fdafdsafdsafdsafdsafdsafdsa) def whatever(x: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Here\u0026#39;s a docstring!\u0026#34;\u0026#34;\u0026#34; return x + 1 M-x compile RET mypy errors.py -*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 14:06:55 .venv/bin/mypy errors.py errors.py:6: error: Cannot find implementation or library stub for module named \u0026#34;aaaaaaa\u0026#34; errors.py:6: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports errors.py:8: error: Name \u0026#34;foo\u0026#34; is not defined errors.py:9: error: Module has no attribute \u0026#34;fdafdsafdsafdsafdsafdsafdsa\u0026#34; errors.py:14: error: Unsupported operand types for + (\u0026#34;str\u0026#34; and \u0026#34;int\u0026#34;) Found 4 errors in 1 file (checked 1 source file) Compilation exited abnormally with code 1 at Sun Aug 14 14:06:55 Now, we can use M-g M-n and M-g M-p to quickly navigate between the errors in our code, even after navigating away from the original errors.py buffer - Emacs will remember what\u0026#39;s going on in the *compilation* buffer so we can hop all around the code base while addressing errors one at a time.\nInteractively with the Python shell python-mode centers heavily around the use of an active, running Python session for some of its features, as we\u0026#39;ll see in the next section. Its documentation recommends regular use of C-c C-c, which sends the entire buffer to the active inferior Python process. That means actually executing Python code, which may feel a bit dangerous for those of us who grew up with static analysis tools. So the first thing we need to make sure we don\u0026#39;t accidentally kick off our whole script is ensure that the main part of our program is properly ensconced.\n# editing.py # --snip-- if __name__ == \u0026#34;__main__\u0026#34;: print(f\u0026#34;{hello_text()}, {world_text()}!\u0026#34;) Code Completion Emacs uses the currently running *Python* process for looking up symbols to complete. As such, python.el recommends using C-c C-c to send the entire buffer\u0026#39;s contents to the Python shell periodically. if __name__ == \u0026#34;__main__\u0026#34; blocks do not execute when using C-c C-c. To send all code in the current buffer, including the __main__ block, instead we must use C-u C-c C-c.\nAnother awkward default in Emacs is that what we typically know of as \u0026#34;tab-complete\u0026#34; is bound to M-TAB, or the equivalent C-M-i (C-i and TAB are the same thing). On most Windows and Linux desktops, Alt+Tab changes the active window, and C-M-i is much too cumbersome to be a reasonable completion shortcut. I prefer just being able to hit TAB to invoke completion-at-point, so I use this snippet in my init.el:\n;; init.el ;; Use TAB in place of C-M-i for completion-at-point (setq tab-always-indent \u0026#39;complete) Now to demonstrate this new completion power. In our python file editing.py, I know we have a function called hello_text(). Within the main block, I might have been typing something that looked like this:\nif __name__ == \u0026#34;__main__\u0026#34;: print(f\u0026#34;{hell█ Where █ is point. Attempting a completion-at-point using C-M-i (or just TAB as I have re-bound it above) will yield … nothing. Maybe the indentation cycles, or it says \u0026#34;No match\u0026#34;, or just - no response. What we require is a running inferior Python process, which will look up completion symbols. After booting up Python with C-c C-p and sending all the current buffer contents with C-c C-c, hitting TAB completes the hell into hello_text:\nif __name__ == \u0026#34;__main__\u0026#34;: print(f\u0026#34;{hello_text█ In the case that the completion is ambiguous, a *completions* buffer will pop up, prompting for input on how to continue. Another nice thing about this completion method is that it respects your completion-styles setting. Personally, I keep mine globally set to include the flex style, which closely mimics fuzzy matching styles like you get in VSCode, JetBrains, or fzf:\n;; init.el (setq completion-styles \u0026#39;(flex basic partial-completion emacs22)) This allows me to type something like hltx, hit TAB and it completes to hello_text.\nDebugging If by running our Python code we encounter the breakpoint() builtin, Emacs will automatically break into pdb/ipdb (depending on your PYTHONBREAKPOINT environment variable), jump to the breakpoint in the code, and put an arrow at the next line to execute.\nRunning the Python debugger by using `C-c C-c` M-x pdb Simply populates the command to run with python -m pdb. Can be configured with the variable gud-pdb-command-name\nThe poetry + pyright stack The stack I use most frequently (for now) consists of:\npython3.10 as the Python runtime poetry for dependency and environment management1 pyright for error checking2 emacs for everything else Each component should, in theory, be easy to replace. That is, if I want conda as a package manager and flake8 or mypy for linting/type checking, it should be easy to do a drop-in replacement for them.\nFor those who haven\u0026#39;t heard the good news of poetry, it takes care of a lot of headaches that every pythonista regularly deals with. It manages your virtual environment (creation and update), pyproject.toml specification, and a poetry.lock file that serves as a replacement for requirements.txt, housing exact dependency version numbers for project collaborators to install. All of these are automatically kept in sync, so you never have the case like with conda where someone does a conda or pip install into their environment but never bothers to update the setup.py, environment.yml, requirements.txt or whatever.\nEarlier we mentioned that running our Python scripts via the M-\u0026amp; async shell command interface wasn\u0026#39;t a great use case for it. However, using it to set up a poetry environment is a fantastic example of when it is appropriate.\nAsync shell command: poetry init -n --python=^3.10 Assuming the poetry command ran without error, it plopped down the pyproject.toml in the same directory as errors.py. In a similar vein, we can add project dependencies using M-\u0026amp;\nAsync shell command: poetry add pyright requests The *Async Shell Command* buffer will update as poetry runs and installs the required dependencies. Following this, we should have the pyright CLI installed to the virtual environment poetry set up for us. As a sanity check, I\u0026#39;ll start up either M-x shell or M-x eshell (whichever happens to be behaving better that day) to just get a simple cross-platform shell running where I can try it out:\n~/tmp $ # using the same `errors.py` as in the earlier sectons ~/tmp $ poetry run pyright errors.py No configuration file found. pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python. Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml Pyproject file \u0026#34;/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml\u0026#34; is missing \u0026#34;[tool.pyright]\u0026#34; section. stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory. Assuming Python platform Linux Searching for source files Found 1 source file /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import \u0026#34;aaaaaaa\u0026#34; could not be resolved (reportMissingImports) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: \u0026#34;foo\u0026#34; is not defined (reportUndefinedVariable) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: \u0026#34;fdafdsafdsafdsafdsafdsafdsa\u0026#34; is not a known member of module (reportGeneralTypeIssues) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; when expected type is \u0026#34;str\u0026#34; (reportGeneralTypeIssues) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import \u0026#34;requests\u0026#34; could not be resolved from source (reportMissingModuleSource) 4 errors, 2 warnings, 0 informations Completed in 1.033sec Emacs actually has a couple ways of running error-checking tools like this. The typical one is M-x compile, which we saw earlier, but there\u0026#39;s also C-c C-v for M-x python-check. The latter will automatically check for tools like pyflakes or flake8, but can be configured with the python-check-command variable to pre-populate the command to run. Like M-x compile, M-x python-check will use a buffer that looks identical to *compilation* in every way except name: it will be called the *Python check: \u0026lt;command you ran\u0026gt;* buffer.\nFor me, that means I typically have something like\n(setq python-check-command \u0026#34;poetry run pyright\u0026#34;) and then C-c C-v from a python buffer will prompt like this while errors.py is my active buffer\nCheck command: poetry run pyright errors.py Adding error parsing to the pyright compile output Unlike the mypy output, the error messages from pyright aren\u0026#39;t links, and we can\u0026#39;t hop between messages using M-g M-n and M-g M-p like before. In order to gain this functionality, we need to add a regex that can parse pyright messages. There are two objects of interest to accomplish this:\ncompilation-error-regexp-alist compilation-error-regexp-alist-alist Here\u0026#39;s the formal description from C-h v compilation-error-regexp-alist:\nAlist that specifies how to match errors in compiler output. On GNU and Unix, any string is a valid filename, so these matchers must make some common sense assumptions, which catch normal cases. A shorter list will be lighter on resource usage. Instead of an alist element, you can use a symbol, which is looked up in ‘compilation-error-regexp-alist-alist’. In not so many words, this says we should modify the *-alist-alist version, and simply add a symbol to the *-alist variable. Examining the current value via C-h v compliation-error-regexp-alist-alist, it\u0026#39;s easy to see that we\u0026#39;re after an expression a bit like this,\n(add-to-list \u0026#39;compilation-error-regexp-alist-alist \u0026#39;(pyright \u0026#34;regexp that parses pyright errors\u0026#34; 1 2 3)) eventually replacing the string in the middle with an actual Emacs regexp. Thankfully, Emacs has the M-x re-builder built in for doing exactly that! Since *Python check: poetry run pyright errors.py* is a buffer like any other, we can hop over to it, and run M-x re-builder to piece together a regex that extracts file name, line number, and column number from each message.\nBuilding the regex that parses pyright errors interactively Clearly, there are some errors in the regexp so far, but as we edit the text in the *RE-Builder* buffer, the highlighting in the *compilation* buffer will update live to show us what would be captured by the regexp we\u0026#39;ve entered. After fiddling with the contents in the bottom buffer to get the highlighting correct, we\u0026#39;ve got this regular expression:\n\u0026#34;^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\u0026#34; Now we just need to add this into the compilation-error-regexp-alist-alist in our init.el:\n;; init.el (require \u0026#39;compile) (add-to-list \u0026#39;compilation-error-regexp-alist-alist \u0026#39;(pyright \u0026#34;^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\u0026#34; 1 2 3)) (add-to-list \u0026#39;compilation-error-regexp-alist \u0026#39;pyright) After restarting emacs with the modified alist, we get error prasing from pyright output:\nFunctional links in the *compilation* buffer after running pyright Virtual Environments Since I use poetry so frequently, and I can prefix all of the Emacs or shell commands with poetry run, it\u0026#39;s pretty rare that I have to invoke specific virtual environments. That said, this guide would have a pretty large hole in it if we didn\u0026#39;t mention the vanilla virtual environment experience.\nMost folks tend to run a slightly different virtual environment workflow from one another. What I\u0026#39;m showing off below is the one I think fits most easily with the flavor of vanilla already presented in this article, with some added knowledge about how .dir-locals.el works (coming up shortly).\nCreate a virtual environment Keeping a .venv folder at the top level of a project is one valid way to organize things, but (vanilla) Emacs isn\u0026#39;t going to make it easy for us to use it that way. Instead, I\u0026#39;d recommend keeping all virtual environments in a central place. For me, that looks like this:\nM-! python3 -m venv ~/.cache/venvs/website This builds a virtualenv named website for python utilities that help buld my blog under the ~/.cache directory on Unix. To use this virtualenv explicitly for shell utilities, I can always run commands like this\nM-! ~/.cache/venvs/website/bin/python -m pip install mypy M-! ~/.cache/venv/website/bin/mypy errors.py Of course, adding the prefix ~/.cache/venvs/website/bin every time is a bit cumbersome, especially for frequent commands like M-x python-check.\n.dir-locals.el for setting virtual environment One quick way to reduce some typing is to add entries in a project file called .dir-locals.el. This is a special data file that Emacs will read, if it exists, and apply to all new buffers within the project. For our needs, we want to apply a couple changes to python-mode specifically to use the virtual environment instead of system python. The two easy ones are the python-check-command and python-shell-virtualenv-root:\n;; .dir-locals.el ((python-mode . ((python-check-command . \u0026#34;%HOME%\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe -m mypy\u0026#34;) (python-shell-virtualenv-root . \u0026#34;~/.cache/venvs/website\u0026#34;)))) I\u0026#39;ve included a quirk of working on Microsoft Windows here - the python-check-command needs to run through your shell, which is cmd.exe by default, and hence requires Windows-style paths. The python-shell-virtualenv-root, however, is evaulated by Emacs, and can use tilde-expansion and Unix-style paths. Changing default shell commands to run through pwsh on Windows would likely alleviate this issue, but it\u0026#39;s worth calling out for cmd.exe users.\nIt\u0026#39;s also worth mentioning here that M-x add-dir-local-variable provides an easy interactive interface to editing the .dir-locals.el file.\nThe python-shell-virtualenv-root part only affects running Python as a shell within Emacs, it does not affect things like PATH, async commands, or M-x compile. To demonstrate this, once we\u0026#39;ve set up .dir-locals.el as above, and we either revert a Python buffer with C-x x g or open a new Python buffer in the same project, a popup like this appears:\nThe local variables list in c:/Users/robbe/repos/renzmann.github.io/content/posts/006_emacs_2_python/ contains values that may not be safe (*). Do you want to apply it? You can type y -- to apply the local variables list. n -- to ignore the local variables list. ! -- to apply the local variables list, and permanently mark these values (*) as safe (in the future, they will be set automatically.) i -- to ignore the local variables list, and permanently mark these values (*) as ignored * python-check-command : \u0026#34;%HOME%\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe -m mypy\u0026#34; * python-shell-virtualenv-root : \u0026#34;~/.cache/venvs/website\u0026#34; Responding with y will set the python-check-command and python-shell-virtualenv-root for just the current session, while ! will add both of these values to the custom section in either init.el or wherever you\u0026#39;ve set your custom-file. This is another reason for using a common, central spot for virtual environments, since across workstations I can use the same path relative to my $HOME directory. After confirming, and using C-c C-p, we can check which Python executable we\u0026#39;re using in the *Python* buffer now:\nPython 3.10.6 (tags/v3.10.6:9c7b4bd, Aug 1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import sys; sys.executable \u0026#39;c:\\\\Users\\\\robbe\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe\u0026#39; Keep in mind, the values provided in .dir-locals.el are evaluated on a per-buffer basis, so attempting to set a relative path like (python-shell-virtualenv-root . \u0026#34;.venv/website\u0026#34;) will only work when executing run-python in the same directory as .dir-locals.el and .venv/.\nThe various compile and shell commands will not respect the virtualenv we\u0026#39;ve set via .dir-locals.el. On *nix, M-x compile RET which python3 will still bring back some variant of /usr/bin/python3, as will M-\u0026amp; which python or M-! which python. In a follow-up article we might explore how it is possible to take care of all this via .dir-locals.el and the special exec variable, but it\u0026#39;s not very elegant.\nAll things considered: pyvenv pyvenv is a very lightweight package, clocking in at around 540 source lines of code, designed specifically around the challenge of ensuring the correct python virtual environment is at the front of PATH when running (async) shell commands, M-x eshell, M-x shell, M-x term, M-x python-check, M-x compile, and more. When written, it was based around virtualenv and virtualenvwrapper.sh, and some of the language it uses will reflect that. Although virtualenv has mostly fallen out of favor, the core functionality of pyvenv is still very relevant. Especially if you choose to adopt a central store of virtual environments, as above, you can set that as a WORKON_HOME variable (\u0026#34;workon\u0026#34; is terminology held over from virtualenvwrapper.sh) to a directory that all your virtual environments sit under, so that it\u0026#39;s easy to select one with the pyvenv-workon function. When using poetry, that usually looks like this:\n(if (eq system-type \u0026#39;windows-nt) ;; Default virtualenv cache directory for poetry on Microsoft Windows (setenv \u0026#34;WORKON_HOME\u0026#34; \u0026#34;$LOCALAPPDATA/pypoetry/Cache/virtualenvs\u0026#34;) ;; Default virtualenv cache directory for poetry on *nix (setenv \u0026#34;WORKON_HOME\u0026#34; \u0026#34;~/.cache/pypoetry/virtualenvs\u0026#34;)) (pyvenv-mode) Setting WORKON_HOME to ~/.cache/venvs as in the previous examples is another valid option. Doing it this way also plays nice with .dir-locals.el, since pyvenv exposes a way to set a project-level venv with a single variable:\n;; .dir-locals.el ((python-mode . ((pyvenv-workon . \u0026#34;website\u0026#34;)))) Also of use for folks who frequently swap between different projects is (pyvenv-tracking-mode), which will automatically change the active python virtual environment when you navigate to a different buffer.\nAnd, of course, if the whole \u0026#34;workon\u0026#34; and virtualenvs grouped together under ~/.cache/venvs isn\u0026#39;t to taste, there\u0026#39;s always M-x pyvenv-activate, which lets you choose a virtual environement anywhere on your system. So, all-in-all, I\u0026#39;ll probably stick with pyvenv in my configuration, because setting all the different utility PATHs without it is just such a pain.\nNext: Notebooking Belive it or not, we\u0026#39;ve only scratched the surface. org-mode and org-babel together provide a fully-functional \u0026#34;notebooking\u0026#34; (technically \u0026#34;literate programming\u0026#34;) experience out of the box with recent versions of Emacs. The next article will focus exclusively on Python and data science in Org as a near-complete Jupyter replacement.\nFootnotes 1 https://python-poetry.org/docs/#installation\n2 https://github.com/microsoft/pyright#command-line\n","date":"4 September 2022","permalink":"/posts/006_emacs_2_python/","section":"Posts","summary":"Intro There are a lot of great guides on getting set up with Python in Emacs.","title":"Python in Emacs: Vanilla is a Powerful Flavor"},{"content":" Setup In one of my first articles about getting set up with packages.el, I left a somewhat expensive line hanging out in the open:\n;; init.el ;; --snip-- (package-refresh-contents) ;; --snip-- This function will call out to any repositories we\u0026#39;ve configured to search packages from and update our local registry of what\u0026#39;s available. That can take a few seconds, and is a bit annoying if you\u0026#39;re constantly restarting Emacs to work on your init.el like I am right now. So it would be nice if this function instead looked something like this:\n(when \u0026lt;packages-aren\u0026#39;t-installed\u0026gt; (package-refresh-contents)) We just need a little code to check when \u0026lt;packages-aren\u0026#39;t-installed\u0026gt; is true. We already discovered that the variable package-selected-packages, managed by custom.el, is a list of packages that we\u0026#39;ve chosen to install. We also know that the function package-installed-p checkes whether a particular package is installed or not. In my init.el, I have a block like so:\n;; init.el ;; --snip-- (custom-set-variables \u0026#39;(package-selected-packages \u0026#39;(markdown-mode marginalia))) ;; --snip-- So it seems like we have the ingredients we need, save for a way to apply the package-installed-p over the whole list package-selected-packages, and reduce down to a single true or false value, depending on if any of the expected packages aren\u0026#39;t installed. Altogether, that means we have a very simple map-reduce problem, and I am certain there\u0026#39;s a function in Emacs ready for us to use - we just need to find it.\nVertical FIDO Mode This hidden superpower of Emacs 28.1+, along with the marginalia package described below, are the main tools in my arsenal for surfacing everything from Emacs\u0026#39; many hidden, labyrinthine depths.\n;; Set \u0026#39;flex\u0026#39; to be the main completion style. This enables a \u0026#34;fuzzy\u0026#34; ;; style of searching for things using the minibuffer (setq completion-styles \u0026#39;(flex basic partial-completion emacs22)) ;; Turn on FIDO (Fake IDO) mode (fido-mode) ;; Have TAB complete using the first option and continue, instead of ;; popping up the *Completions* buffer (define-key icomplete-minibuffer-map [remap minibuffer-complete] \u0026#39;icomplete-force-complete) ;; Sometimes I have to customize this icomplete-compute-delay variable ;; to 0.0 to avoid delay before the M-x minibuffer pops up (setq icomplete-compute-delay 0.0) ;; Set the display to be a vertical list of items, instead of a horizontal one (fido-vertical-mode) This sets up the minibuffer to show a live update of completion candidates as we type, in an easy-to-read vertical format\nMarginalia While not a part of base Emacs, this little package complements the vertical FIDO display by adding information, usually a docstring, next to each item. After performing a M-x package-refresh-contents and M-x package-install RET marginalia, we get this:\nSearch Process The modifications we just made also affect commands that search through variables and functions, like C-h f (describe-function). What we\u0026#39;re after right now is some kind of function that acts on a list, and tells us if any of the items are nil after applying the package-installed-p function to them. My gut tells me that a word like \u0026#34;all\u0026#34;, \u0026#34;every\u0026#34;, or \u0026#34;none\u0026#34; might appear in such a function. After trying a few of these, examining the descriptions, and quickly trying again, a query for the word \u0026#34;any\u0026#34; brought up a promising function called cl-notany\nIt\u0026#39;s close; this one will yield t when every element in the sequence is nil, we want one for when any element is nil. Hitting RET on cl-notany above brings up its help text\ncl-notany is an autoloaded compiled Lisp function in ‘cl-extra.el’. (cl-notany PREDICATE SEQ...) Return true if PREDICATE is false of every element of SEQ or SEQs. [back] There\u0026#39;s a link on `cl-extra` in this buffer, and my bet is that the function we\u0026#39;re looking for would be defined near cl-notany. Following that link takes us to a block of code with the defun for cl-notany. Lo and behold, there\u0026#39;s a cl-notevery right below it with a description that matches exactly what we need:\n;; cl-extra.el ;;;###autoload (defun cl-notany (cl-pred cl-seq \u0026amp;rest cl-rest) \u0026#34;Return true if PREDICATE is false of every element of SEQ or SEQs. \\n(fn PREDICATE SEQ...)\u0026#34; (not (apply #\u0026#39;cl-some cl-pred cl-seq cl-rest))) ;;;###autoload (defun cl-notevery (cl-pred cl-seq \u0026amp;rest cl-rest) \u0026#34;Return true if PREDICATE is false of some element of SEQ or SEQs. \\n(fn PREDICATE SEQ...)\u0026#34; (not (apply #\u0026#39;cl-every cl-pred cl-seq cl-rest))) Writing the when block With cl-notevery in hand, the last step is to apply it in our init.el for managing package refresh and installation.\n(when (cl-notevery \u0026#39;package-installed-p package-selected-packages) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-refresh-contents) (package-install-selected-packages)) ","date":"22 August 2022","permalink":"/posts/007_emacs_3_discovering/","section":"Posts","summary":"Setup In one of my first articles about getting set up with packages.","title":"Discovering Useful Functions in Emacs"},{"content":" Philosophy This is the first part of a series in building an emacs configuration around the data science toolkit, which I introduced in another article. I won\u0026#39;t be covering the absolute basics here, like how to download and install Emacs, but just my thoughts as I start building my configuration from a brand new ~/.emacs.d/init.el1. In many ways, this is a notes-as-I-go type of article, and I may gloss over details I don\u0026#39;t find important yet or would become obvious after a little Googling.\nIf this is your first exposure to Emacs, this is what it looks like when you download it and start it without configuring it at all:\nAt this point, the world is your oyster - they provide a few helpful links to get a new user started, but basically we can take this program and make it do whatever we want, including writing and building this website! While Emacs is a fairly feature-rich editor by itself, I know there are features it doesn\u0026#39;t provide off the shelf that I want to include, especially:\nLanguage server stuff - like pyright for Python editing A git management UI Intellisense-like code completion That means we need to get comfortable with whatever plugin or package system emacs supports. My first impression exploring Reddit, package author sites, and github is that most Emacs-ers have an incredibly favorable view of throwing whatever kitchen sink you like into your configuration, as long as you feel happy.\nThis is a strikingly different attitude compared to (especially vanilla) Vim configuration advice. Typically when asking for advice in the Vim circles you\u0026#39;ll first be greeted with \u0026#34;you aught to try this built-in capability first\u0026#34;. There are also notably vocal members who will argue against using any plugin that doesn\u0026#39;t serve some critical missing functionality of the editor. When dipping into the Emacs forums, quite to the contrary, I\u0026#39;ve seen members mention \u0026#34;I know person A does it like X because of Y, but I do W because Z\u0026#34;, often from a place of understanding or empathy to a particular use case. One user even mentioned that they need vertical popup to assist with voice-powered coding tools, and hence will only consider auto-complete frameworks that work in that way for them. That level of community acceptance and support is encouraging to see, and Neovim has adopted a similar attitude to some extent, but is still somewhat nascent, especially with the recent Vim9/Lua debacle.\nA brief note about keyboard shortcuts and finger contortion I\u0026#39;m including this section about \u0026#34;how to use your fingers\u0026#34; because it\u0026#39;s something I desparately wish had been laid out for me when I was first starting Emacs. There are a lot of key combinations in Emacs that rely on consistent, easy access to the Ctrl and Alt (option on macOS) keys. What I was lacking was a guide along the lines of \u0026#34;use your left little finger for this modifier, followed by your thumb for this one.\u0026#34; Starting out, some of the combinations looked impossibly slow to be useful, just because of the muscle memory I already built around using Ctrl and Alt. For instance, imagine seeing this keyboard shortcut for navigating up three lines in Emacs:\nCtrl + 3 Ctrl + p At the time, I was used to hitting Ctrl+3 with my right little finger on the Ctrl in the lower right and left middle finger on the \u0026#34;3\u0026#34;, and then using the left Ctrl for Ctrl+p. That seemed like a lot of wasted arm movement just to do what would normally be 3k in Vim. In reality, nearly every Emacs user has the \u0026#34;Ctrl\u0026#34; key just to the left of their little finger on the home row.2 This is where most American keyboards place the \u0026#34;Caps Lock\u0026#34; key, which in my opinion is just dead useless. Regardless of whether you use something like Vim or Emacs, this is a good key to remap, and I do it on every workstation with one of these pieces of software:\nmacOS: Karabiner Elements (Third party) Windows: PowerToys (included with Windows 10) Linux: On Ubuntu/Gnome it\u0026#39;s usually as easy as Tweaks -\u0026gt; Keyboard \u0026amp; Mouse -\u0026gt; Additional Layout options QMK Firmware - when I\u0026#39;m on one of my fancy programmable keyboards Given that remapping, the combination should work like this:\nLeft little finger holds down \u0026#34;Ctrl,\u0026#34; using what is normally the \u0026#34;Caps Lock\u0026#34; key Press \u0026#34;3\u0026#34; with left middle finger Press \u0026#34;p\u0026#34; with right ring finger Release \u0026#34;Ctrl\u0026#34; I can perform this version just as fast as 3k in Vim - since the \u0026#34;Ctrl\u0026#34; and \u0026#34;3\u0026#34; can happen at the same time. Below I\u0026#39;ve listed my general \u0026#34;finger flow\u0026#34; to maintain tempo while using Emacs. For the rest of the article I\u0026#39;m going to use Emacs-style notation, which means C-x is \u0026#34;Ctrl\u0026#34; plus \u0026#34;x\u0026#34; at the same time, and M-x for \u0026#34;Alt\u0026#34; plus \u0026#34;x\u0026#34; at the same time. The M is short for \u0026#34;Meta\u0026#34;, a vestigial artifact of Emacs\u0026#39; history as a screen terminal program, and a common point of befuddlement for young, unwary travelers like me.\nLeft little finger for \u0026#34;Ctrl\u0026#34;, left of \u0026#34;a\u0026#34; on American QWERTY keyboard in almost all cases Left thumb on \u0026#34;Meta\u0026#34; (Alt/option), just to the left of the spacebar for most cases Left little finger to use \u0026#34;Cmd\u0026#34; (Windows key, emacs calls this \u0026#34;super\u0026#34;) just to the left of \u0026#34;Meta\u0026#34;, when modifying a right-hand letter, i.e. ⌘-p Either right little finger or right thumb to use \u0026#34;Cmd\u0026#34; when I need a left-hand modified character, like ⌘-w, depending on the keyboard I\u0026#39;m using For C-x and C-c specifically, I have my right enter key bound to \u0026#34;Ctrl\u0026#34; on hold, \u0026#34;Enter\u0026#34; on tap, so that I can type the x and c characters as I normally would, without stretching my left little finger upwards and to the left at the same time. When I don\u0026#39;t have the ability to program my Enter key this way, I\u0026#39;ll hop between using the right Ctrl and modified Caps Lock key For M-x (that\u0026#39;s \u0026#34;Alt\u0026#34; and \u0026#34;x\u0026#34; together, or \u0026#34;option\u0026#34; + \u0026#34;x\u0026#34; on a mac, which Emacs calls \u0026#34;Meta\u0026#34;) specifically, I will usually use either my right thumb or right little finger on the Alt/option key, depending on the keyboard and how wide the spacebar is, because I find that more comfortable than crossing over on my left hand to hit both keys. Similarly, I find M-q, M-w, and M-z all easier by using both hands Actually setting up the config Now that we\u0026#39;ve made it past the first hurdle of using the keyboard, we can actually open Emacs and start configuring it. The most radical departure from my experience in Vim/Neovim starts here, with the Easy Customize interactive system. Emacs leans heavily on its interactive components, backed by plain text and data - which was admittedly a pleasant discovery. VSCode rediscovered this type of system by providing an easy customization UI representing a swath of JSON configuration under the hood, which has proved immensely popular. By comparison, I would argue that the Emacs interface is downright hideous, but easier to grok.\nBy way of example, let\u0026#39;s walk what it looks like to customize the color theme just via interactive commands. First, we hit M-x, Emacs\u0026#39; equivalent of the \u0026#34;Command Palette\u0026#34;, if you\u0026#39;re coming from something like VSCode or Jupyter, and enter customize-theme to get a menu that shows all the default color themes we could use. Another option, barring the use of M-x, is to use the menu bar and mouse just like we would in any other GUI program: \u0026#34;Options -\u0026gt; Customize Emacs -\u0026gt; Custom Themes\u0026#34; takes us to the same place.\nClicking the check box next to \u0026#34;tango-dark\u0026#34; and then clicking the \u0026#34;Save Theme Settings\u0026#34; results in a modified color theme that looks like this:\nThere are now two new things in your home directory:\nA file called .emacs A directory called .emacs.d/ Opening the former using \u0026#34;File -\u0026gt; Open File…\u0026#34; (which may require turning on a \u0026#34;Show Hidden Files\u0026#34; option, depending on your system) shows us this set of text:\n(custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won\u0026#39;t work right. \u0026#39;(custom-enabled-themes \u0026#39;(tango-dark))) (custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won\u0026#39;t work right. ) The code here is Emacs LISP - a programming language in its own right - and the main configuration language for the Emacs editor. Coming from Vim, where the only method of configuration is by manually editing your ~/.vimrc, this really blew my socks off. The implication here is that we can use interactive menus, backed by a proper programming language (not just JSON data), which can take effect right next to my hand-tuned configuration, and I\u0026#39;m free to modify it however I like later on. It is a bit cumbersome to have two folders dedicated to configuration, though, so the first thing I do here is \u0026#34;File -\u0026gt; Save As…\u0026#34; and write it to ~/.emacs.d/init.el, then delete the ~/.emacs file. Emacs will automatically detect this and load the correct file the next time we start it up.\nA short foray into elisp Usually, the first symbol inside parenthesis is a function, and the remaining symbols its arguments. So, coming from more traditional languages like Java, Python, C, etc., I tend to visualize it this way:\nelisp version Kinda like ------------- ---------- (foo) foo() (foo \u0026#34;bar\u0026#34;) foo(\u0026#34;bar\u0026#34;) (foo \u0026#34;bar\u0026#34; 2) foo(\u0026#34;bar\u0026#34;, 2) I say \u0026#34;usually\u0026#34; because there are other constructs, such as special forms and macros, but I\u0026#39;m definitely not getting to those for a while. I also say \u0026#34;Kinda like\u0026#34; because I\u0026#39;m pretty sure an experienced elisp-er would look at what I\u0026#39;ve written and say \u0026#34;yeah, no\u0026#34;, but as I\u0026#39;m just starting out this is a helpful mental thesaurus.\nRedirect \u0026#34;custom\u0026#34; to separate the interactive stuff from our hand-edited parts We\u0026#39;re going to do a combination of letting the customization menus manage the blocks like we showed above and writing a little configuration ourselves, so I\u0026#39;m going to redirect custom to a different file, then load it from there:\n;; ~/.emacs.d/init.el ;; Redirect custom so it doesn\u0026#39;t edit this file (setq custom-file \u0026#34;~/.emacs.d/custom.el\u0026#34;) ;; Load the custom file (when (file-exists-p custom-file) (load custom-file)) In ~/.emacs.d/custom.el, I placed all the contents of what was written by \u0026#34;custom\u0026#34; - the block that originally went to ~/.emacs after saving the custom theme. Now we have two distinct spots for customizing emacs:\n~/.emacs.d/custom.el - managed by the interactive customization menus. We never touch this one by hand ~/.emacs.d/init.el - customization we do write by hand Later on I\u0026#39;ll cover some other common settings for the init.el file, but for now we\u0026#39;ll leave it be to address more important things. Namely, let\u0026#39;s start plugging in new packages.\nEdit what packages we use interactively Unlike most package managers in the Vim world, it\u0026#39;s rare nowadays to grab code directly off github or submoduling/unzipping some tarball into your configuration directory. Rather, there\u0026#39;s a central repository called ELPA, located at http://elpa.gnu.org/, which hosts well-known packages we can install right away (Python folks can think of ELPA a bit like PyPI). By running M-x list-packages, we\u0026#39;re prompted with this lovely screen:\nThere are a few special key commands, the most common of which I am using are /n to filter by name and /s installed to look for packages I currently have installed.\nThe first thing I wanted was a vertical pop-up style for my minibuffer when using M-x or C-x C-f (finding files), a lot like the \u0026#34;command palette\u0026#34; you get in other editors like VSCode, Jupyter, and JetBrains, when selecting generic actions to take. As of Emacs 28, there\u0026#39;s a built-in vertical FIDO mode that mostly does this, but I kept getting a delay between pressing M-x and the minibuffer popping up, so I opted for a third party package called vertico that I\u0026#39;m very happy with. To install it, all I had to do was use the M-x list-packages buffer posted above and click on \u0026#34;install\u0026#34;, or use M-x package-install RET vertico (that\u0026#39;s M-x package-install, followed by hitting \u0026#34;enter\u0026#34;, then typing vertico and hitting enter again), and Emacs has automatically done three things for me:\nFetched the latest version of the package from ELPA and downloaded it Byte-compiled and installed the package into my editor Edited ~/.emacs.d/custom.el to signal that I selected and installed a new package That last one is mind-blowing. Emacs edited a variable called package-selected-packages and put it into my custom.el file, just by the very nature of installing it interactively.\n;; ~/.emacs.d/custom.el ;; --snip-- \u0026#39;(package-selected-packages \u0026#39;(vertico)) ;; --snip-- This means I can use all of Emacs\u0026#39; interactive features, even while keeping my configuration under the proper text-based version control of my choosing. It also leaves the possibility of managing this variable manually via ~/.emacs.d/init.el open, but we aren\u0026#39;t there yet. At any point, I can also use M-x package-delete or the packages buffer to interactively remove a package from Emacs and ~/.emacs.d/custom.el. Since I\u0026#39;d like to ship my Emacs configuration to many workstations, I\u0026#39;d like Emacs to automatically install these selected plugins, and remove obsolete ones, at boot. There are a couple functions that allow me to do this:\n;; ~/.emacs.d/init.el ;; Enable built-in package manager (require \u0026#39;package) ;; Redirect custom so it doesn\u0026#39;t edit this file (setq custom-file \u0026#34;~/.emacs.d/custom.el\u0026#34;) ;; Load the custom file (when (file-exists-p custom-file) (load custom-file)) ;; At this point, package-selected-packages has been set by loading the custom-file ;; Remove any packages that are installed, but aren\u0026#39;t listed in package-selected-packages (package-autoremove) ;; Keep our registry up-to-date (package-refresh-contents) ;; Install selected packages (package-install-selected-packages) As far as I\u0026#39;m concerned at the moment, this is all the package management I need! The built-in support is so good that I don\u0026#39;t find myself wanting to reach towards an external package manager at all, like I would typically do in Neovim.3\nCommunity packages There is also a community-maintained, much larger selection of plugins on something called \u0026#34;Milkypostman\u0026#39;s Emacs Lisp Package Archive\u0026#34;, usually abbreviated to MELPA, which serves an almost identical role as ELPA, but doesn\u0026#39;t require going through the official GNU channels to get your project hosted. As such, most projects on GitHub require you to enable fetching packages from MELPA before installing. There are two versions of MELPA - melpa.org/packages and the \u0026#34;stable\u0026#34; melpa.org/packages. Both the MELPA setup instructions and community discussion recommend against the use of MELPA-stable, so I\u0026#39;ll be sticking with the regular version:\n;; ~/.emacs.d/init.el ;; --snip-- ;; Keep our registry up-to-date (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-refresh-contents) ;; --snip-- There\u0026#39;s a decent amount of elisp witchcraft in the add-to-list statement alone, but in essence it just enables Emacs to \u0026#34;see\u0026#34; what\u0026#39;s on the community MELPA archive when we run M-x list-packages or M-x package-install. After adding this and digging around /r/emacs and github, I have a minimal set of packages that are enabling me to be productive without too much configuration so far4\ncorfu (intellisense-like autocomplete; plays well with orderless below) exec-path-from-shell (macOS specific) go-mode magit (UI for git, I think basically everyone grabs this) marginalia (preview that works amazingly well with vertico, shows me things like documentation and keybindings next to commands when I open M-x) markdown-mode orderless (a \u0026#34;completion style\u0026#34; that\u0026#39;s pretty nifty, once you get the hang of it) restart-emacs rust-mode tree-sitter (more intelligent code highlighting) tree-sitter-langs use-package (a configuration macro, see below) writeroom-mode (distraction-free writing, which I use for this blog) I am also trying out both lsp-mode with lsp-pyright and eglot for language server stuff to see which one I like better, but haven\u0026#39;t finalized it yet so we\u0026#39;ll keep them in our back pocket for now. I tend to shy away from exceptionally large frameworks, so helm didn\u0026#39;t look appealing at first glance. I\u0026#39;d rather pick exactly the pieces I want to include and get them working one-by-one.\nConfiguring packages we\u0026#39;ve installed The one piece that confused me more than anything while starting out is what the heck use-package actually is or does. Many users online would refer to it as \u0026#34;their package manager\u0026#34;, however it is emphatically not a package manager, as the very first section of their README notes. Because I had just been copying use-package snippets from around the internet before I took a minute to read the use-package documentation, it took me a while to figure out that use-package is meant to be used in conjunction with a package manager, which in our case is the built-in package.el. After package.el installs a new package, it\u0026#39;s likely there are ways to tweak that package that suit our tastes, and that is what we ask use-package to do for us.\nWithout diving into too much detail, it\u0026#39;s easy to imagine how complex managing package start up, configuration, and order-of-operations could be:\nDid I make sure load this package after its prerequisites? How do enable keybindings only when this package is active? How can I delay loading this big, expensive package until I actually need it? It bears mentioning that there are ways to have use-package interface with package.el, but I\u0026#39;m going to hold off on those until I feel like I need them. Here\u0026#39;s an example of how I configure tree-sitter to add spiffy highlighting everywhere I go, without bogging down startup time of emacs:\n(use-package tree-sitter :init (global-tree-sitter-mode) :hook (tree-sitter-after-on . tree-sitter-hl-mode) :config (use-package tree-sitter-hl) (use-package tree-sitter-langs) (use-package tree-sitter-debug) (use-package tree-sitter-query)) The README on the use-package GitHub page explains all the special :\u0026lt;section\u0026gt; bits, but in essence this is a clean way of saying:\nRun (global-tree-sitter-mode) on startup Turn on tree-sitter-hl-mode whenever we boot up tree-sitter Configure tree-sitter to also use four other useful packages There are many, many capabilities bundled into use-package, and even very minimal configurations will tend to include it, because of the brevity it brings to advanced package configuration.\nUpdates 2022-08-19: Recommend against the MELPA-stable repository, after a bit of research 1 For our resident Microsoft Windows users - I\u0026#39;ll be using Unix-style paths, which means ~ is the home directory, like C:\\Users\\Robb, and / as path separators. Fret not, as Emacs will understand this style of pathing and the ~, even on Windows\n2 It\u0026#39;s also likely that its predecessor TECO from the 60\u0026#39;s was developed on a terminal on which the \u0026#34;Ctrl\u0026#34; key was located just to the left of a\n3 Such as packer.nvim (inspired by use-package) or vim-plug\n4 I\u0026#39;ll use another article to cover specific, intersting configuration on a per-package basis\n","date":"7 August 2022","permalink":"/posts/005_emacs_1_packages/","section":"Posts","summary":"Philosophy This is the first part of a series in building an emacs configuration around the data science toolkit, which I introduced in another article.","title":"Emacs Part 1: The Keyboard and Packages"},{"content":" I\u0026#39;m pretty happy with my (neo)vim setup. Wielding it, I can walk into most code bases and be useful. There comes a point, though, where we hit a wall, look at Jupyter or VSCode, and think \u0026#34;damn, that actually is pretty useful.\u0026#34; This started happening more frequently as my workflow transitioned to terminal-based tooling for Python and away from Jupyter and PyCharm. Suddenly, I found myself lacking some of the basics we need to do useful data science, like rich text (math) and images (plots). I don\u0026#39;t want to give up my precious all-about-me editing experience, though, and if I can avoid proprietary software, I will.\nLike most fledgling data scientists, my journey began on a Jupyter notebook, followed by JupyterLab, when it came out. After learning that \u0026#34;hey, I can make my own libraries too!\u0026#34;, I found Spyder from the Anaconda ecosystem, jumped to PyCharm for a while, all the while using a dash of Vim on the side. Recently, I went all-in on a lua configuration for Neovim, and that\u0026#39;s been my home for the last couple years now, except for when I just need a notebook. Typically I still turn to JupyterLab when I need a literate programming environment, with access to plotting inline with code. Sometimes a notebook is just the right thing for the job. Other times, I need a text editor and a language server for some back-end work. I want a free/libre environment that supports both of these, and right now I don\u0026#39;t think the options are great.\nSpyder is probably the closest right now, but I have the least experience with it. The messaging from their website is wholly python-centric, though, and I\u0026#39;m looking for a much more generic tool. I also have no idea how well it handles remote project development VSCode is currently the gold standard in terms of \u0026#34;just working\u0026#34; out of the box. I haven\u0026#39;t seen anything integrate with remote development, including Jupyter notebooks, as well as this one does. It doesn\u0026#39;t meet the \u0026#34;libre\u0026#34; requirement, though, and Microsoft has no plans for opening its pylance server either PyCharm is a behemoth powerhouse for working on a local codebase. It absolutely falls apart when trying to work on remote projects Vim and Neovim are terminal editors, and by their very nature are not designed for displaying images. Really, they are designed to address the physical act of editing text, and leave the other components of your development workflow to be integrated some other way (i.e. running commands in one tmux window and vim in the other) I think Pluto is incredibly slick, and I wish more notebooking environments operated like it So where does this leave us? Emacs has:\nRich text and image display (as a GUI program) Inline literate programming via org-mode, and many Jupyter integration projects Support for basically every programming language on the planet Tree-sitter and Language Server Protocol (LSP) support, with the option to choose our own server A fully featured general programming language for configuration and extension (Emacs LISP) An enormous integrated help and documentation system Cross-platform to Windows, Linux, and macOS Libre license (GNU GPL 3.0) Built-in remote development support (via TRAMP) Terminal emulation via any of `M-x term`, `M-x shell`, or `M-x eshell` All that to say Emacs is a tempting offer, and I\u0026#39;m going to try diving in so that you don\u0026#39;t have to. The plan is to build an emacs configuration from scratch with the goal of a data science workstation in mind, and will be aimed at folks like me - people who want to learn how this crazy emacs monster works, and are maybe a strong Vimmer, but haven\u0026#39;t had the chance to really sit down an learn emacs yet. As such, this will be more than a \u0026#34;follow-along\u0026#34; configuration guide; rather I\u0026#39;m aiming to dig into the details, and weigh the merits of choosing one thing over another, especially as they compare against their (neo)vim counterparts. As long as I can keep up, the plan is one post a week, focusing on a single component to integrate, such as LSP, auto-complete, remote workflow, notebooks, packaging, Windows-specific forays, and so on. I may reference back to this article and change it up a bit as we learn more, so that this article can be the one-stop-shop on justification for \u0026#34;why emacs\u0026#34;?\nAt the end of the day, though, this whole process is largely to document my own learning process, so I can come back and say \u0026#34;why on earth did I do it this way? Oh, that\u0026#39;s right…\u0026#34; There are already an enormous number of excellent learning materials out there for picking up emacs, so my recommendation for other people like me is to also give them a shot:\nThe official Emacs manual An Introduction to Programming in Emacs Lisp Mastering Emacs ","date":"31 July 2022","permalink":"/posts/004_emacs_start/","section":"Posts","summary":"I\u0026#39;m pretty happy with my (neo)vim setup.","title":"Emacs Has Been Waiting for Data Science"},{"content":"Some time ago, I saw this fantastic talk by Sandy Metz on favoring object composition over inheritance.\nAt the 17:00 mark, she introduces the cumulative folk tale This Is the House That Jack Built, the first few lines of which looks like this:\nThis is the house that Jack built. This is the rat that ate the cheese that lay in the house that Jack built. This is the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. This is the cow with the crumpled horn that tossed the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. This is the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. \u0026hellip;\nFor the rest of the talk, she focuses on the problem of programming a class that can perform two transformations on the poem:\nRandomize the order in which lines are added, so that the \u0026ldquo;rat that ate the cheese\u0026rdquo; might come before the \u0026ldquo;maiden all forlorn\u0026rdquo; \u0026ldquo;Echo\u0026rdquo; each line, so that we get \u0026ldquo;the cow with the crumpled horn that tossed the cow with the crumpled horn\u0026rdquo; That is, a user should be able to instantiate a class that can recite the poem verbatim, recite a randomized poem, recite an echoed poem, or recite a poem that\u0026rsquo;s both random and echoed. What makes this interesting as a data scientist or engineer is that she\u0026rsquo;s tackling the problem of object composition in the context of a data pipeline. So in this article, I\u0026rsquo;m going to cover Python solutions to this problem in three broad strokes:\nWhat does a literal translation of the object-oriented version look like in Python, while still remaining \u0026ldquo;pythonic?\u0026rdquo; How can we extend the code to swap the order in which transformations happen? How can we simplify the user experience by translating the logic to pure functions? On point 3 - I tend to believe a functional style, where data is immutable and pure functions create new, transformed data is usually the right approach to any system that\u0026rsquo;s \u0026ldquo;data first\u0026rdquo;. It also reduces overhead for most users by avoiding the introduction of a new object type. That\u0026rsquo;s not always a good thing, but specifically in the context of a Python end user, this means they need only remember the recite() function, and not both the House() object and its recite() method. While not strictly a functional language, Python does offer some key functional components, namely first-class functions and currying, so we\u0026rsquo;ll take a look at how those can still be useful even when building a more object-centric solution.\nThe Object-Oriented Python Solution to RandomEchoHouse # This article uses Python 3.10 syntax. To run examples on older versions of Python, some adjustments to the type annotations are required. First, let\u0026rsquo;s set up a new Python file random_echo.py with some imports we\u0026rsquo;ll need, the poem\u0026rsquo;s data as a module constant1, and a couple type aliases to make future code more readable:\n#!/usr/bin/env python3 import random from typing import Callable # requires pip install of `more-itertools` from more_itertools import always_iterable Poem = list[str] PoemTransform = Callable[[Poem], Poem] HOUSE_POEM = [ \u0026#34;the horse and the hound and the horn that belonged to\u0026#34;, \u0026#34;the farmer sowing his corn that kept\u0026#34;, \u0026#34;the rooster that crowed in the morn that woke\u0026#34;, \u0026#34;the judge all shaven and shorn that married\u0026#34;, \u0026#34;the man all tattered and torn that kissed\u0026#34;, \u0026#34;the maiden all forlorn that milked\u0026#34;, \u0026#34;the cow with the crumpled horn that tossed\u0026#34;, \u0026#34;the dog that worried the cat that chased\u0026#34;, \u0026#34;the rat that ate the cheese that lay in\u0026#34;, \u0026#34;the house that Jack built\u0026#34;, ] So from now on, a Poem is any list of string values, just like HOUSE_POEM, and a PoemTransform is any function that takes in a Poem as its only argument and returns a Poem.\nOur objective is to produce variations on this poem using a single interface:\nRecite the original poem Recite a version of the poem in random order Recite a version of the poem with each line \u0026ldquo;echoed\u0026rdquo; (duplicated) Recite the poem both in random order and with duplicated lines There are three possible transformations of a poem - we echo it, we randomize it, or we do nothing. The fourth option is a composition of the two other non-identity transformations, so we don\u0026rsquo;t consider it a separate object. Ruby has a much stricter object-oriented paradigm than Python, so Sandy\u0026rsquo;s example uses a dedicated class with a single method for each role. Such ceremony isn\u0026rsquo;t required in Python, though. We can just define a pure function for each processing step.\n# --snip-- def identity(x: Any) -\u0026gt; Any: return x def random_order(poem: Poem, random_seed: int = 42) -\u0026gt; Poem: random.seed(random_seed) return random.sample(poem, len(poem)) def echo_format(poem: Poem) -\u0026gt; Poem: return [f\u0026#34;{line} {line}\u0026#34; for line in poem] To start, let\u0026rsquo;s look at a literal translation of Sandy\u0026rsquo;s House class into Python:\n# --snip-- class House: def __init__( self, order: PoemTransform = identity, fmt: PoemTransform = identity, ): self.lines = order(fmt(HOUSE_POEM)) def recite(self, stanza: int | Sequence[int] | None = None) -\u0026gt; None: if stanza is None: indices = range(len(self.lines)) else: indices = always_iterable(stanza) for i in indices: stanza_lines = self.lines[-(i + 1) :] joined = \u0026#34;\\n\u0026#34;.join(stanza_lines) print(\u0026#34;This is \u0026#34;, joined, \u0026#34;.\u0026#34;, sep=\u0026#34;\u0026#34;, end=\u0026#34;\\n\\n\u0026#34;) Anyone who\u0026rsquo;s seen Jack Diederich\u0026rsquo;s Stop Writing Classes should notice a red flag here. We have two methods, one of which is __init__(), so that means this class is really just an obfuscated call to a recite function. In the next section we\u0026rsquo;ll refactor this down to a flatter API, but for the moment let\u0026rsquo;s just examine how this class works by dropping into an interactive session:\n$ python3 -i random_echo.py \u0026gt;\u0026gt;\u0026gt; house = House() \u0026gt;\u0026gt;\u0026gt; house.recite() # the whole tale This is the house that Jack built. ... the rat that ate the cheese that lay in the house that Jack built. \u0026gt;\u0026gt;\u0026gt; house.recite(2) # just stanza 2 This is the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. \u0026gt;\u0026gt;\u0026gt; # We can \u0026#34;plug in\u0026#34; any function for the `order` role \u0026gt;\u0026gt;\u0026gt; random_house = House(order=random_order) \u0026gt;\u0026gt;\u0026gt; random_house.recite(4) This is the maiden all forlorn that milked the rat that ate the cheese that lay in the rooster that crowed in the morn that woke the judge all shaven and shorn that married the dog that worried the cat that chased. \u0026gt;\u0026gt;\u0026gt; # Similarly for the `fmt` role \u0026gt;\u0026gt;\u0026gt; echo_house = House(fmt=echo_format) \u0026gt;\u0026gt;\u0026gt; echo_house.recite(3) This is the cow with the crumpled horn that tossed the cow with the crumpled horn that tossed the dog that worried the cat that chased the dog that worried the cat that chased the rat that ate the cheese that lay in the rat that ate the cheese that lay in the house that Jack built the house that Jack built. \u0026gt;\u0026gt;\u0026gt; # Including both at once \u0026gt;\u0026gt;\u0026gt; random_echo_house = House(order=random_order, fmt=echo_format) \u0026gt;\u0026gt;\u0026gt; random_echo_house.recite() This is the dog that ... Feature Request: Line Numbers # \u0026ldquo;Can we get line numbers before each of the chunks even when randomizing? It makes it easier to read.\u0026rdquo;\nEasy. We just make a new formatter:\ndef linum_format(poem: Poem) -\u0026gt; Poem: return [f\u0026#34;{i}: {line}\u0026#34; for i, line in enumerate(poem)] random_line_house = House(fmt=linum_format, order=random_order) random_line_house.recite(9) # This is 0: the farmer sowing his corn that kept # 1: the horse and the hound and the horn that belonged to # 2: the man all tattered and torn that kissed # ... \u0026ldquo;We noticed something,\u0026rdquo; our client says. \u0026ldquo;It looks like the randomization happens before the line numbers are made. What we really wanted was to keep the original line numbers, so we know what happened. But that\u0026rsquo;s fine, we were able to just swap the two functions and now it\u0026rsquo;s working great!\u0026rdquo;\nTo our horror, we open their code and see this:\nmyhouse = House(fmt=random_order, order=linum_format) myhouse.recite(9) # This is 1: the farmer sowing his corn that kept # 0: the horse and the hound and the horn that belonged to # 4: the man all tattered and torn that kissed # ... And even worse:\ndef mynumbers(p): return linum_format(echo_format(x)) myhouse2 = House(order=mynumbers, fmt=random_order) Uh oh. We baked the ordering into House.__init__, and because we didn\u0026rsquo;t provide a generic enough API for composing functions, it\u0026rsquo;s getting used in a way we didn\u0026rsquo;t expect, which will certainly put mental burden on future maintainers as well. We now have three options:\nForce an API change that prevents the situation above Deprecate the House class and point users to a newer, better function Open up the public interface with a little more flexibility, at the expense of directly representing business logic In my experience, #1 is rarely prudent. # 2 may or may not be appropriate, depending on what the actual product is. However, as library authors it\u0026rsquo;s our responsibility to keep the public interface as consistent as possible over time. So let\u0026rsquo;s explore what it means to abstract our code a little to achieve better \u0026ldquo;pluggability\u0026rdquo;:\nFunctions First # I want to take it all the way back to the drawing board. What\u0026rsquo;s the simplest part we can keep the same? Probably all of linum_format, echo_format, and random_order remain unchanged.\nFollowing that, we need a small adjustment to the recite function: given a Poem, just print it out on the correct stanza.\n#!/usr/bin/env python3 # Identical to the `House` class version, but doesn\u0026#39;t # rely on stateful `self.lines` def recite(poem: Poem, stanza: int| Sequence[int] | None = None) -\u0026gt; None: if stanza is None: indices = range(len(poem)) else: indices = always_iterable(stanza) for i in indices: stanza_lines = poem[-(i + 1) :] joined = \u0026#34;\\n\u0026#34;.join(stanza_lines) print(\u0026#34;This is \u0026#34;, joined, \u0026#34;.\u0026#34;, sep=\u0026#34;\u0026#34;, end=\u0026#34;\\n\\n\u0026#34;) With that totally compartmentalized, now we can focus entirely on the composition part.\nNotice that the House class utilized one stateful object - the transformed poem after applying the order and fmt functions. This got stored in the self.lines attribute, and subsequent calls for specific stanzas didn\u0026rsquo;t have to re-transform the poem. _recite_stanza just read the data and printed it. Depending on how expensive we expect the functions to be, we can either keep this behavior, or switch to a version where we transform the poem each time we pass it in to recite. All in all, though, it\u0026rsquo;s impossible for us as library authors to predict which of these cases our users will be bound to, so it\u0026rsquo;s actually a poor design in the first place to force this data to persist in memory without their consent. The recite function now takes any poem. So we can pass in a transient, quickly garbage-collected one like this:\nrecite(echo_format(HOUSE_POEM)) Or collect a transformed version, persist it, and pass that in:\nrandom_echo_house = echo_format(random_order(HOUSE_POEM)) recite(random_echo_house) In the end, only the developers implementing the data (HOUSE_POEM) and the functions that act on it (random_order and echo_format) will know which of the two approaches above is appropriate, so we should give them that freedom.\nNext, we have the problem of arbitrary function composition. It\u0026rsquo;s a bit clunky to manually produce each composition like this:\ndef random_echo(poem: Poem) -\u0026gt; Poem: return echo_format(random_order(poem)) def echo_linum(poem: Poem) -\u0026gt; Poem: return linum_format(echo_format(poem)) # ... likewise for other combinations Can we provide a generic factory that lets users define a new transformation pipeline on the fly? How about a function that takes a variable set of functions as arguments, and returns a PoemTransform?\ndef compose(*funcs: PoemTransform) -\u0026gt; PoemTransform: def pipeline(poem: Poem) -\u0026gt; Poem: for f in funcs: poem = f(poem) return poem return pipeline linum_echo_random = compose(linum_format, echo_format, random_order) recite(linum_echo_random(HOUSE_POEM), stanza=9) # This is 1: the farmer sowing his corn that kept 1: the farmer sowing his corn that kept # 0: the horse and the hound and the horn that belonged to 0: the horse and the hound and the horn that belonged to # 4: the man all tattered and torn that kissed 4: the man all tattered and torn that kissed # ... It might not look like much, but because most programmers prefer reading function application from left-to-right rather than inside-out (mathematicians being the notable holdout here), some may prefer this. If our functions had varying input and output types, I would keep the slightly clunkier version where we explicitly compose functions via def and return f1(f2(...)) solely for the reason of having the pyright static type checker ensure that I\u0026rsquo;ve chained inputs and outputs correctly. Since all of our functions are PoemTransform, though, we don\u0026rsquo;t need to worry about type checking within the compose function. That is, all the input and output types are Poem, so the resulting function chain is safe.\nA note on mixins # At around the 23:35 mark, an audience member shouts out \u0026ldquo;use multiple inheritance!\u0026rdquo; to which Sandy says \u0026ldquo;just stop that - we\u0026rsquo;re not using multiple inheritance here, it\u0026rsquo;s not the right solution for this problem.\u0026rdquo;\nIt\u0026rsquo;s interesting to note that scikit-learn does exactly this as a way of composing model behavior. Every ridge regression is a regression, after all, and it will always need the attributes that come with a regression, such as its coefficient of determination and fit() method.\nPython doesn\u0026rsquo;t actually have \u0026ldquo;constants\u0026rdquo;, but by convention an all-uppercase variable is meant to signify it\u0026rsquo;s supposed to be constant\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"4 May 2022","permalink":"/posts/003_random_echo_house/","section":"Posts","summary":"Some time ago, I saw this fantastic talk by Sandy Metz on favoring object composition over inheritance.","title":"Data Pipelines as Function Composition"},{"content":"It took me a while to admit it, but with a little upfront time investment, the command line is probably the fastest way to get most tasks accomplished. For me, most tasks means short, one-off, common file operations, such as:\nTrying to find that one damn file that\u0026rsquo;s nested somewhere down all those folders Figuring out what version(s) of python I have installed, and making new virtual environments Downloading files from a link and unzipping the results Examining and editing the contents of a file Can an IDE or VScode offer all this to me? Yup. Those tools are awesome, but when I\u0026rsquo;m on the phone with someone, and they say \u0026ldquo;hey, can you pull up that one thing real fast?\u0026rdquo; I don\u0026rsquo;t have time to boot JetBrains, nor do I want to dig through VScode menus. I pop open the terminal, fuzzy search where I need to go, and hit the file with vim if it\u0026rsquo;s text or open1 if it\u0026rsquo;s something like Excel or PowerPoint. The process of getting that file open from a cold start is around 10 seconds. Here\u0026rsquo;s an example where I\u0026rsquo;m looking for a copy of the Python logo:\nfzf here indexed over a million files on my computer, but because I was able to find it using just a few key words I knew were in the file path or name.\nLet\u0026rsquo;s say it takes on average around 30 seconds to find a file clicking through a file manager.2 That\u0026rsquo;s 20 seconds of savings per file. Suppose we only look for around a dozen files like this per work day. Back of napkin math tells us:\n20 seconds/file * 12 files/day * 5 days/wk / 3600 s/hr ------------- 0.33 hours/wk So assuming you work with roughly the numbers above, one hour of getting comfortable with fzf will pay for itself in under three weeks. Scale this against the number of files you open, and how deeply nested down a mounted SharePoint folder they might be, and the dividends are much faster. If your work looks anything like mine, you\u0026rsquo;re sifting through at least several dozen spreadsheets, presentations, and source code files every day, many of them with similar names but with v3.pptx or v_FINAL.xlsx tacked on the end.\nDoes everyone need to use a fuzzy-finder to find and open files? Certainly not. Some Unix die-hards abhor the use of fuzzy-finders in their workflow, but I just can\u0026rsquo;t seem to get a pure \u0026ldquo;unixy\u0026rdquo; way to work nearly as fast as ctrl+t followed by slapping the keyboard with letters that might be somewhere in that file name.3 I also don\u0026rsquo;t think comments in the spirit of the linked /u/romainl comment have the same set of assumptions about what a \u0026ldquo;typical\u0026rdquo; data science setup looks like. I haven\u0026rsquo;t worked professionally as a website developer, but I have a feeling we work in very different environments. Often I\u0026rsquo;m sitting in front of a data warehouse I\u0026rsquo;ve never connected to before, with 2,000 unique table names, each with possibly 200+ columns. Usually the first thing I do is write a small fzf window that lets me search columns or table names. \u0026ldquo;Are there any features related to customer age? Did an excel sheet from last month make it into the data lake?\u0026rdquo; Interactive, visual feedback as I type these things, followed by a ctrl+u to clear the search bar is way faster than building a pipe with find and/or grep and examining the results each time.\nResources # fzf installation instructions kitty terminal \u0026ndash; This is how I can icat an image in the terminal This is a macOS command. On Windows, just type the name of the file. For Linux I usually am on Gnome desktop, which uses gio open\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI\u0026rsquo;d love some actual hard numbers here, but I\u0026rsquo;d consider this a conservative estimate\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThat said, find . -name \u0026quot;whatever.csv\u0026quot; is definitely still useful in a lot of cases\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"18 April 2022","permalink":"/posts/002_in_defense_of_fuzzy_finders/","section":"Posts","summary":"It took me a while to admit it, but with a little upfront time investment, the command line is probably the fastest way to get most tasks accomplished.","title":"In Defense of Fuzzy Finders"},{"content":"If you aren\u0026rsquo;t regularly wiping and rebuilding your virtual environments, you should be; anyone trying to run your project for the first time will thank you for it. For most folks that\u0026rsquo;s using python -m venv .venv to create a new one, or conda create if you\u0026rsquo;re on the conda stack. I do this so frequently that it became my first bash alias. In sh, bash, and most other shells, there\u0026rsquo;s more than one way to make longer commands shorter, the easiest of which is the alias:\nalias so=\u0026#34;source .venv/bin/activate\u0026#34; After running this, when we use so as the first command, it will be replaced with the text source .venv/bin/activate. Remembering to just type so once I cd to a project is much easier to remember and type quickly. If we don\u0026rsquo;t already have an environment, we usually have to create it:\nalias new-venv=\u0026#34;python -m venv .venv\u0026#34; To chain two operations together in bash, we use \u0026amp;\u0026amp; to allow the second part to run only if the first one succeeded:\nnew-venv \u0026amp;\u0026amp; so Beyond that, we usually have to upgrade pip in the new environment\nnew-venv \u0026amp;\u0026amp; so \u0026amp;\u0026amp; pip install --upgrade pip wheel And this chain is so common, I actually have the entire thing under the new-venv name, but as a bash function so it can take arguments:\nnew-venv() { local name=${1:-.venv} local python_version=${2:-3} python${python_version} -m venv $name \\ \u0026amp;\u0026amp; source $name/bin/activate \\ \u0026amp;\u0026amp; python3 -m pip install --upgrade pip wheel } The usage of this function is like this:\nnew-venv [NAME] [PYTHON_VERSION] with both arguments optional. The voodoo magic on the first two lines inside the function just says:\nAssign the value of the first argument to the name variable, and set it to \u0026ldquo;.venv\u0026rdquo; if nothing is passed in Assign the value of the second parameter to the python_version variable, and set it to \u0026ldquo;3\u0026rdquo; if nothing is passed in Physical savings might only be a few letters, but there\u0026rsquo;s a real cognitive benefit to building out your most common operations as aliases or functions. You can think at higher levels of operation, with four to five commands clicked together instead of just the current one. Often I go \u0026ldquo;I call uncle! Let\u0026rsquo;s try with a fresh environment\u0026rdquo;\ndeactivate \u0026amp;\u0026amp; rm -rf .venv \u0026amp;\u0026amp; new-venv \u0026amp;\u0026amp; poetry install Raymond Hettinger says we have a buffer in our mind of \u0026ldquo;about five things, plus or minus two\u0026rdquo;. By reducing the process above to only four steps, even on a bad day I can remember how to do this.\nTo make sure these aliases/functions are available every time you log in, add them to your \u0026ldquo;rc\u0026rdquo; file. For most folks that\u0026rsquo;s ~/.bashrc, but fish users would use funced and funcsave, zsh users have ~/.zshrc, and on Windows there\u0026rsquo;s a host of options (I wouldn\u0026rsquo;t try all this in cmd).\nI actually like the funced idea from fish a lot, so I use something similar. This allows me to edit any function in my ~/.bash_functions folder, which is then loaded up using load-funcs (also a function), and that is what gets executed by my ~/.bashrc. This gives me the chance to very quickly save useful snippets like what\u0026rsquo;s above for later. In particular, instead of looking up the right invocation to install poetry every time, I just tucked it away into the install-poetry function when I first ran it, and now it\u0026rsquo;s ready for me everywhere I take my dotfiles.\n","date":"6 April 2022","permalink":"/posts/001_faster_pyvenv/","section":"Posts","summary":"If you aren\u0026rsquo;t regularly wiping and rebuilding your virtual environments, you should be; anyone trying to run your project for the first time will thank you for it.","title":"Manage Python Environments Faster With Aliases and Functions"},{"content":"In data science and engineering we tend to think in \u0026ldquo;DAGs\u0026rdquo; (directed acyclic graphs), which just means \u0026ldquo;to make this report, we first have to build this other thing, and to build that thing, we have to run these two queries, and so on. It decomposes the process of building data and artifacts like visualizations or data exports into smaller, individual chunks.\nThere are a lot of contenders in the market for selling solutions to this exact scenario, and each one solves it a little differently. Right now the hot thing is dbt, but before that we had airflow, dagster, prefect, argo, and a host of others that all were built to operate DAGs at scale on different platforms. For large, mission-critical data pipelines these can provide a lot of value, but the truth is that as data scientists, most of us don\u0026rsquo;t need something this heavy. Most projects I see really just need some way of defining the links between \u0026ldquo;scrapbook output\u0026rdquo;. Maybe it\u0026rsquo;s a jupyter notebook, or a python script, or some queries that have to happen in a particular order based on an updated warehouse feed.\nMoreover, there are some reasons you might not want to try adding an entire workflow management ecosystem into your stack. Maybe:\nYou can\u0026rsquo;t get permission for a new install You don\u0026rsquo;t want to force another install on your end users or coworkers You don\u0026rsquo;t want more transitive dependencies entering the picture You don\u0026rsquo;t like someone trying to sell their cloud solution on top of the free tier offering to you make was born from a history of compiling C programs on Unix machines in the 70\u0026rsquo;s, but it\u0026rsquo;s completely agnostic to language choice. It\u0026rsquo;s job is to translate targets and prerequisites into a DAG, and incrementally build only the parts it needs to when any of the source files change. Given that, why would I choose Make over one of the more modern alternatives?\nThe commands are elegant - I enjoy the language of make report.xlsx Parallel execution is built in and easy to turn on or off It\u0026rsquo;s installed on damn near everything,1 and has proven over the last 50 years to be a shark, not a dinosaur It\u0026rsquo;s a \u0026ldquo;small\u0026rdquo; program. You can get through the documentation and start creating useful software in a couple hours. Like SQL, Make is declarative. We describe the result, and let the program optimize the route by which we get there. Creating a simple project with make and python # I\u0026rsquo;m going to use a distilled example of a recent project I built using just a Makefile, some python, and a little SQL. By the end of this my hope is to show that simple tools can be efficient and reliable, and avoid the overhead of learning, installing, configuring, and inevitably debugging something more complex.2 Ultimately, I wanted to hand this project off in such a way that any of my teammates could maintain it if I was unavailable, so it had to be short, and stick to the tools I know they will always have installed.\nOur goal is to produce an Excel file for executive consumption that has a meaningful summary of some data pulled out of our analytics warehouse. Overall, it\u0026rsquo;ll look a little like this:\nbase queries --\u0026gt; summary CSVs --\u0026gt; (report.xlsx, diagrams for powerpoint) The \u0026ldquo;base\u0026rdquo; queries might look a lot like temporary tables or common table expressions (CTEs, or those blocks you see in WITH statements), but we\u0026rsquo;ve broken them into several, separate queries. We\u0026rsquo;re plopping those summarized results into some flat files so that we can examine the results with our favorite tools like pandas or awk. We\u0026rsquo;ll then take all those flat results and produce deliverables from them, like charts and an excel file.\nmyguy is always there for me, so that\u0026rsquo;s the name of our project, and its basic structure looks like this:\n. ├── config.yml ├── Makefile ├── myguy.py ├── README.md └── sql ├── this_quarter_sales.sql ├── model_forecast.sql └── customer_disposition.sql We will execute each file in the sql/ directory as a query we execute and then locally cache the results as CSVs. Later we\u0026rsquo;ll discuss how to handle the case where all our queries are handled remotely, and don\u0026rsquo;t create local files, such as running CREATE TABLE AS (ctas) queries prior to building the report, but for now we\u0026rsquo;ll keep it simple: query \u0026ndash;\u0026gt; csv on computer.\nOur goal is to make reproducing this report dead simple. I should only have to run this command to rebuild the report at any time:\nmake report.xlsx The cookbook that provides this rule is the Makefile.\n# Makefile report.xlsx: myguy.py python -m myguy build-report If this is your first time seeing make, there are a few terms to know:\nreport.xlsx - this is the target of the rule. It is the file produced by running make report.xlsx myguy.py - the prerequisite of report.xlsx. It has to exist in order to create the excel file. If this python file\u0026rsquo;s contents have changed recently, then that\u0026rsquo;s an indication that report.xlsx may also change. python -m myguy build-report - this is the recipe that Make runs when you issue the command make report.xlsx. I am invoking python with the -m, or \u0026ldquo;run module as main\u0026rdquo; flag in case we ever refactor our single .py file into a module, like myguy/__init__.py with its complementary \u0026ldquo;dunder main\u0026rdquo; myguy/__main__.py. Our main entry point will be in the python module. This will handle the program runtime for executing queries or doing some pandas hackery.\n# myguy.py from pathlib import Path from time import sleep import click import pandas as pd @click.group() def cli(): pass @cli.command() @click.option( \u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;Write to file\u0026#34;, default=f\u0026#34;{BUILD_DIR}/report.xlsx\u0026#34;, show_default=True, ) def build_report(output: str): \u0026#34;\u0026#34;\u0026#34; Generate a new Excel workbook and save it locally. \u0026#34;\u0026#34;\u0026#34; # Suppose this produces, you know, useful data pd.DataFrame(dict(a=range(3), b=list(\u0026#34;abc\u0026#34;))).to_excel(output, index=False) sleep(2) print(f\u0026#34;Saved report to {output}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: cli() I think click is just great, and provides me with a lot of zen writing a command line interface (CLI) compared to argparse, although you could achieve everything I\u0026rsquo;m doing in this article equally well with argparse. In this script we create a cli group because we\u0026rsquo;ll eventually add more commands to it. The build_report function just replicates a process that takes a couple seconds before it outputs a file to build/report.xlsx.\nIt takes very little code to get a pleasant command line experience with nested commands. Here\u0026rsquo;s a quick example of using it after adding another command called query, which we\u0026rsquo;ll get to in a moment:\nHowever, if we try building our report right now with make report.xlsx, we get a FileNotFoundError: [Errno 2] No such file or directory: 'build/report.xlsx', and that\u0026rsquo;s because we need to make sure the build directory exists before running this command. We could handle that in the python with a few lines, but why not have our dependency management tool, make, do it for us?\n# Makefile build: mkdir -p build report.xlsx: myguy.py | build python -m myguy build-report Now our make report.xlsx works just fine, and we get a new directory build with our empty report in it. Normally we won\u0026rsquo;t need the |, but in this case it declares that the build rule should only be run once, even if we have other targets with build as a prerequisite.3 If we rerun make report.xlsx, it doesn\u0026rsquo;t try to create that directory again, because it already exists.\nWe do have one other problem though: if we re-run the python code, it will overwrite our report, even if nothing has changed. Instead, we should get a message saying make: 'report.xlsx' is up to date. This is happening because our target is report.xlsx instead of build/report.xlsx, so make looks in the current directory, sees that there\u0026rsquo;s no report.xlsx and therefore runs the recipe. I don\u0026rsquo;t want to write make build/report.xlsx, so what we\u0026rsquo;ll do is set up make to automatically look in our build and sql directories for files by setting the VPATH variable:\n# Makefile BUILDDIR := build SQLDIR := sql VPATH := $(SQLDIR):$(TARGETDIR) $(BUILDDIR): mkdir -p $(BUILDDIR) report.xlsx: myguy.py | $(BULDDIR) python -m myguy build-report By doing this, we can just issue make report.xlsx instead of make build/report.xlsx. Setting build to a variable (referenced via $(BUILDDIR)) allows us to change up the build directory on a whim, should we need to.\nNext, we need to structure the rules that handle our queries, so let\u0026rsquo;s add a generic method for doing exactly that, given the path to a sql file.\n# myguy.py, cont. from datetime import datetime # ...other content same as before... BUILD_DIR = \u0026#34;build\u0026#34; @cli.command() @click.argument(\u0026#34;path\u0026#34;) def query(path: str): \u0026#34;\u0026#34;\u0026#34; Issue the query located at `path` to the database, and write the results to a similarly-named CSV in the `build` directory. \\b Examples -------- This command will produce a new file foobar.csv in the `myguy.BUILD_DIR` directory: $ python -m myguy query sql/foobar.sql \u0026#34;\u0026#34;\u0026#34; # Hey look, more fake code for an article about querying data sleep(2) destination = Path(BUILD_DIR) / Path(path).with_suffix(\u0026#34;.csv\u0026#34;).name ( pd.DataFrame( dict(time_updated=[datetime.now()]) ) .to_csv(destination, index=False) ) print(f\u0026#34;Finished query for {path} and wrote results to {destination}\u0026#34;) Again, imagine that the \u0026ldquo;sleep\u0026rdquo; we\u0026rsquo;re doing here is some body of actual code that fetches results from the database. We also don\u0026rsquo;t need pandas for something as banal as touching a csv with today\u0026rsquo;s date, but it\u0026rsquo;s there to replicate the very common use case of pd.read_sql -\u0026gt; to_csv, which is nearly always the most efficient way to write a program that acquires a database connection, queries it, and writes the results to a csv for analytics-scale work in python like this.\nWe\u0026rsquo;ve also refactored out the destination build directory into a variable, so we can have the make script grab that automatically using the shell built-in:\n# Makefile BUILDDIR := $(shell python -c \u0026#39;import myguy; print(myguy.BUILD_DIR)\u0026#39;) This technique is also useful for having builds that depend on things like myguy.__version__, if it exists. With the python in place, we need to set up our recipes that run the queries. A naive first approach might look like this:\n# Makefile, cont. # ... same as above ... this_quarter_sales.csv: this_quarter_sales.sql python -m myguy query sql/this_quarter_sales.sql model_forecast.csv: model_forecast.sql python -m myguy query sql/model_forecast.sql customer_disposition.csv: customer_disposition.sql python -m myguy query sql/customer_disposition.sql That\u0026rsquo;s a lot of repetition, so our programmer instincts should kick in here and tell us that \u0026ldquo;there must be a better way!\u0026rdquo;4. Make can handle this using implicit rules. We specify a pattern like this, and Make will do all the hard work of connecting the files together:\n%.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; This takes care of all three rules at once.\nThe % is a wildcard - it matches anything and our rules here say that \u0026ldquo;if we\u0026rsquo;re going to build a .csv, then it has a similarly-named .sql file as a prerequisite. The @ at the start of the recipe suppresses echoing of the command when Make runs it The $\u0026lt; is an automatic variable that stands for the first prerequisite. In our case, that will be the full path to the .sql file we are passing into the query function we previously wrote. Since myguy.py is the \u0026ldquo;source\u0026rdquo; of the running command, that\u0026rsquo;s also a prerequisite the | $(BUILDDIR), as before, says that we have an order-only prerequisite on the build directory, and our earlier rule will ensure mkdir build is run before trying to put output there Now we can issue the same command as our report to build the CSV from each of our queries:\n$ make this_quarter_sales.csv Finished query for sql/this_quarter_sales.sql and wrote results to build/this_quarter_sales.csv We still need to tie all these together so that I don\u0026rsquo;t have to run each command manually - we want to just run make report.xlsx and have it do all the prerequisite queries for us. To accomplish this, we\u0026rsquo;re going to use two more built-ins, wildcard and patsubst to build the prerequisite and target lists, respectively.\nSQLFILES := $(wildcard $(SQLDIR)/*.sql) TARGETS := $(patsubst $(SQLDIR)/%.sql,%.csv,$(SQLFILES)) If we were to echo the contents of these two variables, they would look like this:\n# contents of SQLFILES sql/customer_disposition.sql sql/model_forecast.sql sql/this_quarter_sales.sql # contents of TARGETS customer_disposition.csv model_forecast.csv this_quarter_sales.csv Since our report.xlsx depends on all three of the files in TARGETS, we bind them together in that rule:\n# Makefile # ... other content same as before ... report.xlsx: $(TARGETS) @python -m myguy build-report Note here that we took out the myguy.py and $(BUILDDIR) prerequisites from this rule, since those are coming from our implicit rule on the $(TARGETS). I\u0026rsquo;m also going to add a clean rule for trying things over from a fresh start:\nclean: @[ ! -d $(BUILDDIR) ] || rm -r $(BUILDDIR) Decomposing this into English:\n@ - don\u0026rsquo;t echo this command when it runs. Just run it. [ ! -d $(BUILDDIR) ] || - unless the BUILDDIR is missing, do the next command5 rm -r $(BUILDDIR) - remove the contents of the BUILDDIR recursively Here\u0026rsquo;s where our Makefile is now:\n# Makefile BUILDDIR := $(shell python -c \u0026#39;import myguy; print(myguy.BUILD_DIR)\u0026#39;) SQLDIR := sql VPATH := $(SQLDIR):$(TARGETDIR) SQLFILES := $(wildcard $(SQLDIR)/*.sql) TARGETS := $(patsubst $(SQLDIR)/%.sql,%.csv,$(SQLFILES)) report.xlsx: $(TARGETS) @python -m myguy build-report $(BUILDDIR): mkdir -p $(BUILDDIR) %.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; clean: @[ ! -d $(BUILDDIR) ] || rm -r $(BUILDDIR) So now we can run clean and build the report:\nWe can do better though. Make has parallelism built in, and most of our computers have no trouble running things concurrently. By providing the -j (jobs) flag, we can tell it to do several things at once as long as they don\u0026rsquo;t depend on one another. Since our intermediate queries to CSV fit the bill, they can all run at the same time:\nIt\u0026rsquo;s also possible to enable parallelism by default with the MAKEFLAGS special variable.\n# Makefile MAKEFLAGS := --jobs=$(shell nproc) Adding dependencies between intermediate queries # Let\u0026rsquo;s suppose we add two more queries, and they need to run before our existing queries, because we did a little refactoring of our SQL.\nOur DAG Moreover, let\u0026rsquo;s assume that these two new tables are too large to cache locally in a flat file, and we have to issue a CREATE TABLE AS (ctas) statement to build them first. Not every database will permit you to run a CTAS on it, but imagine this is any process that writes data remotely instead of locally, such as spark writing a parquet file on S3, or submitting a POST request to an endpoint we don\u0026rsquo;t control.\nWe represent this in Make by first writing out the targets and prerequisites with different suffixes. For the remote tables, I\u0026rsquo;ll use the \u0026lsquo;.ctas\u0026rsquo; suffix. I also like to do this in a separate file, dag.mk, so I can hop to its buffer directly in my editor.\n# dag.mk sales_subset.ctas: customer_product.ctas: this_quarter_sales.csv model_forecast.csv: sales_subset.ctas customer_disposition.csv: customer_product.ctas This arrangement forces the completion of sales_subset.csv and customer_product.csv prior to the original three queries. Then in the main MakeFile, we include these contents above the rules that handle .csv files, along with a new rule for handling the remote tables. The %.ctas rule will create an empty target as soon as the query is done, signaling to make when it last completed successfully:\n# Makefile # ... other content the same ... include dag.mk %.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; %.ctas: %.sql myguy.py | $(BUILDDIR) @python -m myguy ctas $\u0026lt; @touch $(BUILDDIR)/$@ Note that this includes a new command for myguy, so let\u0026rsquo;s add that too:\n# myguy.py @cli.command() @click.argument(\u0026#34;path\u0026#34;) def ctas(path: str): \u0026#34;\u0026#34;\u0026#34; Perform a CREATE TABLE AS statement from the SELECT statement in the given SQL file path. \u0026#34;\u0026#34;\u0026#34; sql_file = Path(path) query = f\u0026#34;CREATE TABLE {sql_file.stem} AS {sql_file.read_text()}\u0026#34; print(query) sleep(3) # imagine the query is running And one last thing - our $(TARGETS) assignment has no way of telling which sql files it should or shouldn\u0026rsquo;t tie to CSVs. The easiest way to make this distinction is to actually just remove $(TARGETS) altogether, and have the dag.mk declare what report.xlsx depends on.\n# dag.mk # ...other contents the same... report.xlsx: this_quarter_sales.csv \\ model_forecast.csv \\ customer_disposition.csv # Makefile report.xlsx: @python -m myguy build-report Make will take care of combining these two rules into a single one. If all the targets are going to have the same suffix, such as .ctas or .csv, then the trick with $(TARGETS) is handy, but adds more complexity than it\u0026rsquo;s worth when mixing target file types.\nAltogether, our dag now looks like this:\nTemplating the SQL with Jinja # To round out some of our feature parity with dbt, we need to add templating to our SQL. It\u0026rsquo;s best if I don\u0026rsquo;t have to think about how the template is injected, I just want a standard place to put stuff and have the python module take care of it. Let\u0026rsquo;s introduce a configuration file:\n# config.yml sales_max_date: \u0026#34;2022-03-01\u0026#34; sales_min_date: \u0026#34;2021-09-01\u0026#34; Presumably, a future analyst will have to come refresh this report for a different set of dates, and we want that configuration readily available to them. The templating engine we\u0026rsquo;ll use is the same on available on dbt, Jinja2. How we integrate it is by intercepting our python code that reads queries and applying the template from the config there. The jinja2 part is a little verbose, but flexible - anything that\u0026rsquo;s in our config will be available to the templated SQL:6\n# myguy.py import yaml import jinja2 # ... other content the same ... BUILD_DIR = \u0026#34;build\u0026#34; PROJECT_DIR = Path(__file__).parent def get_config(): with open(PROJECT_DIR / \u0026#34;config.yml\u0026#34;) as f: config = yaml.safe_load(f) return config # The `str | Path` union type hint is python 3.10 syntax, so watch out if you\u0026#39;re # on an older version! def read_sql_text(path: str | Path) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Read a SQL file contents and apply jinja templating from this project\u0026#39;s config.yml \u0026#34;\u0026#34;\u0026#34; config = get_config() jinja_loader = jinja2.FileSystemLoader(PROJECT_DIR) jinja_environment = jinja2.Environment(loader=jinja_loader) template = jinja_environment.get_template(str(path)) sql = template.render(**config) return sql And now we use this version of the sql in the ctas and query functions:\n# myguy.py # ...other content the same ... def query(path: str): sql = read_sql_text(path) destination = Path(BUILD_DIR) / Path(path).with_suffix(\u0026#34;.csv\u0026#34;).name # Assuming you have some way of acquiring a database connection with get_connection() as conn: pd.read_sql(sql, conn).to_csv(destination) def ctas(path: str): path = Path(path) sql = f\u0026#34;CREATE TABLE `{path.stem}` AS {read_sql_text(path)}\u0026#34; with get_connection() as conn: conn.execute(sql) Within the SQL itself, we can now reference any of the keys in the config.yml directly:\n# sales_subset.sql SELECT product_id , sales_revenue , sales_units FROM fact_sales WHERE sales_date BETWEEN date(\u0026#39;{{ sales_min_date }}\u0026#39;) AND date(\u0026#39;{{ sales_max_date }}\u0026#39;) I\u0026rsquo;m not here to cover everything you can do with jinja and yaml, since those are already pretty well covered. If you haven\u0026rsquo;t used it before, it\u0026rsquo;s worth looking into. It\u0026rsquo;s very powerful. The looping and conditional constructs can make what would normally be pretty tough with just raw SQL easy. When we issue a make recent_sales.ctas command, it looks like this:\n$ make sales_subset.ctas mkdir -p build CREATE TABLE `sales_subset` AS SELECT product_id , sales_revenue , sales_units FROM fact_sales WHERE sales_date BETWEEN date(\u0026#39;2021-09-01\u0026#39;) AND date(\u0026#39;2022-03-01\u0026#39;) Conclusion # There we have it, a simple little dag system for coordinating our project\u0026rsquo;s deliverables. For a working example of how to implement this project structure, check out the companion repo, which builds a simple analysis on the chinook dataset. This example also includes code that produces .png files for including into presentations and migrates the mypy.py into a fully-fledged, pip-installable module.\nExcept Windows. You\u0026rsquo;ll need to get it via mingw/cygwin or via the Windows subsystem for Linux.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI fully acknowledge the irony here that make is, in fact, a very foreign tool to many data scientists.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThese are called order-only prerequisites\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI\u0026rsquo;m taking this phrase from Raymond Hettinger, who gives fantastic talks on writing idomatic python. I recommend his beyond PEP8 talk to all levels of developers.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe do \u0026ldquo;unless\u0026rdquo; instead of the more familiar \u0026ldquo;if\u0026rdquo; statement, because if we did this: [ -d $(BUILDDIR) ] \u0026amp;\u0026amp; rm -r $(BUILDDIR) the test command [ exits with status 1 when the build directory doesn\u0026rsquo;t exist, and hence the whole pipe exits status 1. Make treats that as a failed recipe, which isn\u0026rsquo;t what we intend. We want it to look like a success both in the case of removing the directory should it exist, and doing nothing if it doesn\u0026rsquo;t.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nYou should be extremely careful about templating like this. This article also uses f-strings for injecting arbitrary code into SQL, which is unacceptable if any of your system is public facing. All of these examples are working under the assumption that we\u0026rsquo;re in a locked-down internal data warehouse, and someone who has access to the system in any way is allowed to issue an arbitrary query.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"6 March 2022","permalink":"/posts/000_make_dag/","section":"Posts","summary":"In data science and engineering we tend to think in \u0026ldquo;DAGs\u0026rdquo; (directed acyclic graphs), which just means \u0026ldquo;to make this report, we first have to build this other thing, and to build that thing, we have to run these two queries, and so on.","title":"Building DAGs with Make, SQL, and python"},{"content":"Why create a new tech blog when so many great ones already exist? In short, because data scientists often get the advice that they should \u0026ldquo;improve their software engineering skills,\u0026rdquo; but the advice they are given on how to do so is usually terrible1. Data science, from a programming perspective, is in a weird place. We aren\u0026rsquo;t quite front end, but we create maps, charts, and plots to display in the browser all the time. We aren\u0026rsquo;t quite back end, yet we write code that targets the file system, databases, and external APIs. And we aren\u0026rsquo;t quite consultants, but still have to be the expert, data-driven decision maker. Data science is not a slow moving field, either, which leaves little space for pausing to reflect on how to write better code.\nI primarily work in a world that uses python, SQL, the standard GNU toolkit (bash, make, vim), and the usual host of data-sciency things that come with all that, like Jupyter and plotly. My posts will be largely targeted at an audience who intends to become more efficient with these tools, or to introduce those who want to become better coders, but aren\u0026rsquo;t sure where to start, to some of the tools that can improve your data science workflow. For about five years now, I\u0026rsquo;ve mentored Data Science team members from writing their first line of code to maintaining 100k \u0026ldquo;source lines of code\u0026rdquo; (SLOC) code bases2. I\u0026rsquo;ve received (and given) many questions prefaced with \u0026ldquo;this may be a stupid question, but\u0026hellip;\u0026rdquo;, and thought that it was about time I wrote down the answers for others to learn from.\nAs of writing, it\u0026rsquo;s February of 2022 and I still see Reddit comments telling new python programmers that requirements.txt is an acceptable form of project dependency management.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSeasoned programming veterans out there might scoff at how low 100k sounds, but for those accustomed to working mainly in Jupyter notebooks, this can be a daunting amount of code.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"26 February 2022","permalink":"/posts/my-first-post/","section":"Posts","summary":"Why create a new tech blog when so many great ones already exist?","title":"Objective"},{"content":"\u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"\u003e My Literate =.emacs.d= Table of Contents Goals Notable Features Tangling Inspirations Getting Emacs Header Custom Proxy settings Packages OS-specific Configuration Font Theme Emacs' Built-in Settings Keybindings Text Completion Language-specific major modes Tool configuration Footer Want to use it? Go ahead! git clone https://github.com/renzmann/.emacs.d ~/.emacs.d All external dependency sources are explicitly included under the elpa/ directory, meaning it's as simple as \"clone-n-go\". Opening this document under my configuration looks like so: If you prefer a prettier reading experience, check out this same document weaved into my website. Or, if you're already reading this on my website, check out the source code on GitHub. Goals If I had to sum up the theme of my configuration, it would be \"vanilla extract,\" because in only a few instances do I change the overt behavior of Emacs. Even with those, though, I want a configuration that fits my hands in such a way that I remain comfortable using emacs -Q with very little disruption to my normal muscle memory and workflow. Aside from these aesthetic and philosophical reasons, there are practical concerns this configuration needs to address. I spend my time on Windows for games, macOS or Linux with remote machines for work, and desktop Linux for personal projects like building my website. Some of these situations enforce a very slow internet connection and tight security measures for Tramp, which can cause modern, \"live updating\" features like corfu and consult to hang Emacs. In other cases, I have no access to the outside internet at all (so no ELPA or MELPA updates). Hence, keeping only a small number of external dependencies under elpa/ maximizes portability and maintainability between systems. Altogether, I wind up using Emacs 29+ on all three of the major platforms, in both GUI and TTY mode. So this config is designed to work equally well for: platform terminal GUI ssh + TTY Tramp Linux ✅ ✅ ✅ ✅ macOS ✅ ✅ ✅ ✅ Windows ❌ ✅ ❌ ✅ Notable Features You may notice that despite the laudable goal of intended minimalism, this document is is still quite long, as I have found many (ever increasing) quirky behaviors of Emacs that I tweak. Most of my time is spent in Org, SQL, Python, Bash, YAML, TOML, and Markdown, so the majority of configuration lies around these sections. I do make changes to things that I feel \"should have been included.\" Some examples of this are: Additional major modes for common filetypes like Markdown, CSV, and YAML Error message support for pyright in a *Compilation* buffer Reasonable indentation behavior for SQL files Updating buffers automatically if their contents change on disk Syntax highlighting for Source blocks in Markdown Handling ANSI color escape codes in shell output, compilation, and VC buffers Tangling My configuration is a single literate programming document, which is tangled into the standard init.el and supporting files. This is so I can keep track of all the crazy things I try, and explain them inline with the final code I decide to include. Some platforms like GitHub can render this document in a limited way, but to see all the final configuration values I use you will likely have to view this document in Emacs itself. Why use a literate document for my configuration? Basically, as I added more comments and reminders about what some line of code was doing, where I got it from, and why it might be commented out, the prose grew longer than the actual code, and so a change of medium felt prudent. In my case, that's the venerable Org mode, which comes with Emacs and serves as a way to seamlessly weave commentary and code together. Inspirations I steal quite a lot from other, more qualified Emacs community contributors, such as: Protesilaos Stavrou Ramón Panadestein Mickey Petersen Daniel Mendler Omar Antolín Camarena Luca's Literate Config Getting Emacs For a while I would try to compile Emacs myself, but installing the whole compilation toolchain hasn't been worth it lately, especially on Windows. Instead, I've started simply downloading emacs from these sources on each of the platforms: Windows I go to the pretest FTP to get the latest version of Emacs. Usually not quite up-to-date with the master branch, but still one version number ahead of the most recent official release. Mac On macOS, I've had the best luck with jimeh's nightly builds. These Emacs.app bundles have no external dependencies, signed with a developer certificate, and notarized by Apple, so it just works. Even without administrator permissions, you can drag the bundle to the \"Applications\" folder under your user home instead, and Emacs still works beautifully. In particular, this feature has saved me a lot of headaches that I ran into compiling Emacs on my own: Emacs.app is signed with a developer certificate and notarized by Apple. Very nice! Linux Depending on the machine, I get Emacs one of several ways in a GNU/Linux setup. These rank from highest to lowest priority: Through my system package manager, such as sudo apt-get install emacs or pacman -S emacs Through the official FTP Through the pretest FTP Through condax Compiling it myself Compiling If I do ever want to compile it myself, these are the options I use, making sure to export the correct CC and GCC variables: git clone git://git.savannah.gnu.org/emacs.git --branch emacs-29 --depth 1 export CC=/usr/bin/gcc-10 CXX=/usr/bin/gcc-10 ./autogen.sh ./configure \\ --prefix=/c/emacs-29 \\ --with-native-compilation \\ --with-tree-sitter \\ --with-gnutls \\ --with-jpeg \\ --with-png \\ --with-rsvg \\ --with-tiff \\ --with-wide-int \\ --with-xft \\ --with-xml2 \\ --with-xpm \\ --without-dbus \\ --without-pop make --jobs=$(nproc) sudo make install Header To comply with the Emacs conventions for libraries, the tangled init.el must have the following header and footer: ;;; init.el --- Robb's Emacs configuration -*- lexical-binding: t -*- ;; Copyright (C) 2022 Robert Enzmann\n;; Author: Robb Enzmann \u0026lt;robbenzmann@gmail.com\u0026gt; ;; Keywords: internal ;; URL: https://robbmann.io/\n;;; Commentary: ;; A mostly minimal, reproducible Emacs configuration. This file is ;; automatically tangled from README.org, with header/footer comments on each ;; code block that allow for de-tangling the source back to README.org when ;; working on this file directly.\n;;; Code: Custom I prefer having custom modify its own file. This next snippet ensures any package-install or custom edits go to custom.el. (setq custom-file (expand-file-name \"custom.el\" user-emacs-directory)) (when (file-exists-p custom-file) (load custom-file 'noerror)) Proxy settings When behind a corporate proxy, we might have to authenticate before we can pull packages off ELPA. Emacs only uses the HOST and PORT portions of the http_proxy and https_proxy environment variables, so we need to set LOGIN (user id) and PASSWORD ourselves. I store the login, port, and host variables in a proxy.el file (obviously outside version control) when I'm on a machine that's behind an http proxy. We grab the password interactively when such a file exists. (defun renz/enable-proxy () (interactive) \"Turn on HTTP proxy.\" (let ((proxy-file (expand-file-name \"proxy.el\" user-emacs-directory))) (when (file-exists-p proxy-file) (load-file proxy-file) (setq url-proxy-services `((\"no_proxy\" . \"^\\\\(localhost\\\\|10.*\\\\)\") (\"http\" . ,(concat renz/proxy-host \":\" renz/proxy-port)) (\"https\" . ,(concat renz/proxy-host \":\" renz/proxy-port)))) (setq url-http-proxy-basic-auth-storage (list (list (concat renz/proxy-host \":\" renz/proxy-port) (cons renz/proxy-login (base64-encode-string (concat renz/proxy-login \":\" (password-read \"Proxy password: \")))))))))) Packages The initial cornerstone of every Emacs configuration is a decision on package management and configuration. I opt for use-package and package.el, since both are built-in to Emacs 29+, which helps maximize stability and portability. To avoid loading packages twice, the manual recommends disabling package-enable-at-startup in init.el. (require 'package) (setq package-enable-at-startup nil) (add-to-list 'package-archives '(\"melpa\" . \"https://melpa.org/packages/\") t) I do not use the :ensure t keyword in use-package declarations to install packages, because I cannot always ensure that I have a stable connection to GNU ELPA (in the case of package-install-selected-packages) or the public github.com (for package-vc-install-selected-packages). Instead, I rely on M-x package-install and M-x package-delete, and only permit use-package to handle the configuration and loading of packages. As mentioned in the introduction, each package's source is explicitly included into version control of my configuration, so I don't worry too much about pinning package versions in this file. When I want to update a package, I use M-x package-update, the package.el user interface, or delete the package's source folder and use renz/package-sync (defined below). Should something go wrong, I roll back to a previous commit. So far, this method has been reliable for keeping my init.el (this README), custom.el, the package-selected-packages variable, and elpa/ directory all in sync with one another. (defun renz/package-sync () \"Remove unused sources and install any missing ones.\" (interactive) (package-autoremove) (package-install-selected-packages) (package-vc-install-selected-packages)) (when (and (cl-notevery \u0026lsquo;package-installed-p package-selected-packages) (yes-or-no-p \u0026ldquo;Install VC packages?\u0026rdquo;)) (package-vc-install-selected-packages)) There are also a few hand-made packages I keep around in a special .emacs.d/site-lisp directory. (add-to-list 'load-path (expand-file-name \"site-lisp/\" user-emacs-directory)) OS-specific Configuration Microsoft Windows Windows, funnily enough, has some trouble registering the Windows key as a usable modifier for Emacs. In fact, s-l will never be an option, since it's handled at the hardware level. (defun renz/windowsp () \"Are we on Microsoft Windows?\" (memq system-type '(windows-nt cygwin ms-dos))) (when (and (renz/windowsp) (executable-find \"pwsh\")) (setq shell-file-name \"pwsh\")) There are a few things I set up independent of Emacs. Namely, find, xargs, and rg. These days, I can usually install these things with winget: winget install BurntSushi.ripgrep.GNU winget install GnuWin32.FindUtils winget install GnuWin32.Grep winget install RubyInstallerTeam.RubyWithDevKit.3.2 # For building my website with Jekyll winget install Python.Python.3.11 # I work a lot in python You can use Emacs without these, but some commands like M-x grep or M-x project-find-regexp will not work without making sure the GNU version of find and grep (or a suitable replacement) are on your PATH. I tend not to muck with PATH inside Emacs if I can help it, and instead launch Emacs from powershell where things are properly set. Usually I'll have some things like this in my $PROFILE: $ENV:Path = \"${ENV:ProgramFiles}\\Hunspell\\bin\\;\" + $ENV:Path $ENV:Path = \"${ENV:ProgramFiles(x86)}\\GnuWin32\\bin\\;\" + $ENV:Path $ENV:Path = \"${ENV:ProgramFiles}\\Emacs\\emacs-29.1\\bin\\;\" + $ENV:Path $ENV:PROFILE = $PROFILE $ENV:LANG = \"en_US\" $ENV:DICPATH = \"$ENV:ProgramFiles\\Hunspell\\\" The duplicate $PROFILE thing is so we can access that file through C-x C-f $PROFILE within Emacs. Check out the Spellchecking section on the Hunspell stuff. On the winkey For a time I considered enabling the use of the winkey like this: (setq w32-pass-lwindow-to-system nil) (setq w32-lwindow-modifier 'super) ; Left Windows key (setq w32-pass-rwindow-to-system nil) (setq w32-rwindow-modifier 'super) ; Right Windows key Followed by enabling specific chords, such as \"winkey+a\": (w32-register-hot-key [s-a]) Since I've taken a more TTY-friendly approach for my config in general, where super can be a bit tough to integrate with both the windowing application and the terminal emulator, I've mostly given up on the GUI key in favor of other chords, especially the C-c ones. macOS Launching Emacs from the typical application launcher or command-space usually won't capture any modifications to $PATH, typically handled in a file like ~/.profile or ~/.bashrc. So, the main configuration included here is from exec-path-from-shell. (when (eq system-type 'darwin) (setq exec-path-from-shell-arguments '(\"-l\")) (exec-path-from-shell-initialize)) Font Fonts are a tricky business. See Emacs/Fonts in the manual (C-h i) for relevant information on how checking and setting default fonts works: Searching for installed fonts Setting the default font (cond ((x-list-fonts \"Hack Nerd Font\") (add-to-list 'default-frame-alist '(font . \"Hack Nerd Font-12\"))) ;; ((x-list-fonts \"Segoe UI Emoji\") ;; (add-to-list 'default-frame-alist '(font . \"Segoe UI Emoji-12\"))) ) (defun renz/change-font-size (new-size) \u0026ldquo;Change the default font size to the given size.\u0026rdquo; (interactive \u0026ldquo;nNew font size: \u0026ldquo;) (set-face-attribute \u0026lsquo;default nil :height (* 10 new-size))) Theme With the introduction of modus-vivendi-tinted in Emacs 29, I really have no need for any external themes now. It is accessible, well optimized for org-mode and prog-mode, and distributed with vanilla Emacs. Hats off to Prot for these wonderful themes. (use-package emacs :custom (modus-themes-inhibit-reload nil) (modus-themes-subtle-line-numbers t) (modus-themes-syntax '(alt-syntax faint green-strings yellow-comments)) (modus-themes-diffs 'desaturated) ;; (modus-themes-hl-line 'intense) (modus-themes-deuteranopia nil) (modus-themes-bold-constructs t) (modus-themes-italic-constructs t) ;; (modus-themes-mode-line 'borderless) (modus-themes-fringes 'subtle) (modus-themes-org-blocks 'gray-background) (modus-themes-vivendi-color-overrides '((bg-main . \"#010101\"))) :bind (\"\u0026lt;f5\u0026gt;\" . modus-themes-toggle) :config (if (version\u0026lt; emacs-version \"29.0\") (load-theme 'leuven-dark) (load-theme 'modus-vivendi-tinted t))) Emacs' Built-in Settings My settings for base Emacs behavior. Assuming I ran with no plugins (ala emacs -Q), I would still set most of these by hand at one point or another. This section is designed for variables that modify Emacs and its editing behavior directly. Configuation for built-in tools, such as Dired, Tramp, and Tree-sitter are located under Tool configuration. Stop stupid bell This snippet has a special place in my heart, because it was the first two lines of elisp I wrote when first learning Emacs. It is the central kernel around which my ~/.emacs and later ~/.emacs.d/init.el grew. ;; Stop stupid bell (setq ring-bell-function 'ignore) The bell is really, really annoying. Start a server for emacsclient (server-start) Don't hang when visiting files with extremely long lines (global-so-long-mode t) Unicode Sometimes (especially on Windows), Emacs gets confused about what encoding to use. These settings try to prevent that confusion. (prefer-coding-system 'utf-8) (set-default-coding-systems 'utf-8) (set-terminal-coding-system 'utf-8) (set-keyboard-coding-system 'utf-8) (setq default-buffer-file-coding-system 'utf-8) (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)) Mode line It's easy for the mode line to get cluttered once things like Flymake and eglot kick in. When I was starting out, I used to have these two settings: (setq display-battery-mode t display-time-day-and-date t) (display-time) After a while I noticed that I'm almost never running Emacs in a full screen where I can't see the battery or date in the corner of my window manager, so they were just wasting mode line space. Nowadays I simply opt for column mode and a dimmed mode line in non-selected windows. (setq column-number-mode t mode-line-in-non-selected-windows t) Remember minibuffer history Found this on a System Crafters video. (setq history-length 25) (savehist-mode 1) Render ASCII color escape codes For files containing color escape codes, this provides a way to render the colors in-buffer. Provided by a helpful stackoverflow answer. (defun renz/display-ansi-colors () \"Render colors in a buffer that contains ASCII color escape codes.\" (interactive) (require 'ansi-color) (let ((inhibit-read-only t)) (ansi-color-apply-on-region (point-min) (point-max)))) Colored output in eshell and *compilation* In *compilation* mode, we just use the \"display colors\" function from above. Enable colors in the *compilation* buffer. (add-hook 'compilation-filter-hook #'renz/display-ansi-colors) For eshell, this is copy-pasted from a stack overflow question. (add-hook 'eshell-preoutput-filter-functions #'ansi-color-apply) xterm-color Soon, I'd like to swap out my hacks above for this more robust package: https://github.com/atomontage/xterm-color/tree/master Recent files menu This enables \"File -\u0026gt; Open Recent\" from the menu bar and using completing-read over the recentf-list. (recentf-mode t) (defun renz/find-recent-file () \u0026ldquo;Find a file that was recently visted using `completing-read\u0026rsquo;.\u0026rdquo; (interactive) (find-file (completing-read \u0026ldquo;Find recent file: \u0026quot; recentf-list nil t))) Fill-column Regardless of whether we're doing visual fill or hard fill, I like the default at around 80 characters, and I'll manually change it per buffer if I want something different (setq-default fill-column 80) Scroll bar I toggle this one on/off sometimes depending on how I feel and which OS I'm currently on. (scroll-bar-mode -1) By default, though, I prefer it to be off when I start Emacs. Window margins and fringe This hunk adds some space around all sides of each window so that we get a clear space between the edge of the screen and the fringe. (defun renz/modify-margins () \"Add some space around each window.\" (interactive) (modify-all-frames-parameters '((right-divider-width . 40) (internal-border-width . 40))) (dolist (face '(window-divider window-divider-first-pixel window-divider-last-pixel)) (face-spec-reset-face face) (set-face-foreground face (face-attribute 'default :background))) (set-face-background 'fringe (face-attribute 'default :background))) (renz/modify-margins) We also need to make sure this runs each time we change the ef-theme, otherwise the old background color will linger in the margins. (add-hook 'ef-themes-post-load-hook 'renz/modify-margins) Automatically visit symlink sources When navigating to a file that is a symlink, this automatically redirects us to the source file it's pointing to. (setq find-file-visit-truename t) (setq vc-follow-symlinks t) Indent with spaces by default For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of these favor spaces over tabs, so I prefer this as the default. (setq-default indent-tabs-mode nil) Generally, though, indentation behavior is set by major-mode functions, which may or may not use Emacs' built-in indentation functions. For instance, when trying to find the functions behind indentation in shell mode, I came across smie.el, whose introductory comments include this gem: OTOH we had to kill many chickens, read many coffee grounds, and practice untold numbers of black magic spells, to come up with the indentation code. Since then, some of that code has been beaten into submission, but the `smie-indent-keyword' function is still pretty obscure. Even the GNU manual speaks of it in the same way: Writing a good indentation function can be difficult and to a large extent it is still a black art. Many major mode authors will start by writing a simple indentation function that works for simple cases, for example by comparing with the indentation of the previous text line. For most programming languages that are not really line-based, this tends to scale very poorly: improving such a function to let it handle more diverse situations tends to become more and more difficult, resulting in the end with a large, complex, unmaintainable indentation function which nobody dares to touch. Enable horizontal scrolling with mouse From a helpful stackoverflow answer. (setq mouse-wheel-tilt-scroll t) Window management From a Mickey Petersen article, this causes switch-to-buffer to open the selected buffer in the current window rather than switching windows, assuming both are open in the current frame. This is more frequently the behavior I intend when I'm trying to get a window to display a specific buffer. (unless (version\u0026lt; emacs-version \"27.1\") (setq switch-to-buffer-obey-display-actions t)) Automatically update buffers when contents change on disk Without setting global-auto-revert-mode, we have to remember to issue a revert-buffer or revert-buffer-quick (C-x x g by default) in case a file changed. Over Tramp, we still have to manually revert files when they've changed on disk. (global-auto-revert-mode) Highlight the line point is on Add a faint background highlight to the line we're editing. (add-hook 'prog-mode-hook #'hl-line-mode) (add-hook 'text-mode-hook #'hl-line-mode) (add-hook 'org-mode-hook #'hl-line-mode) Always turn on flymake in prog mode (add-hook 'prog-mode-hook #'flymake-mode) Another, related mode is flyspell-prog-mode, which is just checks spelling in comments and strings. (add-hook 'prog-mode-hook #'flyspell-prog-mode) Automatically create matching parens in programming modes (add-hook 'prog-mode-hook (electric-pair-mode t)) (add-hook 'prog-mode-hook (show-paren-mode t)) Shorten yes/no prompts to y/n (setq use-short-answers t) Delete whitespace on save I would also like to have a good-looking display for trailing whitespace and leading tabs like in my Neovim setup, but it has proven challenging to just narrow down to those two faces. In the interim, I toggle M-x whitespace-mode to check for mixed tabs, spaces, and line endings. (add-hook 'before-save-hook 'delete-trailing-whitespace) Killing buffers with a running process Typically, Emacs will ask you to confirm before killing a buffer that has a running process, such as with run-python, a *shell* buffer, or a *compilation* buffer. (setq kill-buffer-query-functions (remq 'process-kill-buffer-query-function kill-buffer-query-functions)) Don't wrap lines I much prefer having long lines simply spill off to the right of the screen than having them wrap around onto the next line, except in the case where I'd like to see wrapped line content, like in one of the shell modes. (setq-default truncate-lines t) (add-hook 'eshell-mode-hook (lambda () (setq-local truncate-lines nil))) (add-hook 'shell-mode-hook (lambda () (setq-local truncate-lines nil))) Relative line numbers For programming and prose/writing modes. Unfortunately, line numbers are displayed in the text area of the buffer, but org-modern uses the fringe to display source blocks. There's no way to display them to the left of the fringe, so I'm careful about only turning on line numbers in modes that I think I'll benefit from it. It's been working pretty well in org-mode without the line numbers so far, since for each of the code blocks I can always use C-c ' to edit in prog-mode, where I do get line numbers. (defun renz/display-relative-lines () (setq display-line-numbers 'relative)) (add-hook \u0026lsquo;prog-mode-hook #\u0026lsquo;renz/display-relative-lines) (add-hook \u0026lsquo;yaml-mode-hook #\u0026lsquo;renz/display-relative-lines)\n(unless (display-graphic-p) (add-hook \u0026rsquo;text-mode-hook #\u0026lsquo;renz/display-relative-lines)) Delete region when we yank on top of it I just think that's a funny sentence. Normally when yanking text with an active region, the region will remain and the yanked text is just inserted at point. I prefer the modern word processor behavior of replacing the selected text with the yanked content. (delete-selection-mode t) Enable mouse in terminal/TTY (xterm-mouse-mode 1) Compilation As new text appears, the default behavior is for it to spill off the bottom, unless we manually scroll to the end of the buffer. Instead, I prefer the window to automatically scroll along with text as it appears, stopping at the first error that appears. (setq compilation-scroll-output 'first-error) Tool bar I usually leave the tool bar disabled (tool-bar-mode -1) The menu bar, on the other hand (menu-bar-mode), is very handy, and I only disable it on Windows, where it looks hideous if I'm running in dark mode. (when (renz/windowsp) (menu-bar-mode -1)) For newcomers to Emacs, I would strongly discourage disabling the menu bar, as it is the most straightforward way to discover Emacs' most useful features. Ignore risky .dir-locals.el From an Emacs stackexchange answer. (advice-add 'risky-local-variable-p :override #'ignore) Prefer rg over grep (use-package grep :config (when (executable-find \"rg\") (setq grep-program \"rg\") (grep-apply-setting 'grep-find-command '(\"rg -n -H --color always --no-heading -e '' $(git rev-parse --show-toplevel || pwd)\" . 27)))) If you're on Windows, this command assumes you're running pwsh version 7 or higher. Shorter file paths in grep/compilation buffers (use-package scf-mode :load-path \"site-lisp\" :hook (grep-mode . (lambda () (scf-mode 1)))) Confirm when exiting Emacs It's very annoying when I'm working and suddenly I meant to do C-c C-x, but instead hit C-x C-c. This helps prevent that. (setq confirm-kill-emacs 'yes-or-no-p) Smooth scrolling Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the \"jumpiness\" you see when scrolling past images. (if (version\u0026lt; emacs-version \"29.0\") (pixel-scroll-mode) (pixel-scroll-precision-mode 1) (setq pixel-scroll-precision-large-scroll-height 35.0)) Spellchecking On macOS and linux I typically use aspell, given how easy it is to install. For Windows, I'll set up hunspell, which I install from the hunspell-binary repo. After installing the hunspell binary, it requires installing a dictionary and affix file to the installation directory: curl -o en_US.dic https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.dic?id=a4473e06b56bfe35187e302754f6baaa8d75e54f curl -o en_US.aff https://cgit.freedesktop.org/libreoffice/dictionaries/plain/en/en_US.aff?id=a4473e06b56bfe35187e302754f6baaa8d75e54f Then move these files to wherever hunspell is. For instance, C:\\Program Files\\Hunspell. (cond ((executable-find \"aspell\") (setq ispell-program-name \"aspell\" ispell-really-aspell t)) ((executable-find \"hunspell\") (setq ispell-program-name \"hunspell\" ispell-really-hunspell t))) Backup and auto-save files Keep all backup files in a temporary folder. At the moment I have some \"file not found\" errors popping up during auto-save on Windows. Once I debug that, I'll uncomment the second part. (setq backup-directory-alist '((\".\" . \"~/.emacs.d/backups/\")) ;; auto-save-file-name-transforms '((\".\" ,temporary-file-directory t)) ) Enable narrow-to-region narrow-to-region restricts editing in this buffer to the current region. The rest of the text becomes temporarily invisible and untouchable but is not deleted; if you save the buffer in a file, the invisible text is included in the file. C-x n w makes all visible again. (put 'narrow-to-region 'disabled nil) Enable up/downcase-region Allows us to convert entire regions to upper or lower case. (put 'upcase-region 'disabled nil) (put 'downcase-region 'disabled nil) Mark rings and registers: bigger, faster, stronger 16 is the default number of marks stored on the global and local mark rings is 16. I hop around much more than 16 times as I'm editing, so I expand this a bit. (setq-default mark-ring-max 32) (setq global-mark-ring-max 32) Another handy shortcut is continually popping marks by repeated C-\u0026lt;SPC\u0026gt; after the first C-u C-\u0026lt;SPC\u0026gt; through the set-mark-command-repeat-pop setting. (setq set-mark-command-repeat-pop t) And, because I always forget it, to pop a global mark you use C-x C-\u0026lt;SPC\u0026gt;. The local version, C-u C-\u0026lt;SPC\u0026gt; will only pop marks from the current buffer. So the C-x C-\u0026lt;SPC\u0026gt; version is much closer to how Vim's jump stack works. A handy \"bookmark\" system (aside from actual bookmarks) is to set common buffers and files to registers pre-emptively. (set-register ?S '(buffer . \"*scratch*\")) (set-register ?I `(file . ,(expand-file-name \"README.org\" user-emacs-directory))) (set-register ?B `(file . \"~/.bashrc\")) The default keybinding for jump-to-register is C-x r j R, where R is the name of the register. My own personal convention here is to use lower-case letter for interactive session bookmarks that will be lost between sessions, and upper-case letters for ones I've set permanently here. Before I was aware of this feature I had created my own jump-to-X style functions, but this is much better! You even get a handy pop-up if you wait a second after typing C-x r j to see all the available registers. Keybindings Expanded/better defaults These convenient chords allow for fast text replacement by holding C-M- and rapidly typing k and h in succession. (global-set-key (kbd \"C-M-\u0026lt;backspace\u0026gt;\") 'backward-kill-sexp) (global-set-key (kbd \"C-M-h\") 'backward-kill-sexp) The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on the GUI was frustrating as hell, so now I use C-x C-z if I really want to suspend the frame. (global-set-key (kbd \"C-z\") #'zap-up-to-char) Hippie-expand is purported to be a better version of dabbrev, but I rather like the default behavior of dabbrev. (global-set-key [remap dabbrev-expand] 'hippie-expand) ibuffer is a strictly superior, built-in version of its counterpart. (global-set-key [remap list-buffers] 'ibuffer) The most common situation where I'm running flymake would be for spelling in prose, or diagnostics from a language server. In either case, I like having next/previous on easy to reach chords. (use-package flymake :bind (:map flymake-mode-map (\"C-c n\" . flymake-goto-next-error) (\"C-c p\" . flymake-goto-prev-error))) Overriding defaults Some default bindings aren't useful for me, so I bind them to actions I take more frequently. (global-set-key (kbd \"C-x C-p\") 'previous-buffer) ; Overrides `mark-page' (global-set-key (kbd \"C-x C-n\") 'next-buffer) ; Overrides `set-goal-column' C-c bindings Emacs has some standards about where user-configured keys should go; C-c \u0026lt;letter\u0026gt; is always free for users. It may seem like overkill how I set a header for each possible C-c combination, but it's incredibly handy when I want to jump directly to one of these headings while in another buffer. See e.g. org-goto, which allows me to narrow in on a particular key I'd like to bind by leveraging completing-read. If a C-c \u0026lt;letter\u0026gt; combination is missing as a header, then I'm probably using it in a :bind statement with use-package somewhere else. C-c b build / compile (global-set-key (kbd \"C-c b\") #'compile) (global-set-key (kbd \"C-c B\") #'recompile) C-c c Calendar (global-set-key (kbd \"C-c c\") #'calendar) C-c d Navigating to symbols using old-school TAGS Before the whole language server revolution, we had TAGS files for caching the location of symbol definitions. etags comes with Emacs, and combining some clever use of find with it can render a pretty good symbol search experience. To generate the TAGS file, I usually have a TAGS recipe that looks something similar to this in each project's Makefile: find . -type d -name \".venv\" -prune \\ -o -type d -name \".ipynb_checkpoints\" -prune \\ -o -type d -name \".node_modules\" -prune \\ -o -type d -name \"elpa\" -prune \\ -o -type f -name \"*.py\" -print \\ -o -type f -name \"*.sql\" -print \\ -o -type f -name \"*.el\" -print \\ | etags - Then, M-x project-compile RET make TAGS builds a tags table. At which point, I can use tags-completion-table to build a list of symbols I can navigate to with completion, with just a little help from xref-find-definitions. (defun renz/find-tag () \"Use `completing-read' to navigate to a tag.\" (interactive) (require 'etags) (tags-completion-table) (xref-find-definitions (completing-read \"Find tag: \" tags-completion-table))) (global-set-key (kbd \u0026ldquo;C-c d\u0026rdquo;) #\u0026lsquo;renz/find-tag) C-c f find file at point (ffap) (global-set-key (kbd \"C-c f\") #'ffap) C-c i browse url of buffer (global-set-key (kbd \"C-c i\") #'browse-url-of-buffer) C-c j Toggle window split Toggling windows from vertical to horizontal splits and vice-versa. (defun toggle-window-split () \"Switch between horizontal and vertical split window layout.\" (interactive) (if (= (count-windows) 2) (let* ((this-win-buffer (window-buffer)) (next-win-buffer (window-buffer (next-window))) (this-win-edges (window-edges (selected-window))) (next-win-edges (window-edges (next-window))) (this-win-2nd (not (and (\u0026lt;= (car this-win-edges) (car next-win-edges)) (\u0026lt;= (cadr this-win-edges) (cadr next-win-edges))))) (splitter (if (= (car this-win-edges) (car (window-edges (next-window)))) 'split-window-horizontally 'split-window-vertically))) (delete-other-windows) (let ((first-win (selected-window))) (funcall splitter) (if this-win-2nd (other-window 1)) (set-window-buffer (selected-window) this-win-buffer) (set-window-buffer (next-window) next-win-buffer) (select-window first-win) (if this-win-2nd (other-window 1)))))) (global-set-key (kbd \u0026ldquo;C-c j\u0026rdquo;) #\u0026rsquo;toggle-window-split) C-c k kill all but one space (global-set-key (kbd \"C-c k\") #'just-one-space) C-c q replace regexp (global-set-key (kbd \"C-c q\") #'replace-regexp) C-c r find recent files (global-set-key (kbd \"C-c r\") #'renz/find-recent-file) C-c s shell (global-set-key (kbd \"C-c s s\") #'shell) (global-set-key (kbd \"C-c s e\") #'eshell) (global-set-key (kbd \"C-c s t\") #'term) C-c u open URL at point in browser (global-set-key (kbd \"C-c u\") #'browse-url-at-point) C-c v faster git-commit (defun renz/git-commit () (interactive) (vc-next-action nil) (log-edit-show-diff) (other-window 1)) (global-set-key (kbd \u0026ldquo;C-c v\u0026rdquo;) #\u0026lsquo;renz/git-commit) C-c w whitespace mode (global-set-key (kbd \"C-c w\") #'whitespace-mode) C-c Other bindings (global-set-key (kbd \"C-c \u0026lt;DEL\u0026gt;\") #'backward-kill-sexp) ;; TTY-frindly (global-set-key (kbd \"C-c \u0026lt;SPC\u0026gt;\") #'mark-sexp) ;; TTY-friendly F5-F9 Like the C-c \u0026lt;letter\u0026gt; bindings, these are reserved for users. In practice, even though there are few of these keys, I tend to forget which is which. So I wind up using things bound to my C-c keymaps instead. The C-c kyes from a more natural, nested language in my head, so it feels more like I'm \"speaking Emacs\" that way. Super bindings (global-set-key (kbd \"s-p\") #'project-switch-project) Text Completion Emacs offers incredible depth and freedom when configuring methods to automatically complete text. There are actually two things that \"autocompletion\" can refer to in Emacs: Minibuffer completion Completion at point Emacs on its own does not have a nice pop-up-menu like Vim for completing text at point. For both the minibuffer and completion-at-point it uses a special buffer called *Completions*, from which we can see (and optionally select) a completion from potential candidates. Before we get to tweak those settings, though, we first need to oil the engine with an enhanced completion style Completion style For both the minibuffer and completion-at-point, I use the same completion style. Completion style is the method of assigning completion candidates to a given input string. flex is the built-in \"fuzzy\" completion style, familiar to us from symbol completion in IDEs and VSCode's command palette. basic functions much like your default TAB-complete at a Bash shell. (setq completion-styles '(flex basic partial-completion emacs22)) Nicer Display and Behavior of *Completions* With the completion style set, we now have to configure the interface for displaying candidates as we type. First, I want candidates displayed as a single, vertical list. (setq completions-format 'one-column) Also, when using the built-in completion-at-point, the *Completions* buffer can sometimes take up the whole screen when there are a lot of candidates. (unless (version\u0026lt; emacs-version \"29.0\") (setq completions-max-height 15)) Some time ago, Prot wrote a package called MCT (Minibuffer and Completions in Tandem) that enhanced the default minibuffer and *Completions* buffer behavior to act more like what we expect of a modern editor's auto-complete. He discontinued development of that project once it became clear that Emacs 29 was going to include similar behavior as a configurable option. These are the options in question. (unless (version\u0026lt; emacs-version \"29.0\") (setq completion-auto-help 'lazy completion-auto-select 'second-tab completion-show-help nil completions-sort nil completions-header-format nil)) Completion in the minibuffer and at point By default, Emacs uses M-TAB, or the equivalent C-M-i for completion-at-point. I'd much prefer to use the easier and more intuitive TAB. (setq tab-always-indent 'complete) Something I might try is to use icomplete along with icomplete-in-buffer to get something like a little window that updates as I type. It seems a little wonky, since TAB-completion will still cause the \u0026lowast;Completions\u0026lowast; buffer to pop up, even while Icomplete is active, unless we set completion-auto-help to lazy; and even then it will still come up on the second TAB press. (setq icomplete-in-buffer t) (setq icomplete-prospects-height 10) (icomplete-vertical-mode t) In the case that we need to enter a new file name, but fido is still showing a completion candidate, you have to use C-d to refuse completion and take whatever is currently in the prompt. For instance, if we are editing a file hello.py, and then use C-x C-f hell.py, the minibuffer will complete hell.py into hello.py if we use RET, and will open a new buffer for hell.py if we use C-d. Language-specific major modes Shell (Bash, sh, \u0026#x2026;) (defun renz/sh-indentation () ;; (setq indent-tabs-mode t) (setq tab-width 8)) (add-hook \u0026lsquo;sh-mode-hook #\u0026lsquo;renz/sh-indentation) (add-hook \u0026lsquo;bash-ts-mode-hook #\u0026lsquo;renz/sh-indentation) HTML This changes the behavior of a few commonly-used tags in web pages that I write. (use-package sgml-mode :defer t :config (let* ((p-tag-old (assoc \"p\" html-tag-alist)) ;; Close the \u0026lt;p\u0026gt; tag and open on a new line. (p-tag-new `(\"p\" \\n ,(cdr (cdr p-tag-old))))) (add-to-list 'html-tag-alist p-tag-new) ;; Close the \u0026lt;code\u0026gt; tag and stay inline. (add-to-list 'html-tag-alist '(\"code\")))) CSS (setq css-indent-offset 2) For validation, grab css-validator.jar and execute it with java: java -jar ~/.local/jars/css-validator.jar file:///home/me/my/site/index.html Org-mode (setq renz/org-home \"~/.emacs.d/org/\") org-mode provides org-babel-tangle-jump-to-org, which jumps back to an Org source file from within the tangled code. renz/org-babel-tangle-jump-to-src, defined below, does the opposite - given the Org source file and point inside a src block, it jumps to the location of the tangled code. Provided by a helpful stackoverflow answer. (defun renz/org-babel-tangle-jump-to-src () \"The opposite of `org-babel-tangle-jump-to-org'. Jumps to an Org src block from tangled code.\" (interactive) (if (org-in-block-p) (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block))) (tangle (car header)) (lang (caadr header)) (buffer (nth 2 (cadr header))) (org-id (nth 3 (cadr header))) (source-name (nth 4 (cadr header))) (search-comment (org-fill-template org-babel-tangle-comment-format-beg `((\"link\" . ,org-id) (\"source-name\" . ,source-name)))) (file (expand-file-name (org-babel-effective-tangled-filename buffer lang tangle)))) (if (not (file-exists-p file)) (message \"File does not exist. 'org-babel-tangle' first to create file.\") (find-file file) (beginning-of-buffer) (search-forward search-comment))) (message \"Cannot jump to tangled file because point is not at org src block.\"))) Now we configure org-mode itself. For a while I was trying (setq org-startup-indented t) to get indentation under each header, but this was interfering with the beautification features from org-modern. Preferring the latter over the former, I've removed the org-startup-indented call. (defun renz/list-files-with-absolute-path (directory) \"Return a list of files in DIRECTORY with their absolute paths.\" (cl-remove-if-not #'file-regular-p (directory-files directory t \".*\\.org$\"))) (use-package org :hook ((org-mode . (lambda () (progn (add-hook \u0026lsquo;after-save-hook #\u0026lsquo;org-babel-tangle :append :local) (add-hook \u0026lsquo;org-babel-after-execute-hook #\u0026lsquo;renz/display-ansi-colors) (setq indent-tabs-mode nil)))))\n:init (defun renz/jump-org () \u0026ldquo;Prompt for an org file in my emacs directory, then go there.\u0026rdquo; (interactive) (renz/\u0026ndash;jump-section renz/org-home \u0026ldquo;Org files: \u0026quot; \u0026ldquo;.*.org$\u0026rdquo;))\n:bind ((\u0026ldquo;C-c o a\u0026rdquo; . org-agenda) (\u0026ldquo;C-c o b d\u0026rdquo; . org-babel-detangle) (\u0026ldquo;C-c o b o\u0026rdquo; . org-babel-tangle-jump-to-org) (\u0026ldquo;C-c o b s\u0026rdquo; . renz/org-babel-tangle-jump-to-src) (\u0026ldquo;C-c o k\u0026rdquo; . org-babel-remove-result) (\u0026ldquo;C-c o o\u0026rdquo; . renz/jump-org) (\u0026ldquo;C-c o y\u0026rdquo; . ox-clip-image-to-clipboard))\n:custom (org-image-actual-width nil \u0026ldquo;Enable resizing of images\u0026rdquo;) (org-agenda-files (renz/list-files-with-absolute-path renz/org-home) \u0026ldquo;Sources for Org agenda view\u0026rdquo;) (org-html-htmlize-output-type nil \u0026ldquo;See C-h f org-html-htmlize-output-type\u0026rdquo;) (org-confirm-babel-evaluate nil \u0026ldquo;Don\u0026rsquo;t ask for confirmation when executing src blocks\u0026rdquo;) (org-goto-interface \u0026lsquo;outline-path-completion \u0026ldquo;Use completing-read for org-goto (C-c C-j, nicer than imenu)\u0026rdquo;) (org-outline-path-complete-in-steps nil \u0026ldquo;Flatten the outline path, instead of completing hierarchically\u0026rdquo;)\n:config (add-to-list \u0026lsquo;org-modules \u0026lsquo;org-tempo) (org-babel-do-load-languages \u0026lsquo;org-babel-load-languages \u0026lsquo;((emacs-lisp . t) (python . t) (sql . t) (shell . t) (R . t) ;; (fortran . t) ;; (julia . t) ;; (jupyter . t) ;; (scheme . t) ;; (haskell . t) (lisp . t) ;; (clojure . t) ;; (C . t) ;; (org . t) ;; (gnuplot . t) ;; (awk . t) ;; (latex . t) ))) Converting JSON to Org Tables I use a small external dependency for this: (use-package json-to-org-table :load-path \"site-lisp/json-to-org-table/\" :after org) SQL DDL is SQL (add-to-list 'auto-mode-alist '(\"\\\\.ddl\\\\'\" . sql-mode)) (add-to-list 'auto-mode-alist '(\"\\\\.bql\\\\'\" . sql-mode)) Indentation Vanilla Emacs doesn't offer a lot (read: nothing) in terms of making SQL code pretty. I tend to format SQL like this: SELECT whatever, thing FROM wherever AS w JOIN the_other AS t ON w.id = t.id GROUP BY whatever The configuration of sql-indent below achieves that nicely when using RET and TAB for formatting. (defun renz/sql-mode-hook () (setq tab-width 4)) (defvar renz/sql-indentation-offsets-alist \u0026lsquo;((syntax-error sqlind-report-sytax-error) (in-string sqlind-report-runaway-string) (comment-continuation sqlind-indent-comment-continuation) (comment-start sqlind-indent-comment-start) (toplevel 0) (in-block +) (in-begin-block +) (block-start 0) (block-end 0) (declare-statement +) (package ++) (package-body 0) (create-statement +) (defun-start +) (labeled-statement-start 0) (statement-continuation +) (nested-statement-open sqlind-use-anchor-indentation +) (nested-statement-continuation sqlind-use-previous-line-indentation) (nested-statement-close sqlind-use-anchor-indentation) (with-clause sqlind-use-anchor-indentation) (with-clause-cte +) (with-clause-cte-cont ++) (case-clause 0) (case-clause-item sqlind-use-anchor-indentation +) (case-clause-item-cont sqlind-right-justify-clause) (select-clause 0) (select-column sqlind-indent-select-column) (select-column-continuation sqlind-indent-select-column +) (select-join-condition ++) (select-table sqlind-indent-select-table) (select-table-continuation sqlind-indent-select-table +) (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (insert-clause 0) (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (delete-clause 0) (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (update-clause 0) (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator)))\n(defun renz/sql-indentation-offsets () (setq sqlind-indentation-offsets-alist renz/sql-indentation-offsets-alist) (setq sqlind-basic-offset 4))\n(use-package sql-indent :hook (sqlind-minor-mode . renz/sql-indentation-offsets))\n(use-package sql-mode :hook ((sql-mode . renz/sql-mode-hook) (sql-mode . sqlup-mode) (sql-mode . sqlind-minor-mode))) Interactive hive2 mode This \"hive2\" package came from the days where I was working on an on-prem system that used hive2 as the main command-line interface to Hive. I don't use this much now, but it's a good reference for implementing a plug-in to a new interactive SQL CLI. (use-package hive2 :load-path \"site-lisp/\" :demand t :mode (\"\\\\.hql\" . sql-mode)) Interactive bq shell The SQL interactive commands are looking for a single executable file, so let's set that up somewhere common, like ~/.local/bin/bq-shell. #!/usr/bin/env sh bq shell \"$@\" Also, we don't want to use \"legacy SQL\" in our queries, which requires us to configure the bq query statically in a ~/.bigqueryrc file, according to the Google issue tracker. [query] --use_legacy_sql=false Then enable the BQ product. (use-package bq :load-path \"site-lisp\" :demand t) BigQuery sql Blocks in Org-Babel Advising org-babel-execute:sql in this way allows me to use #+begin_src sql :engine bq :results raw blocks in org-babel and execute them with C-c C-c. More commonly, though, I set #+PROPERTY: header-args:sql :engine bq :results raw at the top of the document so that I can just mark a src block as sql and be done with it. (defun org-babel-execute:bq (orig-fun body params) (if (string-equal-ignore-case (cdr (assq :engine params)) \"bq\") (json-to-org-table-parse-json-string (org-babel-execute:shell (concat \"bq query --format=json --nouse_legacy_sql '\" body \"'\") params)) (org-babel-execute:sql body params))) (advice-add \u0026lsquo;org-babel-execute:sql :around #\u0026lsquo;org-babel-execute:bq) This also typically requires #+OPTIONS: ^:nil at the top of the Org document to stop underscores from messing up how column names are displayed. TODO BigQuery exception markers When running BigQuery from a *compilation* buffer, it would be nice if I could get error markers to jump directly to the issue. Python (add-to-list 'auto-mode-alist '(\"Pipfile\" . toml-ts-mode)) Pyright error links in *compilation* The M-x compile feature does not recognize or parse pyright error messages out of the box, so I add that support myself. Here's an example error message: /home/robb/tmp/errors.py/ /home/robb/tmp/errors.py:1:1 - error: \"foo\" is not defined (reportUndefinedVariable) /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression) /home/robb/tmp/errors.py:4:12 - error: Operator \"+\" not supported for types \"str\" and \"Literal[1]\" Operator \"+\" not supported for types \"str\" and \"Literal[1]\" (reportGeneralTypeIssues) 2 errors, 1 warning, 0 informations To get the basic M-g M-n and M-g M-p navigation working, we just need a regex to parse file name, line, and column number. (with-eval-after-load 'compile (add-to-list 'compilation-error-regexp-alist-alist '(pyright \"^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\" 1 2 3)) (add-to-list 'compilation-error-regexp-alist 'pyright)) It would be nice if we could also capture the \\\\(error\\\\|warning\\\\) part as \"KIND\", but I'm struggling to get it working. Python check with \"ruff\" Another nice vanilla feature of python-mode is M-x python-check, which runs a pre-specified linter. Setting that to mypy or pyright if either of those programs exist is a small time saver. (use-package python :config (require 'eglot) (setq python-check-command \"ruff\") (add-hook 'python-mode-hook #'flymake-mode) (add-hook 'python-ts-mode-hook #'flymake-mode) ;; (add-to-list 'eglot-server-programs '((python-mode python-ts-mode) \"ruff-lsp\")) ) Fix Microsoft Windows Issues At one point, I ran into something similar to this elpy issue on Windows. The culprit was \"App Execution Aliases\" with python and python3 redirecting to the windows store. Using this fixed it: winkey -\u0026gt; Manage app execution aliases -\u0026gt; uncheck python and python3 Also on Windows - a pip install of pyreadline3 is required to make tab-completion work at all. It provides the readline import symbol. Make check command and virtualenv root safe for .dir-locals.el Virtualenvs require .dir-locals.el to have something like: ((python-mode . ((python-shell-virtualenv-root . \"/path/to/my/.venv\")))) However, this only operates on `run-python' shells. Also, for projects, we need to make sure that setting the virtualenv root is marked as safe. (put 'python-check-command 'safe-local-variable #'stringp) (put 'python-shell-virtualenv-root 'safe-local-variable #'stringp) (put 'pyvenv-default-virtual-env-name 'safe-local-variable #'stringp) Emacs Jupyter? Eventually, I would like to try the emacs-jupyter package to interface with Jupyter kernels from org-mode. pyrightconfig.json The most consistent way to get eglot to properly configure the python virtual environment with pyright is to have a static file at the root of the project, called pyrightconfig.json. I wrote a short plugin that allows me to select a directory using completing-read and have Emacs write the content of pyrightconfig.json based on what I selected, in the appropriate directory. (use-package pyrightconfig :after (python)) Configuring pyright this way rather than \"activating\" an environment through Emacs (ala pythonic-activate or similar) means we can be running the language server in more than one project at a time, each pointing to its respective virtual environment. Activating Virtual Environments Over Tramp (use-package tramp-venv :bind ((\"C-c t v a\" . tramp-venv-activate) (\"C-c t v d\" . tramp-venv-deactivate))) Pyvenv for virtual environments (use-package pyvenv :init (if (eq system-type 'darwin) (setenv \"WORKON_HOME\" \"~/micromamba/envs/\") (setenv \"WORKON_HOME\" \"~/.conda/envs/\")) :bind ((\"C-c p w\" . pyvenv-workon) (\"C-c p d\" . pyvenv-deactivate) (\"C-c p a\" . pyvenv-activate)) :config (pyvenv-mode)) Markdown When installing markdown through Anaconda, the executable is actually called markdown_py. In case markdown isn't found, use that instead. (when (and (not (executable-find \"markdown\")) (executable-find \"markdown_py\")) (setq markdown-command \"markdown_py\")) Some folks like to write markdown without hard line breaks. When viewing those documents, I can use M-x renz/md-hook to view it as if there were line breaks in it. (defun renz/md-hook () \"View buffer in visual fill mode with 80 character width.\" (interactive) (visual-fill-column-mode) (setq-local fill-column 80)) I make a lot of spelling mistakes as I type\u0026#x2026; (add-hook 'markdown-mode-hook 'flyspell-mode) (add-hook 'markdown-mode-hook 'auto-fill-mode) And I like to see language syntax highlighting within code fences. (setq markdown-fontify-code-blocks-natively t) Missing auto-modes These really should already be in auto-mode-alist, but aren't for some reason. (add-to-list 'auto-mode-alist '(\"\\\\.rs\\\\'\" . rust-ts-mode)) (add-to-list 'auto-mode-alist '(\"\\\\.go\\\\'\" . go-ts-mode)) (add-to-list 'auto-mode-alist '(\"\\\\.ts\\\\'\" . typescript-ts-mode)) (add-to-list 'auto-mode-alist '(\"\\\\.dockerfile\\\\'\" . dockerfile-ts-mode)) csv-mode Handy for viewing data quickly. (use-package csv-mode :mode \"\\\\.csv\\\\'\") Tool configuration These are tweaks for self-contained tooling, such as third party packages or built-in packages that have a well-defined scope and namespace. eldoc I find it very distracting when eldoc suddenly pops up and consumes a large part of the screen for docstrings in python. (setq eldoc-echo-area-use-multiline-p nil) imenu (use-package imenu :config (setq imenu-auto-rescan t org-imenu-depth 3)) dabbrev (use-package dabbrev :custom (dabbrev-ignored-buffer-regexps '(\"\\\\.\\\\(?:pdf\\\\|jpe?g\\\\|png\\\\)\\\\'\"))) dired By default, dired uses bytes instead of \"K\", \"Mb\", or \"G\" for file sizes. I also have it hide the mode, size, and owner of each file by default. (use-package dired :hook (dired-mode . dired-hide-details-mode) :config (setq dired-listing-switches \"-alFh\") (setq dired-dwim-target t)) Also enabled above is Do-What-I-Mean (DWIM) copying. This is for when two dired windows are open, and we want to copy something from one location to the other. By enabling dired-dwim-target, it auto-populates the minibuffer with the other dired window's path when issuing a copy command with C. Visual fill column For visual lines, this adds line breaks at the fill-column value. Especially useful for prose that is meant to be copied to other mediums, such as email or word. (use-package visual-fill-column :config (add-hook 'visual-line-mode-hook #'visual-fill-column-mode)) eww - search engine and browser Ecosia requires JavaScript, unfortunately. (use-package eww :config (setq eww-search-prefix \"https://duckduckgo.com/html/?q=\")) Reloading Emacs Often used when changing up my init.el. (use-package restart-emacs :bind (\"C-c x r\" . restart-emacs)) Language Server Protocol (LSP) with eglot As of version 29, eglot (Emacs polyGLOT) is bundled with Emacs. It provides Emacs with the client side configuration for the language server protocol. (use-package eglot :bind ((\"C-c l c\" . eglot-reconnect) (\"C-c l d\" . flymake-show-buffer-diagnostics) (\"C-c l f f\" . eglot-format) (\"C-c l f b\" . eglot-format-buffer) (\"C-c l l\" . eglot) (\"C-c l r n\" . eglot-rename) (\"C-c l s\" . eglot-shutdown))) To have eglot always start up for a python buffer, we would tangle this line into init.el. However, this can cause a significant loading delay over Tramp, and I would prefer snappy, simple access with LSP provided on an as-needed basis. (add-hook 'python-mode-hook 'eglot-ensure) Side show: semantic-mode For a while, it looks like Emacs was trying out something called semantic-mode, which looks a lot like a precursor to what we now know as the Language Server Protocol. Enabling it was done through adding the semantic-mode hook to your language's major mode hook: (add-hook 'python-mode-hook 'semantic-mode) TreeSitter About TreeSitter and its Load Paths Emacs 29 added native TreeSitter support. TreeSitter is a new way of incrementally parsing source code that offers superior navigation and syntax highlighting. To fully realize this benefit, however, it requires that we install tree-sitter grammars independently from Emacs. Right now, I'm using casouri's modules, which I build and install under ~/.emacs.d/tree-sitter, if they don't already exist under /usr/local/lib/ or ~/.local/lib. In case of the latter, I just add extra paths to treesit-extra-load-path explicitly. (when (boundp 'treesit-extra-load-path) (add-to-list 'treesit-extra-load-path \"/usr/local/lib/\") (add-to-list 'treesit-extra-load-path \"~/.local/lib/\")) For the full instructions, the commit history of adding the tree-sitter modules to Emacs included a full guide, which can be read in Info under \"Parsing Program Source\". C-h i d m elisp RET g Parsing Program Source RET Enabling TreeSitter is done on a per-language basis to override the default major mode with the corresponding TreeSitter version. Automatically Using TreeSitter Modes I've posted this to GitHub and MELPA as treesit-auto. (use-package treesit-auto :custom (treesit-auto-install 'prompt) :config (global-treesit-auto-mode)) Before it was published to MELPA, I used a git subtree to manage the plugin. This is a pretty useful technique, so I keep these two one-liners around in case I need to reference or copy them. To get a copy of something as a subtree, I use this: git subtree add -P site-lisp/treesit-auto git@github.com:renzmann/treesit-auto main --squash Fetching updates is a similar command. git subtree pull -P site-lisp/treesit-auto git@github.com:renzmann/treesit-auto main --squash Ooo, aaah, shiny colors I like to program \"in Skittles\": (setq-default treesit-font-lock-level 3) Tramp Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on a remote machine, and edit them locally. This is great for simple changes or quickly testing out some Python on a VM somewhere. It isn't as snappy as using the TTY version or an X-forwarded Emacs from the server directly, so if I can set up Emacs remotely, I usually do. When I don't want to or don't have the time, Tramp is a godsend. There are, however, many foibles to guard against, particularly with how interacts with version control and .dir-locals. The Tramp manual (distributed with Emacs) recommends adjusting these for some speed improvements: (use-package tramp :defer t :config (setq vc-handled-backends '(Git) file-name-inhibit-locks t tramp-inline-compress-start-size 1000 tramp-copy-size-limit 10000 tramp-verbose 1) (add-to-list 'tramp-remote-path 'tramp-own-remote-path)) eglot is actively working on an issue related to timers causing a \"Forbidden reentrant call of Tramp\" message and freezing. In the meantime, this setting was recommended. (setq tramp-use-ssh-controlmaster-options nil) For some time I was having a lot of trouble with prohibitive slowness over Tramp, and after careful scrutiny of the logs on (I believe) tramp-verbose 6, I found out that enabling remote dir-locals was causing a huge bottleneck. On every operation it would trace up the filesystem tree back to the root directory, scanning for a .dir-locals file. Since some of the drives were network-mounted, this caused thousands of network calls per file operation, obviously slowing things down a lot. Because of this, I've opted to simply disable .dir-locals over Tramp entirely, since I don't really use it much, if at all. ;; (setq enable-remote-dir-locals t) Disabling VC does seem to speed things up a little, but it's not an acceptable thing to put in, since I so frequently use VC over tramp. Fully disabling VC would include this snippet: (remove-hook 'find-file-hook 'vc-find-file-hook) (setq vc-ignore-dir-regexp (format \u0026ldquo;\\(%s\\)\\|\\(%s\\)\u0026rdquo; vc-ignore-dir-regexp tramp-file-name-regexp)) Additionally, these came up as other potential options from the doom-emacs issues, which I do not currently include. (setq tramp-default-method \"scp\") (setq projectile--mode-line \"Projectile\") I often need to set these in ~/.ssh/config for TRAMP to speed up Host * ControlMaster auto ControlPath ~/.ssh/master-%h:%p ControlPersist 10m ForwardAgent yes ServerAliveInterval 60 Shell commands The Async command buffer's default behavior is to print ^M characters (the carriage return) instead of actually clearing text. This is problematic for spinners and progress bars, so I have a little hack to work around that. (defun renz/async-shell-command-filter-hook () \"Filter async shell command output via `comint-output-filter'.\" (when (equal (buffer-name (current-buffer)) \"*Async Shell Command*\") ;; When `comint-output-filter' is non-nil, the carriage return characters ^M ;; are displayed (setq-local comint-inhibit-carriage-motion nil) (when-let ((proc (get-buffer-process (current-buffer)))) ;; Attempting a solution found here: ;; https://gnu.emacs.help.narkive.com/2PEYGWfM/m-chars-in-async-command-output (set-process-filter proc 'comint-output-filter)))) (add-hook \u0026lsquo;shell-mode-hook #\u0026lsquo;renz/async-shell-command-filter-hook) There might be a better way, but this mostly works for now. Footer Thank you for reading 'till the end or for being interested on how to end an Emacs package. So that's it, let's gracefully finish tangling everything: (provide 'init.el) ;;; init.el ends here Author: Robb Enzmann\nCreated: 2023-10-26 Thu 16:48\nValidate\n","date":"1 January 0001","permalink":"/emacsd/","section":"","summary":"\u003c?xml version=\"","title":"My Literate .emacs.d"}]