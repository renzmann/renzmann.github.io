[{"content":"I\u0026rsquo;ve got a (relatively) stable version of my Emacs configuration as a literate document now. It\u0026rsquo;s easy to read either on my GitHub or my website. The website version may lag behind my GitHub verison a bit, but they should be pretty close. Many thanks to the maintainers of ox-hugo for making it possible.\n","date":"21 November 2022","permalink":"/posts/emacs-literate-announcement/","section":"Posts","summary":"I\u0026rsquo;ve got a (relatively) stable version of my Emacs configuration as a literate document now.","title":"Moving My Emacs Configuration to a Literate Programming Document"},{"content":"Motivation # My most reliable setup for developing Python projects on remote hosts with LSP support so far has been with eglot and pyright. I\u0026rsquo;ve also tried lsp-mode with pyright, and both of lsp-mode and eglot with the python-lsp-server, however I\u0026rsquo;ve landed on eglot + pyright for a few reasons:\neglot requires zero configuration to work over Tramp, unlike lsp-mode. Fewest number of Tramp hangs. This could just be a symptom of my particular setup, though. eglot will have built-in support in future Emacs versions. This may or may not be worth a damn to other Emacs users. pyright has been strictly faster at error checking and diagnostic updates as compared to python-language-server in the machines I\u0026rsquo;m using. One hiccup remained though: pyright is typically a system or user installation, not something you install per virtual environment. Getting pyright to see the virtual environment of my choosing , and correctly report which dependencies are installed was a bit of a hassle, but I think my favorite solution so far has been to configure the virtual environment through the pyrightconfig.json file at the root of my project, and just have this file ignored by git. Typically, pyrightconfig.json looks like this:\n{ \u0026#34;venvPath\u0026#34;: \u0026#34;/absolute/path/to/dir/\u0026#34;, \u0026#34;venv\u0026#34;: \u0026#34;.venv\u0026#34; } I\u0026rsquo;m pretty happy with the other default configurations for pyright, so I leave those be, and just configure the virtual environment path this way. What was annoying me, though, is that I\u0026rsquo;d need to write out this absolute path for each machine I clone a project into, since relative paths and shortcuts using ~ aren\u0026rsquo;t supported. Much better if we can just have Emacs do it for us.\nIn the spirit of other Emacs/Python tools like pythonic and pyvenv for activating virtual environments, I wanted something that would just prompt for a directory using completing-read, and then populate the contents of pyrightconfig.json automatically based on my selection.\nGetting Functions That Write pyrightconfig.json # Edit 2022-11-20: Thanks to Mickey Petersen of mastering emacs for pointing out that json-encode exists. I originally had my own function pyrightconfig--json-contents here, but I\u0026rsquo;ve modified the function below to use this built-in version instead.\nWe really just need to do three things:\nPrompt for a directory that houses a Python virtual environment Break the result into an absolute parent path + base name, cleaning any Tramp prefix in the process Write the contents of pyrightconfig--json-contents using the previous result to a file in the version control root. It\u0026rsquo;s worth mentioning that we must put this file in the VC root, otherwise eglot just won\u0026rsquo;t pick it up. For my purposes, the VC system will always be git, so I\u0026rsquo;m going to make an assumption here and use vc-git-root instead of something more generic.\n(defun pyrightconfig-write (virtualenv) (interactive \u0026#34;DEnv: \u0026#34;) (let* (;; file-truename and tramp-file-local-name ensure that neither `~\u0026#39; nor ;; the Tramp prefix (e.g. \u0026#34;/ssh:my-host:\u0026#34;) wind up in the final ;; absolute directory path. (venv-dir (tramp-file-local-name (file-truename virtualenv))) ;; Given something like /path/to/.venv/, this strips off the trailing `/\u0026#39;. (venv-file-name (directory-file-name venv-dir)) ;; Naming convention for venvPath matches the field for ;; pyrightconfig.json. `file-name-directory\u0026#39; gets us the parent path ;; (one above .venv). (venvPath (file-name-directory venv-file-name)) ;; Grabs just the `.venv\u0026#39; off the end of the venv-file-name. (venv (file-name-base venv-file-name)) ;; Eglot demands that `pyrightconfig.json\u0026#39; is in the project root ;; folder. (base-dir (vc-git-root default-directory)) (out-file (expand-file-name \u0026#34;pyrightconfig.json\u0026#34; base-dir)) ;; Finally, get a string with the JSON payload. (out-contents (json-encode (list :venvPath venvPath :venv venv)))) ;; Emacs uses buffers for everything. This creates a temp buffer, inserts ;; the JSON payload, then flushes that content to final `pyrightconfig.json\u0026#39; ;; location (with-temp-file out-file (insert out-contents)))) Here\u0026rsquo;s a quick demo where I interactively choose a virtual environment directory, write the pyrightconfig.json, launch eglot, and use M-. to leverage the LSP\u0026rsquo;s jump-to-definition of a library, then show that the library we jumped to is indeed inside the virtual environment.\nFollow-ups # Feel free to take this package and modify it to suit your needs. Over time I might make some modifications to it:\nMaybe integrate with the variety of activate functions? So activating or setting a venv root for use with run-python automatically sets this. Support other VC roots than just git I\u0026rsquo;d love to get to VSCode-like intelligence about common venv locations and just prompt for those automatically through completing-read, instead of going through the pathing processing myself. Maybe that would become a function like pyrightconfig-suggest. ","date":"19 November 2022","permalink":"/posts/emacs-eglot-pyrightconfig/","section":"Posts","summary":"Motivation # My most reliable setup for developing Python projects on remote hosts with LSP support so far has been with eglot and pyright.","title":"Virtual Environments with Eglot, Tramp, and Pyright"},{"content":" Intro There are a lot of great guides on getting set up with Python in Emacs. Many of them have titles like \u0026#34;Emacs as a Python IDE\u0026#34; and start off by installing pyvenv for virtual environment management, eglot or lsp-mode for autocomplete/error checking, and maybe a host of other non-python things, like the helm or projectile packages.\nThis is not that guide.\nThis guide is for picky @#$%!s like me who want to exhaust every builtin capability before reaching out to external dependencies. Dependencies that, in turn, I will also have to learn and manage. Once I really understand what pyvenv is solving, then, and only then, will I add it to my package-selected-packages.\nDespite the excellent swath of materials both new and old on how to get IDE-like performance for Python out of Emacs, the collected materials on just running \u0026#34;vanilla extract\u0026#34; are fairly scant. The builtin python.el documentation is thorough and the keybindings easily discoverable, but not all documentation is collated into a single place. This guide started out as just my working notes as I began primarily working in emacs for my Python projects, and has grown into a workflow guide using nothing but the builtin capabilities of Emacs 28.1+. With that in mind, the examples and walkthroughs presented here are designed for emacs -q - i.e. starting emacs without any user configuration or your distribution\u0026#39;s default.el.\nEditing Let\u0026#39;s get our feet wet by bopping around some Python buffers first. I\u0026#39;m going to start up a new python file with C-x C-f and naming my file editing.py. I\u0026#39;m going to start by just adding a couple functions and a print statement, obfuscating the typical \u0026#34;Hello, world!\u0026#34; example a bit by introducing some functions and a \u0026#34;main\u0026#34; section right away.\n# These funtions are a little basic and silly right now, but we\u0026#39;ll use # them to showcase some Emacs features later on. def hello_text(): \u0026#34;\u0026#34;\u0026#34;Just gives back \u0026#39;Hello\u0026#39;\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Hello\u0026#34; def world_text(): \u0026#34;\u0026#34;\u0026#34;Just gives back \u0026#39;world!\u0026#39;\u0026#34;\u0026#34;\u0026#34; return \u0026#34;world!\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: # Emacs 28.1+ has f-string syntax highlighting built in print(f\u0026#34;{hello_text()}, {world_text()}!\u0026#34;) By visiting this file, Emacs automatically goes into python-mode, which turns on a lot of Python-specific functionality. If you\u0026#39;re impatient like me and want to see everything that\u0026#39;s available right away, I\u0026#39;d start with C-c C-h from the editing.py buffer to see key commands specific to python-mode, and also use C-h a python to see every command involving the word \u0026#34;python\u0026#34; in some way. Out of the box we also get syntax highlighting, including within f-strings.\nUseful C-c commands Emacs typically has commands that are specific to the active major mode bound to C-c C-\u0026lt;letter\u0026gt;. What each \u0026lt;letter\u0026gt; does will depend on the buffer you\u0026#39;re currently in and what major mode is active. In our case, that\u0026#39;s python-mode, which has a lot of handy shortcuts already mapped out. For any of the keyboard shortcuts you can always use C-h k, or C-h f for the function names (prefixed by M-x below) to get the official documentation.\nC-c C-p or M-x run-python to start a python REPL This boots up what Emacs calls an \u0026#34;inferior Python shell\u0026#34;. \u0026#34;Inferior\u0026#34; here just means that Python is running as a subprocess of Emacs; not that there\u0026#39;s some other, \u0026#34;superior\u0026#34; method of running a Python process. If you need to control the exact command Emacs runs to start the shell, you can use the universal C-u prefix before either C-c C-p or M-x run-python to edit the command Emacs runs. Based on the previous article, what I\u0026#39;m frequently doing is holding down the Ctrl key with my left little finger, then rapidly typing u, c, and p to get C-u C-c C-p, bringing up a minibuffer prompt like this:\nRun Python: python3 -i█ Where █ is point (my cursor). I then use C-a to move point back to the start and add a poetry run:\nRun Python: poetry run█python3 -i Emacs is typically smart enough to figure out what to do even if we leave off the -i, but generally it\u0026#39;s good to leave it in there.\nC-c C-z jumps to python REPL if already running Once the REPL is running, this is a very handy one for swapping back and forth between a file I\u0026#39;m actively editing and a running Python process\nC-c C-{c,e,r} for sending chunks to the REPL A handy complement to C-c C-z, these commands are for taking pieces of Python that I\u0026#39;m actively editing and sending them to the Python buffer all at once.\nC-c C-v or M-x python-check More on this later…\nC-c C-t ... or python-skeleton-... Using C-c C-t d and C-c C-t c it\u0026#39;s easy to insert new def and class statements (think t for \u0026#34;template\u0026#34;, d for \u0026#34;def\u0026#34;, and c for \u0026#34;class\u0026#34;). Ater invoking one of these, Emacs will guide us through the process of filling out each part needed to define a new function or class via the minibuffer. Using C-g at any point while editing the template wil revert the buffer back to its original state, as if you never started filling out the skeleton.\n# editing.py # --snip-- # Here we use `C-c C-t d` and follow the prompts to design a new # function signature. def whatever(my_string: str = hello_text, my_integer: int = 0): \u0026#34;\u0026#34;\u0026#34;Whatever, man\u0026#34;\u0026#34;\u0026#34; return f\u0026#34;{hello_text}, {my_integer}\u0026#34; # Next, `C-c C-t c` to make a new class class MyGuy: \u0026#34;\u0026#34;\u0026#34;My guy is ALWAYS there for me\u0026#34;\u0026#34;\u0026#34; pass # --snip-- \u0026#34;__main__\u0026#34; C-c C-j or M-x imenu The nimble, builtin imenu is a way to quickly navigate between major symbol definitions in the current buffer - especially those off screen. In our editing.py we now have three functions, hello_text(), world_text(), and whatever(), and one class MyGuy. If we use C-c C-j, a minibuffer menu like this comes up:\n1/5 Index item: █ *Rescan* MyGuy.(class) whatever.(def) world_text.(def) hello_text.(def) My minibuffer displays a vertical preview of the options because I\u0026#39;ve set (fido-mode) and (vertical-fido-mode) in my init.el, both of which are included in Emcacs 28.1 or later. Then, if I partially type out a result the list will filter down to possible completions:\n1/1 Index item: My█ MyGuy.(class) imenu is very, very handy across Emacs, not just for Python, so it\u0026#39;s worth trying in a variety of major modes.\nRunning Now its time to actually start executing some code. Before getting to all the complexity of virtual environments, we\u0026#39;ll start simply by just invoking the system Python for our script. Once that feels comfortable, we\u0026#39;ll throw in all the venv goodies.\nAs a script with M-x compile This mode has built-in error parsing, so it\u0026#39;s the best way to run a script for real if we want to quickly navigate any traceback messages that come up. Conversely, the M-\u0026amp; async shell command does not have error parsing, so it\u0026#39;s not the right tool for launching processes we have to debug. Same goes for booting up a shell and running Python from there. Taking our script from the previous section, if we run M-x compile and give it an argument of python3 editing.py, up pops the *compilation* buffer, with the starting time, output of our program, and finish time.\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 13:50:39 python3 editing.py Hello, world! Compilation finished at Sun Aug 14 13:50:39 Now, let\u0026#39;s try a different script, with an error in it:\n# hello_error.py print(\u0026#34;Not an error yet!\u0026#34;) fdafdsafdsafdsa print(\u0026#34;Shouldn\u0026#39;t make it here...\u0026#34;) Now, M-x compile will error out:\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 13:53:26 python3 hello_error.py Not an error yet! Traceback (most recent call last): File \u0026#34;/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/hello_error.py\u0026#34;, line 4, in \u0026lt;module\u0026gt; fdafdsafdsafdsa NameError: name \u0026#39;fdafdsafdsafdsa\u0026#39; is not defined Compilation exited abnormally with code 1 at Sun Aug 14 13:53:26 Emacs will parse the error message, so that after \u0026#34;compiling\u0026#34;, we can use M-g M-n and M-g M-p to move between error messages, or just click the link provided by the *compilation* buffer directly.\nIf just parsing Python tracebacks doesn\u0026#39;t excite you, mypy is also supported out of the box. Assuming mypy is already installed, M-x compile with mypy hello_error.py as the command results in this:\n-*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 14:02:03 .venv/bin/mypy hello_error.py hello_error.py:4: error: Name \u0026#34;fdafdsafdsafdsa\u0026#34; is not defined Found 1 error in 1 file (checked 1 source file) Compilation exited abnormally with code 1 at Sun Aug 14 14:02:04 The hello_error.py:4: error: ... message will be a functional link, just as before. mypy is much more suitable for general error-checking though, so as scripts (and bugs) grow, the M-x compile command can keep up:\n# errors.py import typing import requests import aaaaaaa foo print(typing.fdafdsafdsafdsafdsafdsafdsa) def whatever(x: str) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Here\u0026#39;s a docstring!\u0026#34;\u0026#34;\u0026#34; return x + 1 M-x compile RET mypy errors.py -*- mode: compilation; default-directory: \u0026#34;~/repos/renzmann.github.io/content/posts/006_emacs_2_python/\u0026#34; -*- Compilation started at Sun Aug 14 14:06:55 .venv/bin/mypy errors.py errors.py:6: error: Cannot find implementation or library stub for module named \u0026#34;aaaaaaa\u0026#34; errors.py:6: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports errors.py:8: error: Name \u0026#34;foo\u0026#34; is not defined errors.py:9: error: Module has no attribute \u0026#34;fdafdsafdsafdsafdsafdsafdsa\u0026#34; errors.py:14: error: Unsupported operand types for + (\u0026#34;str\u0026#34; and \u0026#34;int\u0026#34;) Found 4 errors in 1 file (checked 1 source file) Compilation exited abnormally with code 1 at Sun Aug 14 14:06:55 Now, we can use M-g M-n and M-g M-p to quickly navigate between the errors in our code, even after navigating away from the original errors.py buffer - Emacs will remember what\u0026#39;s going on in the *compilation* buffer so we can hop all around the code base while addressing errors one at a time.\nInteractively with the Python shell python-mode centers heavily around the use of an active, running Python session for some of its features, as we\u0026#39;ll see in the next section. Its documentation recommends regular use of C-c C-c, which sends the entire buffer to the active inferior Python process. That means actually executing Python code, which may feel a bit dangerous for those of us who grew up with static analysis tools. So the first thing we need to make sure we don\u0026#39;t accidentally kick off our whole script is ensure that the main part of our program is properly ensconced.\n# editing.py # --snip-- if __name__ == \u0026#34;__main__\u0026#34;: print(f\u0026#34;{hello_text()}, {world_text()}!\u0026#34;) Code Completion Emacs uses the currently running *Python* process for looking up symbols to complete. As such, python.el recommends using C-c C-c to send the entire buffer\u0026#39;s contents to the Python shell periodically. if __name__ == \u0026#34;__main__\u0026#34; blocks do not execute when using C-c C-c. To send all code in the current buffer, including the __main__ block, instead we must use C-u C-c C-c.\nAnother awkward default in Emacs is that what we typically know of as \u0026#34;tab-complete\u0026#34; is bound to M-TAB, or the equivalent C-M-i (C-i and TAB are the same thing). On most Windows and Linux desktops, Alt+Tab changes the active window, and C-M-i is much too cumbersome to be a reasonable completion shortcut. I prefer just being able to hit TAB to invoke completion-at-point, so I use this snippet in my init.el:\n;; init.el ;; Use TAB in place of C-M-i for completion-at-point (setq tab-always-indent \u0026#39;complete) Now to demonstrate this new completion power. In our python file editing.py, I know we have a function called hello_text(). Within the main block, I might have been typing something that looked like this:\nif __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;{hell█ Where █ is point. Attempting a completion-at-point using C-M-i (or just TAB as I have re-bound it above) will yield … nothing. Maybe the indentation cycles, or it says \u0026#34;No match\u0026#34;, or just - no response. What we require is a running inferior Python process, which will look up completion symbols. After booting up Python with C-c C-p and sending all the current buffer contents with C-c C-c, hitting TAB completes the hell into hello_text:\nif __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;{hello_text█ In the case that the completion is ambiguous, a *completions* buffer will pop up, prompting for input on how to continue. Another nice thing about this completion method is that it respects your completion-styles setting. Personally, I keep mine globally set to include the flex style, which closely mimics fuzzy matching styles like you get in VSCode, JetBrains, or fzf:\n;; init.el (setq completion-styles \u0026#39;(flex basic partial-completion emacs22)) This allows me to type something like hltx, hit TAB and it completes to hello_text.\nDebugging If by running our Python code we encounter the breakpoint() builtin, Emacs will automatically break into pdb/ipdb (depending on your PYTHONBREAKPOINT environment variable), jump to the breakpoint in the code, and put an arrow at the next line to execute.\nRunning the Python debugger by using `C-c C-c` M-x pdb Simply populates the command to run with python -m pdb. Can be configured with the variable gud-pdb-command-name\nThe poetry + pyright stack The stack I use most frequently (for now) consists of:\npython3.10 as the Python runtime poetry for dependency and environment management1 pyright for error checking2 emacs for everything else Each component should, in theory, be easy to replace. That is, if I want conda as a package manager and flake8 or mypy for linting/type checking, it should be easy to do a drop-in replacement for them.\nFor those who haven\u0026#39;t heard the good news of poetry, it takes care of a lot of headaches that every pythonista regularly deals with. It manages your virtual environment (creation and update), pyproject.toml specification, and a poetry.lock file that serves as a replacement for requirements.txt, housing exact dependency version numbers for project collaborators to install. All of these are automatically kept in sync, so you never have the case like with conda where someone does a conda or pip install into their environment but never bothers to update the setup.py, environment.yml, requirements.txt or whatever.\nEarlier we mentioned that running our Python scripts via the M-\u0026amp; async shell command interface wasn\u0026#39;t a great use case for it. However, using it to set up a poetry environment is a fantastic example of when it is appropriate.\nAsync shell command: poetry init -n --python=^3.10 Assuming the poetry command ran without error, it plopped down the pyproject.toml in the same directory as errors.py. In a similar vein, we can add project dependencies using M-\u0026amp;\nAsync shell command: poetry add pyright requests The *Async Shell Command* buffer will update as poetry runs and installs the required dependencies. Following this, we should have the pyright CLI installed to the virtual environment poetry set up for us. As a sanity check, I\u0026#39;ll start up either M-x shell or M-x eshell (whichever happens to be behaving better that day) to just get a simple cross-platform shell running where I can try it out:\n~/tmp $ # using the same `errors.py` as in the earlier sectons ~/tmp $ poetry run pyright errors.py No configuration file found. pyproject.toml file found at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python. Loading pyproject.toml file at /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml Pyproject file \u0026#34;/home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/pyproject.toml\u0026#34; is missing \u0026#34;[tool.pyright]\u0026#34; section. stubPath /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/typings is not a valid directory. Assuming Python platform Linux Searching for source files Found 1 source file /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:5:8 - error: Import \u0026#34;aaaaaaa\u0026#34; could not be resolved (reportMissingImports) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - error: \u0026#34;foo\u0026#34; is not defined (reportUndefinedVariable) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:7:1 - warning: Expression value is unused (reportUnusedExpression) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:8:14 - error: \u0026#34;fdafdsafdsafdsafdsafdsafdsa\u0026#34; is not a known member of module (reportGeneralTypeIssues) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:13:12 - error: Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; when expected type is \u0026#34;str\u0026#34; (reportGeneralTypeIssues) /home/robb/repos/renzmann.github.io/content/posts/006_emacs_2_python/errors.py:4:8 - warning: Import \u0026#34;requests\u0026#34; could not be resolved from source (reportMissingModuleSource) 4 errors, 2 warnings, 0 informations Completed in 1.033sec Emacs actually has a couple ways of running error-checking tools like this. The typical one is M-x compile, which we saw earlier, but there\u0026#39;s also C-c C-v for M-x python-check. The latter will automatically check for tools like pyflakes or flake8, but can be configured with the python-check-command variable to pre-populate the command to run. Like M-x compile, M-x python-check will use a buffer that looks identical to *compilation* in every way except name: it will be called the *Python check: \u0026lt;command you ran\u0026gt;* buffer.\nFor me, that means I typically have something like\n(setq python-check-command \u0026#34;poetry run pyright\u0026#34;) and then C-c C-v from a python buffer will prompt like this while errors.py is my active buffer\nCheck command: poetry run pyright errors.py Adding error parsing to the pyright compile output Unlike the mypy output, the error messages from pyright aren\u0026#39;t links, and we can\u0026#39;t hop between messages using M-g M-n and M-g M-p like before. In order to gain this functionality, we need to add a regex that can parse pyright messages. There are two objects of interest to accomplish this:\ncompilation-error-regexp-alist compilation-error-regexp-alist-alist Here\u0026#39;s the formal description from C-h v compilation-error-regexp-alist:\nAlist that specifies how to match errors in compiler output. On GNU and Unix, any string is a valid filename, so these matchers must make some common sense assumptions, which catch normal cases. A shorter list will be lighter on resource usage. Instead of an alist element, you can use a symbol, which is looked up in ‘compilation-error-regexp-alist-alist’. In not so many words, this says we should modify the *-alist-alist version, and simply add a symbol to the *-alist variable. Examining the current value via C-h v compliation-error-regexp-alist-alist, it\u0026#39;s easy to see that we\u0026#39;re after an expression a bit like this,\n(add-to-list \u0026#39;compilation-error-regexp-alist-alist \u0026#39;(pyright \u0026#34;regexp that parses pyright errors\u0026#34; 1 2 3)) eventually replacing the string in the middle with an actual Emacs regexp. Thankfully, Emacs has the M-x re-builder built in for doing exactly that! Since *Python check: poetry run pyright errors.py* is a buffer like any other, we can hop over to it, and run M-x re-builder to piece together a regex that extracts file name, line number, and column number from each message.\nBuilding the regex that parses pyright errors interactively Clearly, there are some errors in the regexp so far, but as we edit the text in the *RE-Builder* buffer, the highlighting in the *compilation* buffer will update live to show us what would be captured by the regexp we\u0026#39;ve entered. After fiddling with the contents in the bottom buffer to get the highlighting correct, we\u0026#39;ve got this regular expression:\n\u0026#34;^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\u0026#34; Now we just need to add this into the compilation-error-regexp-alist-alist in our init.el:\n;; init.el (require \u0026#39;compile) (add-to-list \u0026#39;compilation-error-regexp-alist-alist \u0026#39;(pyright \u0026#34;^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\u0026#34; 1 2 3)) (add-to-list \u0026#39;compilation-error-regexp-alist \u0026#39;pyright) After restarting emacs with the modified alist, we get error prasing from pyright output:\nFunctional links in the *compilation* buffer after running pyright Virtual Environments Since I use poetry so frequently, and I can prefix all of the Emacs or shell commands with poetry run, it\u0026#39;s pretty rare that I have to invoke specific virtual environments. That said, this guide would have a pretty large hole in it if we didn\u0026#39;t mention the vanilla virtual environment experience.\nMost folks tend to run a slightly different virtual environment workflow from one another. What I\u0026#39;m showing off below is the one I think fits most easily with the flavor of vanilla already presented in this article, with some added knowledge about how .dir-locals.el works (coming up shortly).\nCreate a virtual environment Keeping a .venv folder at the top level of a project is one valid way to organize things, but (vanilla) Emacs isn\u0026#39;t going to make it easy for us to use it that way. Instead, I\u0026#39;d recommend keeping all virtual environments in a central place. For me, that looks like this:\nM-! python3 -m venv ~/.cache/venvs/website This builds a virtualenv named website for python utilities that help buld my blog under the ~/.cache directory on Unix. To use this virtualenv explicitly for shell utilities, I can always run commands like this\nM-! ~/.cache/venvs/website/bin/python -m pip install mypy M-! ~/.cache/venv/website/bin/mypy errors.py Of course, adding the prefix ~/.cache/venvs/website/bin every time is a bit cumbersome, especially for frequent commands like M-x python-check.\n.dir-locals.el for setting virtual environment One quick way to reduce some typing is to add entries in a project file called .dir-locals.el. This is a special data file that Emacs will read, if it exists, and apply to all new buffers within the project. For our needs, we want to apply a couple changes to python-mode specifically to use the virtual environment instead of system python. The two easy ones are the python-check-command and python-shell-virtualenv-root:\n;; .dir-locals.el ((python-mode . ((python-check-command . \u0026#34;%HOME%\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe -m mypy\u0026#34;) (python-shell-virtualenv-root . \u0026#34;~/.cache/venvs/website\u0026#34;)))) I\u0026#39;ve included a quirk of working on Microsoft Windows here - the python-check-command needs to run through your shell, which is cmd.exe by default, and hence requires Windows-style paths. The python-shell-virtualenv-root, however, is evaulated by Emacs, and can use tilde-expansion and Unix-style paths. Changing default shell commands to run through pwsh on Windows would likely alleviate this issue, but it\u0026#39;s worth calling out for cmd.exe users.\nIt\u0026#39;s also worth mentioning here that M-x add-dir-local-variable provides an easy interactive interface to editing the .dir-locals.el file.\nThe python-shell-virtualenv-root part only affects running Python as a shell within Emacs, it does not affect things like PATH, async commands, or M-x compile. To demonstrate this, once we\u0026#39;ve set up .dir-locals.el as above, and we either revert a Python buffer with C-x x g or open a new Python buffer in the same project, a popup like this appears:\nThe local variables list in c:/Users/robbe/repos/renzmann.github.io/content/posts/006_emacs_2_python/ contains values that may not be safe (*). Do you want to apply it? You can type y -- to apply the local variables list. n -- to ignore the local variables list. ! -- to apply the local variables list, and permanently mark these values (*) as safe (in the future, they will be set automatically.) i -- to ignore the local variables list, and permanently mark these values (*) as ignored * python-check-command : \u0026#34;%HOME%\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe -m mypy\u0026#34; * python-shell-virtualenv-root : \u0026#34;~/.cache/venvs/website\u0026#34; Responding with y will set the python-check-command and python-shell-virtualenv-root for just the current session, while ! will add both of these values to the custom section in either init.el or wherever you\u0026#39;ve set your custom-file. This is another reason for using a common, central spot for virtual environments, since across workstations I can use the same path relative to my $HOME directory. After confirming, and using C-c C-p, we can check which Python executable we\u0026#39;re using in the *Python* buffer now:\nPython 3.10.6 (tags/v3.10.6:9c7b4bd, Aug 1 2022, 21:53:49) [MSC v.1932 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import sys; sys.executable \u0026#39;c:\\\\Users\\\\robbe\\\\.cache\\\\venvs\\\\website\\\\Scripts\\\\python.exe\u0026#39; Keep in mind, the values provided in .dir-locals.el are evaluated on a per-buffer basis, so attempting to set a relative path like (python-shell-virtualenv-root . \u0026#34;.venv/website\u0026#34;) will only work when executing run-python in the same directory as .dir-locals.el and .venv/.\nThe various compile and shell commands will not respect the virtualenv we\u0026#39;ve set via .dir-locals.el. On *nix, M-x compile RET which python3 will still bring back some variant of /usr/bin/python3, as will M-\u0026amp; which python or M-! which python. In a follow-up article we might explore how it is possible to take care of all this via .dir-locals.el and the special exec variable, but it\u0026#39;s not very elegant.\nAll things considered: pyvenv pyvenv is a very lightweight package, clocking in at around 540 source lines of code, designed specifically around the challenge of ensuring the correct python virtual environment is at the front of PATH when running (async) shell commands, M-x eshell, M-x shell, M-x term, M-x python-check, M-x compile, and more. When written, it was based around virtualenv and virtualenvwrapper.sh, and some of the language it uses will reflect that. Although virtualenv has mostly fallen out of favor, the core functionality of pyvenv is still very relevant. Especially if you choose to adopt a central store of virtual environments, as above, you can set that as a WORKON_HOME variable (\u0026#34;workon\u0026#34; is terminology held over from virtualenvwrapper.sh) to a directory that all your virtual environments sit under, so that it\u0026#39;s easy to select one with the pyvenv-workon function. When using poetry, that usually looks like this:\n(if (eq system-type \u0026#39;windows-nt) ;; Default virtualenv cache directory for poetry on Microsoft Windows (setenv \u0026#34;WORKON_HOME\u0026#34; \u0026#34;$LOCALAPPDATA/pypoetry/Cache/virtualenvs\u0026#34;) ;; Default virtualenv cache directory for poetry on *nix (setenv \u0026#34;WORKON_HOME\u0026#34; \u0026#34;~/.cache/pypoetry/virtualenvs\u0026#34;)) (pyvenv-mode) Setting WORKON_HOME to ~/.cache/venvs as in the previous examples is another valid option. Doing it this way also plays nice with .dir-locals.el, since pyvenv exposes a way to set a project-level venv with a single variable:\n;; .dir-locals.el ((python-mode . ((pyvenv-workon . \u0026#34;website\u0026#34;)))) Also of use for folks who frequently swap between different projects is (pyvenv-tracking-mode), which will automatically change the active python virtual environment when you navigate to a different buffer.\nAnd, of course, if the whole \u0026#34;workon\u0026#34; and virtualenvs grouped together under ~/.cache/venvs isn\u0026#39;t to taste, there\u0026#39;s always M-x pyvenv-activate, which lets you choose a virtual environement anywhere on your system. So, all-in-all, I\u0026#39;ll probably stick with pyvenv in my configuration, because setting all the different utility PATHs without it is just such a pain.\nNext: Notebooking Belive it or not, we\u0026#39;ve only scratched the surface. org-mode and org-babel together provide a fully-functional \u0026#34;notebooking\u0026#34; (technically \u0026#34;literate programming\u0026#34;) experience out of the box with recent versions of Emacs. The next article will focus exclusively on Python and data science in Org as a near-complete Jupyter replacement.\nFootnotes 1 https://python-poetry.org/docs/#installation\n2 https://github.com/microsoft/pyright#command-line\n","date":"4 September 2022","permalink":"/posts/006_emacs_2_python/","section":"Posts","summary":"Intro There are a lot of great guides on getting set up with Python in Emacs.","title":"Emacs Part 2: Python (Vanilla is a Powerful Flavor)"},{"content":" Setup In one of my first articles about getting set up with packages.el, I left a somewhat expensive line hanging out in the open:\n;; init.el ;; --snip-- (package-refresh-contents) ;; --snip-- This function will call out to any repositories we\u0026#39;ve configured to search packages from and update our local registry of what\u0026#39;s available. That can take a few seconds, and is a bit annoying if you\u0026#39;re constantly restarting Emacs to work on your init.el like I am right now. So it would be nice if this function instead looked something like this:\n(when \u0026lt;packages-aren\u0026#39;t-installed\u0026gt; (package-refresh-contents)) We just need a little code to check when \u0026lt;packages-aren\u0026#39;t-installed\u0026gt; is true. We already discovered that the variable package-selected-packages, managed by custom.el, is a list of packages that we\u0026#39;ve chosen to install. We also know that the function package-installed-p checkes whether a particular package is installed or not. In my init.el, I have a block like so:\n;; init.el ;; --snip-- (custom-set-variables \u0026#39;(package-selected-packages \u0026#39;(markdown-mode marginalia))) ;; --snip-- So it seems like we have the ingredients we need, save for a way to apply the package-installed-p over the whole list package-selected-packages, and reduce down to a single true or false value, depending on if any of the expected packages aren\u0026#39;t installed. Altogether, that means we have a very simple map-reduce problem, and I am certain there\u0026#39;s a function in Emacs ready for us to use - we just need to find it.\nVertical FIDO Mode This hidden superpower of Emacs 28.1+, along with the marginalia package described below, are the main tools in my arsenal for surfacing everything from Emacs\u0026#39; many hidden, labyrinthine depths.\n;; Set \u0026#39;flex\u0026#39; to be the main completion style. This enables a \u0026#34;fuzzy\u0026#34; ;; style of searching for things using the minibuffer (setq completion-styles \u0026#39;(flex basic partial-completion emacs22)) ;; Turn on FIDO (Fake IDO) mode (fido-mode) ;; Have TAB complete using the first option and continue, instead of ;; popping up the *Completions* buffer (define-key icomplete-minibuffer-map [remap minibuffer-complete] \u0026#39;icomplete-force-complete) ;; Sometimes I have to customize this icomplete-compute-delay variable ;; to 0.0 to avoid delay before the M-x minibuffer pops up (setq icomplete-compute-delay 0.0) ;; Set the display to be a vertical list of items, instead of a horizontal one (fido-vertical-mode) This sets up the minibuffer to show a live update of completion candidates as we type, in an easy-to-read vertical format\nMarginalia While not a part of base Emacs, this little package complements the vertical FIDO display by adding information, usually a docstring, next to each item. After performing a M-x package-refresh-contents and M-x package-install RET marginalia, we get this:\nSearch Process The modifications we just made also affect commands that search through variables and functions, like C-h f (describe-function). What we\u0026#39;re after right now is some kind of function that acts on a list, and tells us if any of the items are nil after applying the package-installed-p function to them. My gut tells me that a word like \u0026#34;all\u0026#34;, \u0026#34;every\u0026#34;, or \u0026#34;none\u0026#34; might appear in such a function. After trying a few of these, examining the descriptions, and quickly trying again, a query for the word \u0026#34;any\u0026#34; brought up a promising function called cl-notany\nIt\u0026#39;s close; this one will yield t when every element in the sequence is nil, we want one for when any element is nil. Hitting RET on cl-notany above brings up its help text\ncl-notany is an autoloaded compiled Lisp function in ‘cl-extra.el’. (cl-notany PREDICATE SEQ...) Return true if PREDICATE is false of every element of SEQ or SEQs. [back] There\u0026#39;s a link on `cl-extra` in this buffer, and my bet is that the function we\u0026#39;re looking for would be defined near cl-notany. Following that link takes us to a block of code with the defun for cl-notany. Lo and behold, there\u0026#39;s a cl-notevery right below it with a description that matches exactly what we need:\n;; cl-extra.el ;;;###autoload (defun cl-notany (cl-pred cl-seq \u0026amp;rest cl-rest) \u0026#34;Return true if PREDICATE is false of every element of SEQ or SEQs. \\n(fn PREDICATE SEQ...)\u0026#34; (not (apply #\u0026#39;cl-some cl-pred cl-seq cl-rest))) ;;;###autoload (defun cl-notevery (cl-pred cl-seq \u0026amp;rest cl-rest) \u0026#34;Return true if PREDICATE is false of some element of SEQ or SEQs. \\n(fn PREDICATE SEQ...)\u0026#34; (not (apply #\u0026#39;cl-every cl-pred cl-seq cl-rest))) Writing the when block With cl-notevery in hand, the last step is to apply it in our init.el for managing package refresh and installation.\n(when (cl-notevery \u0026#39;package-installed-p package-selected-packages) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-refresh-contents) (package-install-selected-packages)) ","date":"22 August 2022","permalink":"/posts/007_emacs_3_discovering/","section":"Posts","summary":"Setup In one of my first articles about getting set up with packages.","title":"Discovering Useful Functions in Emacs"},{"content":" Philosophy This is the first part of a series in building an emacs configuration around the data science toolkit, which I introduced in another article. I won\u0026#39;t be covering the absolute basics here, like how to download and install Emacs, but just my thoughts as I start building my configuration from a brand new ~/.emacs.d/init.el1. In many ways, this is a notes-as-I-go type of article, and I may gloss over details I don\u0026#39;t find important yet or would become obvious after a little Googling.\nIf this is your first exposure to Emacs, this is what it looks like when you download it and start it without configuring it at all:\nAt this point, the world is your oyster - they provide a few helpful links to get a new user started, but basically we can take this program and make it do whatever we want, including writing and building this website! While Emacs is a fairly feature-rich editor by itself, I know there are features it doesn\u0026#39;t provide off the shelf that I want to include, especially:\nLanguage server stuff - like pyright for Python editing A git management UI Intellisense-like code completion That means we need to get comfortable with whatever plugin or package system emacs supports. My first impression exploring Reddit, package author sites, and github is that most Emacs-ers have an incredibly favorable view of throwing whatever kitchen sink you like into your configuration, as long as you feel happy.\nThis is a strikingly different attitude compared to (especially vanilla) Vim configuration advice. Typically when asking for advice in the Vim circles you\u0026#39;ll first be greeted with \u0026#34;you aught to try this built-in capability first\u0026#34;. There are also notably vocal members who will argue against using any plugin that doesn\u0026#39;t serve some critical missing functionality of the editor. When dipping into the Emacs forums, quite to the contrary, I\u0026#39;ve seen members mention \u0026#34;I know person A does it like X because of Y, but I do W because Z\u0026#34;, often from a place of understanding or empathy to a particular use case. One user even mentioned that they need vertical popup to assist with voice-powered coding tools, and hence will only consider auto-complete frameworks that work in that way for them. That level of community acceptance and support is encouraging to see, and Neovim has adopted a similar attitude to some extent, but is still somewhat nascent, especially with the recent Vim9/Lua debacle.\nA brief note about keyboard shortcuts and finger contortion I\u0026#39;m including this section about \u0026#34;how to use your fingers\u0026#34; because it\u0026#39;s something I desparately wish had been laid out for me when I was first starting Emacs. There are a lot of key combinations in Emacs that rely on consistent, easy access to the Ctrl and Alt (option on macOS) keys. What I was lacking was a guide along the lines of \u0026#34;use your left little finger for this modifier, followed by your thumb for this one.\u0026#34; Starting out, some of the combinations looked impossibly slow to be useful, just because of the muscle memory I already built around using Ctrl and Alt. For instance, imagine seeing this keyboard shortcut for navigating up three lines in Emacs:\nCtrl + 3 Ctrl + p At the time, I was used to hitting Ctrl+3 with my right little finger on the Ctrl in the lower right and left middle finger on the \u0026#34;3\u0026#34;, and then using the left Ctrl for Ctrl+p. That seemed like a lot of wasted arm movement just to do what would normally be 3k in Vim. In reality, nearly every Emacs user has the \u0026#34;Ctrl\u0026#34; key just to the left of their little finger on the home row.2 This is where most American keyboards place the \u0026#34;Caps Lock\u0026#34; key, which in my opinion is just dead useless. Regardless of whether you use something like Vim or Emacs, this is a good key to remap, and I do it on every workstation with one of these pieces of software:\nmacOS: Karabiner Elements (Third party) Windows: PowerToys (included with Windows 10) Linux: On Ubuntu/Gnome it\u0026#39;s usually as easy as Tweaks -\u0026gt; Keyboard \u0026amp; Mouse -\u0026gt; Additional Layout options QMK Firmware - when I\u0026#39;m on one of my fancy programmable keyboards Given that remapping, the combination should work like this:\nLeft little finger holds down \u0026#34;Ctrl,\u0026#34; using what is normally the \u0026#34;Caps Lock\u0026#34; key Press \u0026#34;3\u0026#34; with left middle finger Press \u0026#34;p\u0026#34; with right ring finger Release \u0026#34;Ctrl\u0026#34; I can perform this version just as fast as 3k in Vim - since the \u0026#34;Ctrl\u0026#34; and \u0026#34;3\u0026#34; can happen at the same time. Below I\u0026#39;ve listed my general \u0026#34;finger flow\u0026#34; to maintain tempo while using Emacs. For the rest of the article I\u0026#39;m going to use Emacs-style notation, which means C-x is \u0026#34;Ctrl\u0026#34; plus \u0026#34;x\u0026#34; at the same time, and M-x for \u0026#34;Alt\u0026#34; plus \u0026#34;x\u0026#34; at the same time. The M is short for \u0026#34;Meta\u0026#34;, a vestigial artifact of Emacs\u0026#39; history as a screen terminal program, and a common point of befuddlement for young, unwary travelers like me.\nLeft little finger for \u0026#34;Ctrl\u0026#34;, left of \u0026#34;a\u0026#34; on American QWERTY keyboard in almost all cases Left thumb on \u0026#34;Meta\u0026#34; (Alt/option), just to the left of the spacebar for most cases Left little finger to use \u0026#34;Cmd\u0026#34; (Windows key, emacs calls this \u0026#34;super\u0026#34;) just to the left of \u0026#34;Meta\u0026#34;, when modifying a right-hand letter, i.e. ⌘-p Either right little finger or right thumb to use \u0026#34;Cmd\u0026#34; when I need a left-hand modified character, like ⌘-w, depending on the keyboard I\u0026#39;m using For C-x and C-c specifically, I have my right enter key bound to \u0026#34;Ctrl\u0026#34; on hold, \u0026#34;Enter\u0026#34; on tap, so that I can type the x and c characters as I normally would, without stretching my left little finger upwards and to the left at the same time. When I don\u0026#39;t have the ability to program my Enter key this way, I\u0026#39;ll hop between using the right Ctrl and modified Caps Lock key For M-x (that\u0026#39;s \u0026#34;Alt\u0026#34; and \u0026#34;x\u0026#34; together, or \u0026#34;option\u0026#34; + \u0026#34;x\u0026#34; on a mac, which Emacs calls \u0026#34;Meta\u0026#34;) specifically, I will usually use either my right thumb or right little finger on the Alt/option key, depending on the keyboard and how wide the spacebar is, because I find that more comfortable than crossing over on my left hand to hit both keys. Similarly, I find M-q, M-w, and M-z all easier by using both hands Actually setting up the config Now that we\u0026#39;ve made it past the first hurdle of using the keyboard, we can actually open Emacs and start configuring it. The most radical departure from my experience in Vim/Neovim starts here, with the Easy Customize interactive system. Emacs leans heavily on its interactive components, backed by plain text and data - which was admittedly a pleasant discovery. VSCode rediscovered this type of system by providing an easy customization UI representing a swath of JSON configuration under the hood, which has proved immensely popular. By comparison, I would argue that the Emacs interface is downright hideous, but easier to grok.\nBy way of example, let\u0026#39;s walk what it looks like to customize the color theme just via interactive commands. First, we hit M-x, Emacs\u0026#39; equivalent of the \u0026#34;Command Palette\u0026#34;, if you\u0026#39;re coming from something like VSCode or Jupyter, and enter customize-theme to get a menu that shows all the default color themes we could use. Another option, barring the use of M-x, is to use the menu bar and mouse just like we would in any other GUI program: \u0026#34;Options -\u0026gt; Customize Emacs -\u0026gt; Custom Themes\u0026#34; takes us to the same place.\nClicking the check box next to \u0026#34;tango-dark\u0026#34; and then clicking the \u0026#34;Save Theme Settings\u0026#34; results in a modified color theme that looks like this:\nThere are now two new things in your home directory:\nA file called .emacs A directory called .emacs.d/ Opening the former using \u0026#34;File -\u0026gt; Open File…\u0026#34; (which may require turning on a \u0026#34;Show Hidden Files\u0026#34; option, depending on your system) shows us this set of text:\n(custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won\u0026#39;t work right. \u0026#39;(custom-enabled-themes \u0026#39;(tango-dark))) (custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won\u0026#39;t work right. ) The code here is Emacs LISP - a programming language in its own right - and the main configuration language for the Emacs editor. Coming from Vim, where the only method of configuration is by manually editing your ~/.vimrc, this really blew my socks off. The implication here is that we can use interactive menus, backed by a proper programming language (not just JSON data), which can take effect right next to my hand-tuned configuration, and I\u0026#39;m free to modify it however I like later on. It is a bit cumbersome to have two folders dedicated to configuration, though, so the first thing I do here is \u0026#34;File -\u0026gt; Save As…\u0026#34; and write it to ~/.emacs.d/init.el, then delete the ~/.emacs file. Emacs will automatically detect this and load the correct file the next time we start it up.\nA short foray into elisp Usually, the first symbol inside parenthesis is a function, and the remaining symbols its arguments. So, coming from more traditional languages like Java, Python, C, etc., I tend to visualize it this way:\nelisp version Kinda like ------------- ---------- (foo) foo() (foo \u0026#34;bar\u0026#34;) foo(\u0026#34;bar\u0026#34;) (foo \u0026#34;bar\u0026#34; 2) foo(\u0026#34;bar\u0026#34;, 2) I say \u0026#34;usually\u0026#34; because there are other constructs, such as special forms and macros, but I\u0026#39;m definitely not getting to those for a while. I also say \u0026#34;Kinda like\u0026#34; because I\u0026#39;m pretty sure an experienced elisp-er would look at what I\u0026#39;ve written and say \u0026#34;yeah, no\u0026#34;, but as I\u0026#39;m just starting out this is a helpful mental thesaurus.\nRedirect \u0026#34;custom\u0026#34; to separate the interactive stuff from our hand-edited parts We\u0026#39;re going to do a combination of letting the customization menus manage the blocks like we showed above and writing a little configuration ourselves, so I\u0026#39;m going to redirect custom to a different file, then load it from there:\n;; ~/.emacs.d/init.el ;; Redirect custom so it doesn\u0026#39;t edit this file (setq custom-file \u0026#34;~/.emacs.d/custom.el\u0026#34;) ;; Load the custom file (when (file-exists-p custom-file) (load custom-file)) In ~/.emacs.d/custom.el, I placed all the contents of what was written by \u0026#34;custom\u0026#34; - the block that originally went to ~/.emacs after saving the custom theme. Now we have two distinct spots for customizing emacs:\n~/.emacs.d/custom.el - managed by the interactive customization menus. We never touch this one by hand ~/.emacs.d/init.el - customization we do write by hand Later on I\u0026#39;ll cover some other common settings for the init.el file, but for now we\u0026#39;ll leave it be to address more important things. Namely, let\u0026#39;s start plugging in new packages.\nEdit what packages we use interactively Unlike most package managers in the Vim world, it\u0026#39;s rare nowadays to grab code directly off github or submoduling/unzipping some tarball into your configuration directory. Rather, there\u0026#39;s a central repository called ELPA, located at http://elpa.gnu.org/, which hosts well-known packages we can install right away (Python folks can think of ELPA a bit like PyPI). By running M-x list-packages, we\u0026#39;re prompted with this lovely screen:\nThere are a few special key commands, the most common of which I am using are /n to filter by name and /s installed to look for packages I currently have installed.\nThe first thing I wanted was a vertical pop-up style for my minibuffer when using M-x or C-x C-f (finding files), a lot like the \u0026#34;command palette\u0026#34; you get in other editors like VSCode, Jupyter, and JetBrains, when selecting generic actions to take. As of Emacs 28, there\u0026#39;s a built-in vertical FIDO mode that mostly does this, but I kept getting a delay between pressing M-x and the minibuffer popping up, so I opted for a third party package called vertico that I\u0026#39;m very happy with. To install it, all I had to do was use the M-x list-packages buffer posted above and click on \u0026#34;install\u0026#34;, or use M-x package-install RET vertico (that\u0026#39;s M-x package-install, followed by hitting \u0026#34;enter\u0026#34;, then typing vertico and hitting enter again), and Emacs has automatically done three things for me:\nFetched the latest version of the package from ELPA and downloaded it Byte-compiled and installed the package into my editor Edited ~/.emacs.d/custom.el to signal that I selected and installed a new package That last one is mind-blowing. Emacs edited a variable called package-selected-packages and put it into my custom.el file, just by the very nature of installing it interactively.\n;; ~/.emacs.d/custom.el ;; --snip-- \u0026#39;(package-selected-packages \u0026#39;(vertico)) ;; --snip-- This means I can use all of Emacs\u0026#39; interactive features, even while keeping my configuration under the proper text-based version control of my choosing. It also leaves the possibility of managing this variable manually via ~/.emacs.d/init.el open, but we aren\u0026#39;t there yet. At any point, I can also use M-x package-delete or the packages buffer to interactively remove a package from Emacs and ~/.emacs.d/custom.el. Since I\u0026#39;d like to ship my Emacs configuration to many workstations, I\u0026#39;d like Emacs to automatically install these selected plugins, and remove obsolete ones, at boot. There are a couple functions that allow me to do this:\n;; ~/.emacs.d/init.el ;; Enable built-in package manager (require \u0026#39;package) ;; Redirect custom so it doesn\u0026#39;t edit this file (setq custom-file \u0026#34;~/.emacs.d/custom.el\u0026#34;) ;; Load the custom file (when (file-exists-p custom-file) (load custom-file)) ;; At this point, package-selected-packages has been set by loading the custom-file ;; Remove any packages that are installed, but aren\u0026#39;t listed in package-selected-packages (package-autoremove) ;; Keep our registry up-to-date (package-refresh-contents) ;; Install selected packages (package-install-selected-packages) As far as I\u0026#39;m concerned at the moment, this is all the package management I need! The built-in support is so good that I don\u0026#39;t find myself wanting to reach towards an external package manager at all, like I would typically do in Neovim.3\nCommunity packages There is also a community-maintained, much larger selection of plugins on something called \u0026#34;Milkypostman\u0026#39;s Emacs Lisp Package Archive\u0026#34;, usually abbreviated to MELPA, which serves an almost identical role as ELPA, but doesn\u0026#39;t require going through the official GNU channels to get your project hosted. As such, most projects on GitHub require you to enable fetching packages from MELPA before installing. There are two versions of MELPA - melpa.org/packages and the \u0026#34;stable\u0026#34; melpa.org/packages. Both the MELPA setup instructions and community discussion recommend against the use of MELPA-stable, so I\u0026#39;ll be sticking with the regular version:\n;; ~/.emacs.d/init.el ;; --snip-- ;; Keep our registry up-to-date (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-refresh-contents) ;; --snip-- There\u0026#39;s a decent amount of elisp witchcraft in the add-to-list statement alone, but in essence it just enables Emacs to \u0026#34;see\u0026#34; what\u0026#39;s on the community MELPA archive when we run M-x list-packages or M-x package-install. After adding this and digging around /r/emacs and github, I have a minimal set of packages that are enabling me to be productive without too much configuration so far4\ncorfu (intellisense-like autocomplete; plays well with orderless below) exec-path-from-shell (macOS specific) go-mode magit (UI for git, I think basically everyone grabs this) marginalia (preview that works amazingly well with vertico, shows me things like documentation and keybindings next to commands when I open M-x) markdown-mode orderless (a \u0026#34;completion style\u0026#34; that\u0026#39;s pretty nifty, once you get the hang of it) restart-emacs rust-mode tree-sitter (more intelligent code highlighting) tree-sitter-langs use-package (a configuration macro, see below) writeroom-mode (distraction-free writing, which I use for this blog) I am also trying out both lsp-mode with lsp-pyright and eglot for language server stuff to see which one I like better, but haven\u0026#39;t finalized it yet so we\u0026#39;ll keep them in our back pocket for now. I tend to shy away from exceptionally large frameworks, so helm didn\u0026#39;t look appealing at first glance. I\u0026#39;d rather pick exactly the pieces I want to include and get them working one-by-one.\nConfiguring packages we\u0026#39;ve installed The one piece that confused me more than anything while starting out is what the heck use-package actually is or does. Many users online would refer to it as \u0026#34;their package manager\u0026#34;, however it is emphatically not a package manager, as the very first section of their README notes. Because I had just been copying use-package snippets from around the internet before I took a minute to read the use-package documentation, it took me a while to figure out that use-package is meant to be used in conjunction with a package manager, which in our case is the built-in package.el. After package.el installs a new package, it\u0026#39;s likely there are ways to tweak that package that suit our tastes, and that is what we ask use-package to do for us.\nWithout diving into too much detail, it\u0026#39;s easy to imagine how complex managing package start up, configuration, and order-of-operations could be:\nDid I make sure load this package after its prerequisites? How do enable keybindings only when this package is active? How can I delay loading this big, expensive package until I actually need it? It bears mentioning that there are ways to have use-package interface with package.el, but I\u0026#39;m going to hold off on those until I feel like I need them. Here\u0026#39;s an example of how I configure tree-sitter to add spiffy highlighting everywhere I go, without bogging down startup time of emacs:\n(use-package tree-sitter :init (global-tree-sitter-mode) :hook (tree-sitter-after-on . tree-sitter-hl-mode) :config (use-package tree-sitter-hl) (use-package tree-sitter-langs) (use-package tree-sitter-debug) (use-package tree-sitter-query)) The README on the use-package GitHub page explains all the special :\u0026lt;section\u0026gt; bits, but in essence this is a clean way of saying:\nRun (global-tree-sitter-mode) on startup Turn on tree-sitter-hl-mode whenever we boot up tree-sitter Configure tree-sitter to also use four other useful packages There are many, many capabilities bundled into use-package, and even very minimal configurations will tend to include it, because of the brevity it brings to advanced package configuration.\nUpdates 2022-08-19: Recommend against the MELPA-stable repository, after a bit of research 1 For our resident Microsoft Windows users - I\u0026#39;ll be using Unix-style paths, which means ~ is the home directory, like C:\\Users\\Robb, and / as path separators. Fret not, as Emacs will understand this style of pathing and the ~, even on Windows\n2 It\u0026#39;s also likely that its predecessor TECO from the 60\u0026#39;s was developed on a terminal on which the \u0026#34;Ctrl\u0026#34; key was located just to the left of a\n3 Such as packer.nvim (inspired by use-package) or vim-plug\n4 I\u0026#39;ll use another article to cover specific, intersting configuration on a per-package basis\n","date":"7 August 2022","permalink":"/posts/005_emacs_1_packages/","section":"Posts","summary":"Philosophy This is the first part of a series in building an emacs configuration around the data science toolkit, which I introduced in another article.","title":"Emacs Part 1: The Keyboard and Packages"},{"content":" I\u0026#39;m pretty happy with my (neo)vim setup. Wielding it, I can walk into most code bases and be useful. There comes a point, though, where we hit a wall, look at Jupyter or VSCode, and think \u0026#34;damn, that actually is pretty useful.\u0026#34; This started happening more frequently as my workflow transitioned to terminal-based tooling for Python and away from Jupyter and PyCharm. Suddenly, I found myself lacking some of the basics we need to do useful data science, like rich text (math) and images (plots). I don\u0026#39;t want to give up my precious all-about-me editing experience, though, and if I can avoid proprietary software, I will.\nLike most fledgling data scientists, my journey began on a Jupyter notebook, followed by JupyterLab, when it came out. After learning that \u0026#34;hey, I can make my own libraries too!\u0026#34;, I found Spyder from the Anaconda ecosystem, jumped to PyCharm for a while, all the while using a dash of Vim on the side. Recently, I went all-in on a lua configuration for Neovim, and that\u0026#39;s been my home for the last couple years now, except for when I just need a notebook. Typically I still turn to JupyterLab when I need a literate programming environment, with access to plotting inline with code. Sometimes a notebook is just the right thing for the job. Other times, I need a text editor and a language server for some back-end work. I want a free/libre environment that supports both of these, and right now I don\u0026#39;t think the options are great.\nSpyder is probably the closest right now, but I have the least experience with it. The messaging from their website is wholly python-centric, though, and I\u0026#39;m looking for a much more generic tool. I also have no idea how well it handles remote project development VSCode is currently the gold standard in terms of \u0026#34;just working\u0026#34; out of the box. I haven\u0026#39;t seen anything integrate with remote development, including Jupyter notebooks, as well as this one does. It doesn\u0026#39;t meet the \u0026#34;libre\u0026#34; requirement, though, and Microsoft has no plans for opening its pylance server either PyCharm is a behemoth powerhouse for working on a local codebase. It absolutely falls apart when trying to work on remote projects Vim and Neovim are terminal editors, and by their very nature are not designed for displaying images. Really, they are designed to address the physical act of editing text, and leave the other components of your development workflow to be integrated some other way (i.e. running commands in one tmux window and vim in the other) I think Pluto is incredibly slick, and I wish more notebooking environments operated like it So where does this leave us? Emacs has:\nRich text and image display (as a GUI program) Inline literate programming via org-mode, and many Jupyter integration projects Support for basically every programming language on the planet Tree-sitter and Language Server Protocol (LSP) support, with the option to choose our own server A fully featured general programming language for configuration and extension (Emacs LISP) An enormous integrated help and documentation system Cross-platform to Windows, Linux, and macOS Libre license (GNU GPL 3.0) Built-in remote development support (via TRAMP) Terminal emulation via any of `M-x term`, `M-x shell`, or `M-x eshell` All that to say Emacs is a tempting offer, and I\u0026#39;m going to try diving in so that you don\u0026#39;t have to. The plan is to build an emacs configuration from scratch with the goal of a data science workstation in mind, and will be aimed at folks like me - people who want to learn how this crazy emacs monster works, and are maybe a strong Vimmer, but haven\u0026#39;t had the chance to really sit down an learn emacs yet. As such, this will be more than a \u0026#34;follow-along\u0026#34; configuration guide; rather I\u0026#39;m aiming to dig into the details, and weigh the merits of choosing one thing over another, especially as they compare against their (neo)vim counterparts. As long as I can keep up, the plan is one post a week, focusing on a single component to integrate, such as LSP, auto-complete, remote workflow, notebooks, packaging, Windows-specific forays, and so on. I may reference back to this article and change it up a bit as we learn more, so that this article can be the one-stop-shop on justification for \u0026#34;why emacs\u0026#34;?\nAt the end of the day, though, this whole process is largely to document my own learning process, so I can come back and say \u0026#34;why on earth did I do it this way? Oh, that\u0026#39;s right…\u0026#34; There are already an enormous number of excellent learning materials out there for picking up emacs, so my recommendation for other people like me is to also give them a shot:\nThe official Emacs manual An Introduction to Programming in Emacs Lisp Mastering Emacs ","date":"31 July 2022","permalink":"/posts/004_emacs_start/","section":"Posts","summary":"I\u0026#39;m pretty happy with my (neo)vim setup.","title":"Emacs Has Been Waiting for Data Science"},{"content":"Some time ago, I saw this fantastic talk by Sandy Metz on favoring object composition over inheritance.\nAt the 17:00 mark, she introduces the cumulative folk tale This Is the House That Jack Built, the first few lines of which looks like this:\nThis is the house that Jack built. This is the rat that ate the cheese that lay in the house that Jack built. This is the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. This is the cow with the crumpled horn that tossed the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. This is the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. \u0026hellip;\nFor the rest of the talk, she focuses on the problem of programming a class that can perform two transformations on the poem:\nRandomize the order in which lines are added, so that the \u0026ldquo;rat that ate the cheese\u0026rdquo; might come before the \u0026ldquo;maiden all forlorn\u0026rdquo; \u0026ldquo;Echo\u0026rdquo; each line, so that we get \u0026ldquo;the cow with the crumpled horn that tossed the cow with the crumpled horn\u0026rdquo; That is, a user should be able to instantiate a class that can recite the poem verbatim, recite a randomized poem, recite an echoed poem, or recite a poem that\u0026rsquo;s both random and echoed. What makes this interesting as a data scientist or engineer is that she\u0026rsquo;s tackling the problem of object composition in the context of a data pipeline. So in this article, I\u0026rsquo;m going to cover Python solutions to this problem in three broad strokes:\nWhat does a literal translation of the object-oriented version look like in Python, while still remaining \u0026ldquo;pythonic?\u0026rdquo; How can we extend the code to swap the order in which transformations happen? How can we simplify the user experience by translating the logic to pure functions? On point 3 - I tend to believe a functional style, where data is immutable and pure functions create new, transformed data is usually the right approach to any system that\u0026rsquo;s \u0026ldquo;data first\u0026rdquo;. It also reduces overhead for most users by avoiding the introduction of a new object type. That\u0026rsquo;s not always a good thing, but specifically in the context of a Python end user, this means they need only remember the recite() function, and not both the House() object and its recite() method. While not strictly a functional language, Python does offer some key functional components, namely first-class functions and currying, so we\u0026rsquo;ll take a look at how those can still be useful even when building a more object-centric solution.\nThe Object-Oriented Python Solution to RandomEchoHouse # This article uses Python 3.10 syntax. To run examples on older versions of Python, some adjustments to the type annotations are required. First, let\u0026rsquo;s set up a new Python file random_echo.py with some imports we\u0026rsquo;ll need, the poem\u0026rsquo;s data as a module constant1, and a couple type aliases to make future code more readable:\n#!/usr/bin/env python3 import random from typing import Callable # requires pip install of `more-itertools` from more_itertools import always_iterable Poem = list[str] PoemTransform = Callable[[Poem], Poem] HOUSE_POEM = [ \u0026#34;the horse and the hound and the horn that belonged to\u0026#34;, \u0026#34;the farmer sowing his corn that kept\u0026#34;, \u0026#34;the rooster that crowed in the morn that woke\u0026#34;, \u0026#34;the judge all shaven and shorn that married\u0026#34;, \u0026#34;the man all tattered and torn that kissed\u0026#34;, \u0026#34;the maiden all forlorn that milked\u0026#34;, \u0026#34;the cow with the crumpled horn that tossed\u0026#34;, \u0026#34;the dog that worried the cat that chased\u0026#34;, \u0026#34;the rat that ate the cheese that lay in\u0026#34;, \u0026#34;the house that Jack built\u0026#34;, ] So from now on, a Poem is any list of string values, just like HOUSE_POEM, and a PoemTransform is any function that takes in a Poem as its only argument and returns a Poem.\nOur objective is to produce variations on this poem using a single interface:\nRecite the original poem Recite a version of the poem in random order Recite a version of the poem with each line \u0026ldquo;echoed\u0026rdquo; (duplicated) Recite the poem both in random order and with duplicated lines There are three possible transformations of a poem - we echo it, we randomize it, or we do nothing. The fourth option is a composition of the two other non-identity transformations, so we don\u0026rsquo;t consider it a separate object. Ruby has a much stricter object-oriented paradigm than Python, so Sandy\u0026rsquo;s example uses a dedicated class with a single method for each role. Such ceremony isn\u0026rsquo;t required in Python, though. We can just define a pure function for each processing step.\n# --snip-- def identity(x: Any) -\u0026gt; Any: return x def random_order(poem: Poem, random_seed: int = 42) -\u0026gt; Poem: random.seed(random_seed) return random.sample(poem, len(poem)) def echo_format(poem: Poem) -\u0026gt; Poem: return [f\u0026#34;{line} {line}\u0026#34; for line in poem] To start, let\u0026rsquo;s look at a literal translation of Sandy\u0026rsquo;s House class into Python:\n# --snip-- class House: def __init__( self, order: PoemTransform = identity, fmt: PoemTransform = identity, ): self.lines = order(fmt(HOUSE_POEM)) def recite(self, stanza: int | Sequence[int] | None = None) -\u0026gt; None: if stanza is None: indices = range(len(self.lines)) else: indices = always_iterable(stanza) for i in indices: stanza_lines = self.lines[-(i + 1) :] joined = \u0026#34;\\n\u0026#34;.join(stanza_lines) print(\u0026#34;This is \u0026#34;, joined, \u0026#34;.\u0026#34;, sep=\u0026#34;\u0026#34;, end=\u0026#34;\\n\\n\u0026#34;) Anyone who\u0026rsquo;s seen Jack Diederich\u0026rsquo;s Stop Writing Classes should notice a red flag here. We have two methods, one of which is __init__(), so that means this class is really just an obfuscated call to a recite function. In the next section we\u0026rsquo;ll refactor this down to a flatter API, but for the moment let\u0026rsquo;s just examine how this class works by dropping into an interactive session:\n$ python3 -i random_echo.py \u0026gt;\u0026gt;\u0026gt; house = House() \u0026gt;\u0026gt;\u0026gt; house.recite() # the whole tale This is the house that Jack built. ... the rat that ate the cheese that lay in the house that Jack built. \u0026gt;\u0026gt;\u0026gt; house.recite(2) # just stanza 2 This is the dog that worried the cat that chased the rat that ate the cheese that lay in the house that Jack built. \u0026gt;\u0026gt;\u0026gt; # We can \u0026#34;plug in\u0026#34; any function for the `order` role \u0026gt;\u0026gt;\u0026gt; random_house = House(order=random_order) \u0026gt;\u0026gt;\u0026gt; random_house.recite(4) This is the maiden all forlorn that milked the rat that ate the cheese that lay in the rooster that crowed in the morn that woke the judge all shaven and shorn that married the dog that worried the cat that chased. \u0026gt;\u0026gt;\u0026gt; # Similarly for the `fmt` role \u0026gt;\u0026gt;\u0026gt; echo_house = House(fmt=echo_format) \u0026gt;\u0026gt;\u0026gt; echo_house.recite(3) This is the cow with the crumpled horn that tossed the cow with the crumpled horn that tossed the dog that worried the cat that chased the dog that worried the cat that chased the rat that ate the cheese that lay in the rat that ate the cheese that lay in the house that Jack built the house that Jack built. \u0026gt;\u0026gt;\u0026gt; # Including both at once \u0026gt;\u0026gt;\u0026gt; random_echo_house = House(order=random_order, fmt=echo_format) \u0026gt;\u0026gt;\u0026gt; random_echo_house.recite() This is the dog that ... Feature Request: Line Numbers # \u0026ldquo;Can we get line numbers before each of the chunks even when randomizing? It makes it easier to read.\u0026rdquo;\nEasy. We just make a new formatter:\ndef linum_format(poem: Poem) -\u0026gt; Poem: return [f\u0026#34;{i}: {line}\u0026#34; for i, line in enumerate(poem)] random_line_house = House(fmt=linum_format, order=random_order) random_line_house.recite(9) # This is 0: the farmer sowing his corn that kept # 1: the horse and the hound and the horn that belonged to # 2: the man all tattered and torn that kissed # ... \u0026ldquo;We noticed something,\u0026rdquo; our client says. \u0026ldquo;It looks like the randomization happens before the line numbers are made. What we really wanted was to keep the original line numbers, so we know what happened. But that\u0026rsquo;s fine, we were able to just swap the two functions and now it\u0026rsquo;s working great!\u0026rdquo;\nTo our horror, we open their code and see this:\nmyhouse = House(fmt=random_order, order=linum_format) myhouse.recite(9) # This is 1: the farmer sowing his corn that kept # 0: the horse and the hound and the horn that belonged to # 4: the man all tattered and torn that kissed # ... And even worse:\ndef mynumbers(p): return linum_format(echo_format(x)) myhouse2 = House(order=mynumbers, fmt=random_order) Uh oh. We baked the ordering into House.__init__, and because we didn\u0026rsquo;t provide a generic enough API for composing functions, it\u0026rsquo;s getting used in a way we didn\u0026rsquo;t expect, which will certainly put mental burden on future maintainers as well. We now have three options:\nForce an API change that prevents the situation above Deprecate the House class and point users to a newer, better function Open up the public interface with a little more flexibility, at the expense of directly representing business logic In my experience, #1 is rarely prudent. # 2 may or may not be appropriate, depending on what the actual product is. However, as library authors it\u0026rsquo;s our responsibility to keep the public interface as consistent as possible over time. So let\u0026rsquo;s explore what it means to abstract our code a little to achieve better \u0026ldquo;pluggability\u0026rdquo;:\nFunctions First # I want to take it all the way back to the drawing board. What\u0026rsquo;s the simplest part we can keep the same? Probably all of linum_format, echo_format, and random_order remain unchanged.\nFollowing that, we need a small adjustment to the recite function: given a Poem, just print it out on the correct stanza.\n#!/usr/bin/env python3 # Identical to the `House` class version, but doesn\u0026#39;t # rely on stateful `self.lines` def recite(poem: Poem, stanza: int| Sequence[int] | None = None) -\u0026gt; None: if stanza is None: indices = range(len(poem)) else: indices = always_iterable(stanza) for i in indices: stanza_lines = poem[-(i + 1) :] joined = \u0026#34;\\n\u0026#34;.join(stanza_lines) print(\u0026#34;This is \u0026#34;, joined, \u0026#34;.\u0026#34;, sep=\u0026#34;\u0026#34;, end=\u0026#34;\\n\\n\u0026#34;) With that totally compartmentalized, now we can focus entirely on the composition part.\nNotice that the House class utilized one stateful object - the transformed poem after applying the order and fmt functions. This got stored in the self.lines attribute, and subsequent calls for specific stanzas didn\u0026rsquo;t have to re-transform the poem. _recite_stanza just read the data and printed it. Depending on how expensive we expect the functions to be, we can either keep this behavior, or switch to a version where we transform the poem each time we pass it in to recite. All in all, though, it\u0026rsquo;s impossible for us as library authors to predict which of these cases our users will be bound to, so it\u0026rsquo;s actually a poor design in the first place to force this data to persist in memory without their consent. The recite function now takes any poem. So we can pass in a transient, quickly garbage-collected one like this:\nrecite(echo_format(HOUSE_POEM)) Or collect a transformed version, persist it, and pass that in:\nrandom_echo_house = echo_format(random_order(HOUSE_POEM)) recite(random_echo_house) In the end, only the developers implementing the data (HOUSE_POEM) and the functions that act on it (random_order and echo_format) will know which of the two approaches above is appropriate, so we should give them that freedom.\nNext, we have the problem of arbitrary function composition. It\u0026rsquo;s a bit clunky to manually produce each composition like this:\ndef random_echo(poem: Poem) -\u0026gt; Poem: return echo_format(random_order(poem)) def echo_linum(poem: Poem) -\u0026gt; Poem: return linum_format(echo_format(poem)) # ... likewise for other combinations Can we provide a generic factory that lets users define a new transformation pipeline on the fly? How about a function that takes a variable set of functions as arguments, and returns a PoemTransform?\ndef compose(*funcs: PoemTransform) -\u0026gt; PoemTransform: def pipeline(poem: Poem) -\u0026gt; Poem: for f in funcs: poem = f(poem) return poem return pipeline linum_echo_random = compose(linum_format, echo_format, random_order) recite(linum_echo_random(HOUSE_POEM), stanza=9) # This is 1: the farmer sowing his corn that kept 1: the farmer sowing his corn that kept # 0: the horse and the hound and the horn that belonged to 0: the horse and the hound and the horn that belonged to # 4: the man all tattered and torn that kissed 4: the man all tattered and torn that kissed # ... It might not look like much, but because most programmers prefer reading function application from left-to-right rather than inside-out (mathematicians being the notable holdout here), some may prefer this. If our functions had varying input and output types, I would keep the slightly clunkier version where we explicitly compose functions via def and return f1(f2(...)) solely for the reason of having the pyright static type checker ensure that I\u0026rsquo;ve chained inputs and outputs correctly. Since all of our functions are PoemTransform, though, we don\u0026rsquo;t need to worry about type checking within the compose function. That is, all the input and output types are Poem, so the resulting function chain is safe.\nA note on mixins # At around the 23:35 mark, an audience member shouts out \u0026ldquo;use multiple inheritance!\u0026rdquo; to which Sandy says \u0026ldquo;just stop that - we\u0026rsquo;re not using multiple inheritance here, it\u0026rsquo;s not the right solution for this problem.\u0026rdquo;\nIt\u0026rsquo;s interesting to note that scikit-learn does exactly this as a way of composing model behavior. Every ridge regression is a regression, after all, and it will always need the attributes that come with a regression, such as its coefficient of determination and fit() method.\nPython doesn\u0026rsquo;t actually have \u0026ldquo;constants\u0026rdquo;, but by convention an all-uppercase variable is meant to signify it\u0026rsquo;s supposed to be constant\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"4 May 2022","permalink":"/posts/003_random_echo_house/","section":"Posts","summary":"Some time ago, I saw this fantastic talk by Sandy Metz on favoring object composition over inheritance.","title":"Data Pipelines as Function Composition"},{"content":"It took me a while to admit it, but with a little upfront time investment, the command line is probably the fastest way to get most tasks accomplished. For me, most tasks means short, one-off, common file operations, such as:\nTrying to find that one damn file that\u0026rsquo;s nested somewhere down all those folders Figuring out what version(s) of python I have installed, and making new virtual environments Downloading files from a link and unzipping the results Examining and editing the contents of a file Can an IDE or VScode offer all this to me? Yup. Those tools are awesome, but when I\u0026rsquo;m on the phone with someone, and they say \u0026ldquo;hey, can you pull up that one thing real fast?\u0026rdquo; I don\u0026rsquo;t have time to boot JetBrains, nor do I want to dig through VScode menus. I pop open the terminal, fuzzy search where I need to go, and hit the file with vim if it\u0026rsquo;s text or open1 if it\u0026rsquo;s something like Excel or PowerPoint. The process of getting that file open from a cold start is around 10 seconds. Here\u0026rsquo;s an example where I\u0026rsquo;m looking for a copy of the Python logo:\nfzf here indexed over a million files on my computer, but because I was able to find it using just a few key words I knew were in the file path or name.\nLet\u0026rsquo;s say it takes on average around 30 seconds to find a file clicking through a file manager.2 That\u0026rsquo;s 20 seconds of savings per file. Suppose we only look for around a dozen files like this per work day. Back of napkin math tells us:\n20 seconds/file * 12 files/day * 5 days/wk / 3600 s/hr ------------- 0.33 hours/wk So assuming you work with roughly the numbers above, one hour of getting comfortable with fzf will pay for itself in under three weeks. Scale this against the number of files you open, and how deeply nested down a mounted SharePoint folder they might be, and the dividends are much faster. If your work looks anything like mine, you\u0026rsquo;re sifting through at least several dozen spreadsheets, presentations, and source code files every day, many of them with similar names but with v3.pptx or v_FINAL.xlsx tacked on the end.\nDoes everyone need to use a fuzzy-finder to find and open files? Certainly not. Some Unix die-hards abhor the use of fuzzy-finders in their workflow, but I just can\u0026rsquo;t seem to get a pure \u0026ldquo;unixy\u0026rdquo; way to work nearly as fast as ctrl+t followed by slapping the keyboard with letters that might be somewhere in that file name.3 I also don\u0026rsquo;t think comments in the spirit of the linked /u/romainl comment have the same set of assumptions about what a \u0026ldquo;typical\u0026rdquo; data science setup looks like. I haven\u0026rsquo;t worked professionally as a website developer, but I have a feeling we work in very different environments. Often I\u0026rsquo;m sitting in front of a data warehouse I\u0026rsquo;ve never connected to before, with 2,000 unique table names, each with possibly 200+ columns. Usually the first thing I do is write a small fzf window that lets me search columns or table names. \u0026ldquo;Are there any features related to customer age? Did an excel sheet from last month make it into the data lake?\u0026rdquo; Interactive, visual feedback as I type these things, followed by a ctrl+u to clear the search bar is way faster than building a pipe with find and/or grep and examining the results each time.\nResources # fzf installation instructions kitty terminal \u0026ndash; This is how I can icat an image in the terminal This is a macOS command. On Windows, just type the name of the file. For Linux I usually am on Gnome desktop, which uses gio open\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI\u0026rsquo;d love some actual hard numbers here, but I\u0026rsquo;d consider this a conservative estimate\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThat said, find . -name \u0026quot;whatever.csv\u0026quot; is definitely still useful in a lot of cases\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"18 April 2022","permalink":"/posts/002_in_defense_of_fuzzy_finders/","section":"Posts","summary":"It took me a while to admit it, but with a little upfront time investment, the command line is probably the fastest way to get most tasks accomplished.","title":"In Defense of Fuzzy Finders"},{"content":"If you aren\u0026rsquo;t regularly wiping and rebuilding your virtual environments, you should be; anyone trying to run your project for the first time will thank you for it. For most folks that\u0026rsquo;s using python -m venv .venv to create a new one, or conda create if you\u0026rsquo;re on the conda stack. I do this so frequently that it became my first bash alias. In sh, bash, and most other shells, there\u0026rsquo;s more than one way to make longer commands shorter, the easiest of which is the alias:\nalias so=\u0026#34;source .venv/bin/activate\u0026#34; After running this, when we use so as the first command, it will be replaced with the text source .venv/bin/activate. Remembering to just type so once I cd to a project is much easier to remember and type quickly. If we don\u0026rsquo;t already have an environment, we usually have to create it:\nalias new-venv=\u0026#34;python -m venv .venv\u0026#34; To chain two operations together in bash, we use \u0026amp;\u0026amp; to allow the second part to run only if the first one succeeded:\nnew-venv \u0026amp;\u0026amp; so Beyond that, we usually have to upgrade pip in the new environment\nnew-venv \u0026amp;\u0026amp; so \u0026amp;\u0026amp; pip install --upgrade pip wheel And this chain is so common, I actually have the entire thing under the new-venv name, but as a bash function so it can take arguments:\nnew-venv() { local name=${1:-.venv} local python_version=${2:-3} python${python_version} -m venv $name \\ \u0026amp;\u0026amp; source $name/bin/activate \\ \u0026amp;\u0026amp; python3 -m pip install --upgrade pip wheel } The usage of this function is like this:\nnew-venv [NAME] [PYTHON_VERSION] with both arguments optional. The voodoo magic on the first two lines inside the function just says:\nAssign the value of the first argument to the name variable, and set it to \u0026ldquo;.venv\u0026rdquo; if nothing is passed in Assign the value of the second parameter to the python_version variable, and set it to \u0026ldquo;3\u0026rdquo; if nothing is passed in Physical savings might only be a few letters, but there\u0026rsquo;s a real cognitive benefit to building out your most common operations as aliases or functions. You can think at higher levels of operation, with four to five commands clicked together instead of just the current one. Often I go \u0026ldquo;I call uncle! Let\u0026rsquo;s try with a fresh environment\u0026rdquo;\ndeactivate \u0026amp;\u0026amp; rm -rf .venv \u0026amp;\u0026amp; new-venv \u0026amp;\u0026amp; poetry install Raymond Hettinger says we have a buffer in our mind of \u0026ldquo;about five things, plus or minus two\u0026rdquo;. By reducing the process above to only four steps, even on a bad day I can remember how to do this.\nTo make sure these aliases/functions are available every time you log in, add them to your \u0026ldquo;rc\u0026rdquo; file. For most folks that\u0026rsquo;s ~/.bashrc, but fish users would use funced and funcsave, zsh users have ~/.zshrc, and on Windows there\u0026rsquo;s a host of options (I wouldn\u0026rsquo;t try all this in cmd).\nI actually like the funced idea from fish a lot, so I use something similar. This allows me to edit any function in my ~/.bash_functions folder, which is then loaded up using load-funcs (also a function), and that is what gets executed by my ~/.bashrc. This gives me the chance to very quickly save useful snippets like what\u0026rsquo;s above for later. In particular, instead of looking up the right invocation to install poetry every time, I just tucked it away into the install-poetry function when I first ran it, and now it\u0026rsquo;s ready for me everywhere I take my dotfiles.\n","date":"6 April 2022","permalink":"/posts/001_faster_pyvenv/","section":"Posts","summary":"If you aren\u0026rsquo;t regularly wiping and rebuilding your virtual environments, you should be; anyone trying to run your project for the first time will thank you for it.","title":"Manage Python Environments Faster With Aliases and Functions"},{"content":"In data science and engineering we tend to think in \u0026ldquo;DAGs\u0026rdquo; (directed acyclic graphs), which just means \u0026ldquo;to make this report, we first have to build this other thing, and to build that thing, we have to run these two queries, and so on. It decomposes the process of building data and artifacts like visualizations or data exports into smaller, individual chunks.\nThere are a lot of contenders in the market for selling solutions to this exact scenario, and each one solves it a little differently. Right now the hot thing is dbt, but before that we had airflow, dagster, prefect, argo, and a host of others that all were built to operate DAGs at scale on different platforms. For large, mission-critical data pipelines these can provide a lot of value, but the truth is that as data scientists, most of us don\u0026rsquo;t need something this heavy. Most projects I see really just need some way of defining the links between \u0026ldquo;scrapbook output\u0026rdquo;. Maybe it\u0026rsquo;s a jupyter notebook, or a python script, or some queries that have to happen in a particular order based on an updated warehouse feed.\nMoreover, there are some reasons you might not want to try adding an entire workflow management ecosystem into your stack. Maybe:\nYou can\u0026rsquo;t get permission for a new install You don\u0026rsquo;t want to force another install on your end users or coworkers You don\u0026rsquo;t want more transitive dependencies entering the picture You don\u0026rsquo;t like someone trying to sell their cloud solution on top of the free tier offering to you make was born from a history of compiling C programs on Unix machines in the 70\u0026rsquo;s, but it\u0026rsquo;s completely agnostic to language choice. It\u0026rsquo;s job is to translate targets and prerequisites into a DAG, and incrementally build only the parts it needs to when any of the source files change. Given that, why would I choose Make over one of the more modern alternatives?\nThe commands are elegant - I enjoy the language of make report.xlsx Parallel execution is built in and easy to turn on or off It\u0026rsquo;s installed on damn near everything,1 and has proven over the last 50 years to be a shark, not a dinosaur It\u0026rsquo;s a \u0026ldquo;small\u0026rdquo; program. You can get through the documentation and start creating useful software in a couple hours. Like SQL, Make is declarative. We describe the result, and let the program optimize the route by which we get there. Creating a simple project with make and python # I\u0026rsquo;m going to use a distilled example of a recent project I built using just a Makefile, some python, and a little SQL. By the end of this my hope is to show that simple tools can be efficient and reliable, and avoid the overhead of learning, installing, configuring, and inevitably debugging something more complex.2 Ultimately, I wanted to hand this project off in such a way that any of my teammates could maintain it if I was unavailable, so it had to be short, and stick to the tools I know they will always have installed.\nOur goal is to produce an Excel file for executive consumption that has a meaningful summary of some data pulled out of our analytics warehouse. Overall, it\u0026rsquo;ll look a little like this:\nbase queries --\u0026gt; summary CSVs --\u0026gt; (report.xlsx, diagrams for powerpoint) The \u0026ldquo;base\u0026rdquo; queries might look a lot like temporary tables or common table expressions (CTEs, or those blocks you see in WITH statements), but we\u0026rsquo;ve broken them into several, separate queries. We\u0026rsquo;re plopping those summarized results into some flat files so that we can examine the results with our favorite tools like pandas or awk. We\u0026rsquo;ll then take all those flat results and produce deliverables from them, like charts and an excel file.\nmyguy is always there for me, so that\u0026rsquo;s the name of our project, and its basic structure looks like this:\n. ├── config.yml ├── Makefile ├── myguy.py ├── README.md └── sql ├── this_quarter_sales.sql ├── model_forecast.sql └── customer_disposition.sql We will execute each file in the sql/ directory as a query we execute and then locally cache the results as CSVs. Later we\u0026rsquo;ll discuss how to handle the case where all our queries are handled remotely, and don\u0026rsquo;t create local files, such as running CREATE TABLE AS (ctas) queries prior to building the report, but for now we\u0026rsquo;ll keep it simple: query \u0026ndash;\u0026gt; csv on computer.\nOur goal is to make reproducing this report dead simple. I should only have to run this command to rebuild the report at any time:\nmake report.xlsx The cookbook that provides this rule is the Makefile.\n# Makefile report.xlsx: myguy.py python -m myguy build-report If this is your first time seeing make, there are a few terms to know:\nreport.xlsx - this is the target of the rule. It is the file produced by running make report.xlsx myguy.py - the prerequisite of report.xlsx. It has to exist in order to create the excel file. If this python file\u0026rsquo;s contents have changed recently, then that\u0026rsquo;s an indication that report.xlsx may also change. python -m myguy build-report - this is the recipe that Make runs when you issue the command make report.xlsx. I am invoking python with the -m, or \u0026ldquo;run module as main\u0026rdquo; flag in case we ever refactor our single .py file into a module, like myguy/__init__.py with its complementary \u0026ldquo;dunder main\u0026rdquo; myguy/__main__.py. Our main entry point will be in the python module. This will handle the program runtime for executing queries or doing some pandas hackery.\n# myguy.py from pathlib import Path from time import sleep import click import pandas as pd @click.group() def cli(): pass @cli.command() @click.option( \u0026#34;-o\u0026#34;, \u0026#34;--output\u0026#34;, help=\u0026#34;Write to file\u0026#34;, default=f\u0026#34;{BUILD_DIR}/report.xlsx\u0026#34;, show_default=True, ) def build_report(output: str): \u0026#34;\u0026#34;\u0026#34; Generate a new Excel workbook and save it locally. \u0026#34;\u0026#34;\u0026#34; # Suppose this produces, you know, useful data pd.DataFrame(dict(a=range(3), b=list(\u0026#34;abc\u0026#34;))).to_excel(output, index=False) sleep(2) print(f\u0026#34;Saved report to {output}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: cli() I think click is just great, and provides me with a lot of zen writing a command line interface (CLI) compared to argparse, although you could achieve everything I\u0026rsquo;m doing in this article equally well with argparse. In this script we create a cli group because we\u0026rsquo;ll eventually add more commands to it. The build_report function just replicates a process that takes a couple seconds before it outputs a file to build/report.xlsx.\nIt takes very little code to get a pleasant command line experience with nested commands. Here\u0026rsquo;s a quick example of using it after adding another command called query, which we\u0026rsquo;ll get to in a moment:\nHowever, if we try building our report right now with make report.xlsx, we get a FileNotFoundError: [Errno 2] No such file or directory: 'build/report.xlsx', and that\u0026rsquo;s because we need to make sure the build directory exists before running this command. We could handle that in the python with a few lines, but why not have our dependency management tool, make, do it for us?\n# Makefile build: mkdir -p build report.xlsx: myguy.py | build python -m myguy build-report Now our make report.xlsx works just fine, and we get a new directory build with our empty report in it. Normally we won\u0026rsquo;t need the |, but in this case it declares that the build rule should only be run once, even if we have other targets with build as a prerequisite.3 If we rerun make report.xlsx, it doesn\u0026rsquo;t try to create that directory again, because it already exists.\nWe do have one other problem though: if we re-run the python code, it will overwrite our report, even if nothing has changed. Instead, we should get a message saying make: 'report.xlsx' is up to date. This is happening because our target is report.xlsx instead of build/report.xlsx, so make looks in the current directory, sees that there\u0026rsquo;s no report.xlsx and therefore runs the recipe. I don\u0026rsquo;t want to write make build/report.xlsx, so what we\u0026rsquo;ll do is set up make to automatically look in our build and sql directories for files by setting the VPATH variable:\n# Makefile BUILDDIR := build SQLDIR := sql VPATH := $(SQLDIR):$(TARGETDIR) $(BUILDDIR): mkdir -p $(BUILDDIR) report.xlsx: myguy.py | $(BULDDIR) python -m myguy build-report By doing this, we can just issue make report.xlsx instead of make build/report.xlsx. Setting build to a variable (referenced via $(BUILDDIR)) allows us to change up the build directory on a whim, should we need to.\nNext, we need to structure the rules that handle our queries, so let\u0026rsquo;s add a generic method for doing exactly that, given the path to a sql file.\n# myguy.py, cont. from datetime import datetime # ...other content same as before... BUILD_DIR = \u0026#34;build\u0026#34; @cli.command() @click.argument(\u0026#34;path\u0026#34;) def query(path: str): \u0026#34;\u0026#34;\u0026#34; Issue the query located at `path` to the database, and write the results to a similarly-named CSV in the `build` directory. \\b Examples -------- This command will produce a new file foobar.csv in the `myguy.BUILD_DIR` directory: $ python -m myguy query sql/foobar.sql \u0026#34;\u0026#34;\u0026#34; # Hey look, more fake code for an article about querying data sleep(2) destination = Path(BUILD_DIR) / Path(path).with_suffix(\u0026#34;.csv\u0026#34;).name ( pd.DataFrame( dict(time_updated=[datetime.now()]) ) .to_csv(destination, index=False) ) print(f\u0026#34;Finished query for {path} and wrote results to {destination}\u0026#34;) Again, imagine that the \u0026ldquo;sleep\u0026rdquo; we\u0026rsquo;re doing here is some body of actual code that fetches results from the database. We also don\u0026rsquo;t need pandas for something as banal as touching a csv with today\u0026rsquo;s date, but it\u0026rsquo;s there to replicate the very common use case of pd.read_sql -\u0026gt; to_csv, which is nearly always the most efficient way to write a program that acquires a database connection, queries it, and writes the results to a csv for analytics-scale work in python like this.\nWe\u0026rsquo;ve also refactored out the destination build directory into a variable, so we can have the make script grab that automatically using the shell built-in:\n# Makefile BUILDDIR := $(shell python -c \u0026#39;import myguy; print(myguy.BUILD_DIR)\u0026#39;) This technique is also useful for having builds that depend on things like myguy.__version__, if it exists. With the python in place, we need to set up our recipes that run the queries. A naive first approach might look like this:\n# Makefile, cont. # ... same as above ... this_quarter_sales.csv: this_quarter_sales.sql python -m myguy query sql/this_quarter_sales.sql model_forecast.csv: model_forecast.sql python -m myguy query sql/model_forecast.sql customer_disposition.csv: customer_disposition.sql python -m myguy query sql/customer_disposition.sql That\u0026rsquo;s a lot of repetition, so our programmer instincts should kick in here and tell us that \u0026ldquo;there must be a better way!\u0026rdquo;4. Make can handle this using implicit rules. We specify a pattern like this, and Make will do all the hard work of connecting the files together:\n%.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; This takes care of all three rules at once.\nThe % is a wildcard - it matches anything and our rules here say that \u0026ldquo;if we\u0026rsquo;re going to build a .csv, then it has a similarly-named .sql file as a prerequisite. The @ at the start of the recipe suppresses echoing of the command when Make runs it The $\u0026lt; is an automatic variable that stands for the first prerequisite. In our case, that will be the full path to the .sql file we are passing into the query function we previously wrote. Since myguy.py is the \u0026ldquo;source\u0026rdquo; of the running command, that\u0026rsquo;s also a prerequisite the | $(BUILDDIR), as before, says that we have an order-only prerequisite on the build directory, and our earlier rule will ensure mkdir build is run before trying to put output there Now we can issue the same command as our report to build the CSV from each of our queries:\n$ make this_quarter_sales.csv Finished query for sql/this_quarter_sales.sql and wrote results to build/this_quarter_sales.csv We still need to tie all these together so that I don\u0026rsquo;t have to run each command manually - we want to just run make report.xlsx and have it do all the prerequisite queries for us. To accomplish this, we\u0026rsquo;re going to use two more built-ins, wildcard and patsubst to build the prerequisite and target lists, respectively.\nSQLFILES := $(wildcard $(SQLDIR)/*.sql) TARGETS := $(patsubst $(SQLDIR)/%.sql,%.csv,$(SQLFILES)) If we were to echo the contents of these two variables, they would look like this:\n# contents of SQLFILES sql/customer_disposition.sql sql/model_forecast.sql sql/this_quarter_sales.sql # contents of TARGETS customer_disposition.csv model_forecast.csv this_quarter_sales.csv Since our report.xlsx depends on all three of the files in TARGETS, we bind them together in that rule:\n# Makefile # ... other content same as before ... report.xlsx: $(TARGETS) @python -m myguy build-report Note here that we took out the myguy.py and $(BUILDDIR) prerequisites from this rule, since those are coming from our implicit rule on the $(TARGETS). I\u0026rsquo;m also going to add a clean rule for trying things over from a fresh start:\nclean: @[ ! -d $(BUILDDIR) ] || rm -r $(BUILDDIR) Decomposing this into English:\n@ - don\u0026rsquo;t echo this command when it runs. Just run it. [ ! -d $(BUILDDIR) ] || - unless the BUILDDIR is missing, do the next command5 rm -r $(BUILDDIR) - remove the contents of the BUILDDIR recursively Here\u0026rsquo;s where our Makefile is now:\n# Makefile BUILDDIR := $(shell python -c \u0026#39;import myguy; print(myguy.BUILD_DIR)\u0026#39;) SQLDIR := sql VPATH := $(SQLDIR):$(TARGETDIR) SQLFILES := $(wildcard $(SQLDIR)/*.sql) TARGETS := $(patsubst $(SQLDIR)/%.sql,%.csv,$(SQLFILES)) report.xlsx: $(TARGETS) @python -m myguy build-report $(BUILDDIR): mkdir -p $(BUILDDIR) %.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; clean: @[ ! -d $(BUILDDIR) ] || rm -r $(BUILDDIR) So now we can run clean and build the report:\nWe can do better though. Make has parallelism built in, and most of our computers have no trouble running things concurrently. By providing the -j (jobs) flag, we can tell it to do several things at once as long as they don\u0026rsquo;t depend on one another. Since our intermediate queries to CSV fit the bill, they can all run at the same time:\nIt\u0026rsquo;s also possible to enable parallelism by default with the MAKEFLAGS special variable.\n# Makefile MAKEFLAGS := --jobs=$(shell nproc) Adding dependencies between intermediate queries # Let\u0026rsquo;s suppose we add two more queries, and they need to run before our existing queries, because we did a little refactoring of our SQL.\nOur DAG Moreover, let\u0026rsquo;s assume that these two new tables are too large to cache locally in a flat file, and we have to issue a CREATE TABLE AS (ctas) statement to build them first. Not every database will permit you to run a CTAS on it, but imagine this is any process that writes data remotely instead of locally, such as spark writing a parquet file on S3, or submitting a POST request to an endpoint we don\u0026rsquo;t control.\nWe represent this in Make by first writing out the targets and prerequisites with different suffixes. For the remote tables, I\u0026rsquo;ll use the \u0026lsquo;.ctas\u0026rsquo; suffix. I also like to do this in a separate file, dag.mk, so I can hop to its buffer directly in my editor.\n# dag.mk sales_subset.ctas: customer_product.ctas: this_quarter_sales.csv model_forecast.csv: sales_subset.ctas customer_disposition.csv: customer_product.ctas This arrangement forces the completion of sales_subset.csv and customer_product.csv prior to the original three queries. Then in the main MakeFile, we include these contents above the rules that handle .csv files, along with a new rule for handling the remote tables. The %.ctas rule will create an empty target as soon as the query is done, signaling to make when it last completed successfully:\n# Makefile # ... other content the same ... include dag.mk %.csv: %.sql myguy.py | $(BUILDDIR) @python -m myguy query $\u0026lt; %.ctas: %.sql myguy.py | $(BUILDDIR) @python -m myguy ctas $\u0026lt; @touch $(BUILDDIR)/$@ Note that this includes a new command for myguy, so let\u0026rsquo;s add that too:\n# myguy.py @cli.command() @click.argument(\u0026#34;path\u0026#34;) def ctas(path: str): \u0026#34;\u0026#34;\u0026#34; Perform a CREATE TABLE AS statement from the SELECT statement in the given SQL file path. \u0026#34;\u0026#34;\u0026#34; sql_file = Path(path) query = f\u0026#34;CREATE TABLE {sql_file.stem} AS {sql_file.read_text()}\u0026#34; print(query) sleep(3) # imagine the query is running And one last thing - our $(TARGETS) assignment has no way of telling which sql files it should or shouldn\u0026rsquo;t tie to CSVs. The easiest way to make this distinction is to actually just remove $(TARGETS) altogether, and have the dag.mk declare what report.xlsx depends on.\n# dag.mk # ...other contents the same... report.xlsx: this_quarter_sales.csv \\ model_forecast.csv \\ customer_disposition.csv # Makefile report.xlsx: @python -m myguy build-report Make will take care of combining these two rules into a single one. If all the targets are going to have the same suffix, such as .ctas or .csv, then the trick with $(TARGETS) is handy, but adds more complexity than it\u0026rsquo;s worth when mixing target file types.\nAltogether, our dag now looks like this:\nTemplating the SQL with Jinja # To round out some of our feature parity with dbt, we need to add templating to our SQL. It\u0026rsquo;s best if I don\u0026rsquo;t have to think about how the template is injected, I just want a standard place to put stuff and have the python module take care of it. Let\u0026rsquo;s introduce a configuration file:\n# config.yml sales_max_date: \u0026#34;2022-03-01\u0026#34; sales_min_date: \u0026#34;2021-09-01\u0026#34; Presumably, a future analyst will have to come refresh this report for a different set of dates, and we want that configuration readily available to them. The templating engine we\u0026rsquo;ll use is the same on available on dbt, Jinja2. How we integrate it is by intercepting our python code that reads queries and applying the template from the config there. The jinja2 part is a little verbose, but flexible - anything that\u0026rsquo;s in our config will be available to the templated SQL:6\n# myguy.py import yaml import jinja2 # ... other content the same ... BUILD_DIR = \u0026#34;build\u0026#34; PROJECT_DIR = Path(__file__).parent def get_config(): with open(PROJECT_DIR / \u0026#34;config.yml\u0026#34;) as f: config = yaml.safe_load(f) return config # The `str | Path` union type hint is python 3.10 syntax, so watch out if you\u0026#39;re # on an older version! def read_sql_text(path: str | Path) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; Read a SQL file contents and apply jinja templating from this project\u0026#39;s config.yml \u0026#34;\u0026#34;\u0026#34; config = get_config() jinja_loader = jinja2.FileSystemLoader(PROJECT_DIR) jinja_environment = jinja2.Environment(loader=jinja_loader) template = jinja_environment.get_template(str(path)) sql = template.render(**config) return sql And now we use this version of the sql in the ctas and query functions:\n# myguy.py # ...other content the same ... def query(path: str): sql = read_sql_text(path) destination = Path(BUILD_DIR) / Path(path).with_suffix(\u0026#34;.csv\u0026#34;).name # Assuming you have some way of acquiring a database connection with get_connection() as conn: pd.read_sql(sql, conn).to_csv(destination) def ctas(path: str): path = Path(path) sql = f\u0026#34;CREATE TABLE `{path.stem}` AS {read_sql_text(path)}\u0026#34; with get_connection() as conn: conn.execute(sql) Within the SQL itself, we can now reference any of the keys in the config.yml directly:\n# sales_subset.sql SELECT product_id , sales_revenue , sales_units FROM fact_sales WHERE sales_date BETWEEN date(\u0026#39;{{ sales_min_date }}\u0026#39;) AND date(\u0026#39;{{ sales_max_date }}\u0026#39;) I\u0026rsquo;m not here to cover everything you can do with jinja and yaml, since those are already pretty well covered. If you haven\u0026rsquo;t used it before, it\u0026rsquo;s worth looking into. It\u0026rsquo;s very powerful. The looping and conditional constructs can make what would normally be pretty tough with just raw SQL easy. When we issue a make recent_sales.ctas command, it looks like this:\n$ make sales_subset.ctas mkdir -p build CREATE TABLE `sales_subset` AS SELECT product_id , sales_revenue , sales_units FROM fact_sales WHERE sales_date BETWEEN date(\u0026#39;2021-09-01\u0026#39;) AND date(\u0026#39;2022-03-01\u0026#39;) Conclusion # There we have it, a simple little dag system for coordinating our project\u0026rsquo;s deliverables. For a working example of how to implement this project structure, check out the companion repo, which builds a simple analysis on the chinook dataset. This example also includes code that produces .png files for including into presentations and migrates the mypy.py into a fully-fledged, pip-installable module.\nExcept Windows. You\u0026rsquo;ll need to get it via mingw/cygwin or via the Windows subsystem for Linux.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI fully acknowledge the irony here that make is, in fact, a very foreign tool to many data scientists.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThese are called order-only prerequisites\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nI\u0026rsquo;m taking this phrase from Raymond Hettinger, who gives fantastic talks on writing idomatic python. I recommend his beyond PEP8 talk to all levels of developers.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nWe do \u0026ldquo;unless\u0026rdquo; instead of the more familiar \u0026ldquo;if\u0026rdquo; statement, because if we did this: [ -d $(BUILDDIR) ] \u0026amp;\u0026amp; rm -r $(BUILDDIR) the test command [ exits with status 1 when the build directory doesn\u0026rsquo;t exist, and hence the whole pipe exits status 1. Make treats that as a failed recipe, which isn\u0026rsquo;t what we intend. We want it to look like a success both in the case of removing the directory should it exist, and doing nothing if it doesn\u0026rsquo;t.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nYou should be extremely careful about templating like this. This article also uses f-strings for injecting arbitrary code into SQL, which is unacceptable if any of your system is public facing. All of these examples are working under the assumption that we\u0026rsquo;re in a locked-down internal data warehouse, and someone who has access to the system in any way is allowed to issue an arbitrary query.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"6 March 2022","permalink":"/posts/000_make_dag/","section":"Posts","summary":"In data science and engineering we tend to think in \u0026ldquo;DAGs\u0026rdquo; (directed acyclic graphs), which just means \u0026ldquo;to make this report, we first have to build this other thing, and to build that thing, we have to run these two queries, and so on.","title":"Building DAGs with Make, SQL, and python"},{"content":"Why create a new tech blog when so many great ones already exist? In short, because data scientists often get the advice that they should \u0026ldquo;improve their software engineering skills,\u0026rdquo; but the advice they are given on how to do so is usually terrible1. Data science, from a programming perspective, is in a weird place. We aren\u0026rsquo;t quite front end, but we create maps, charts, and plots to display in the browser all the time. We aren\u0026rsquo;t quite back end, yet we write code that targets the file system, databases, and external APIs. And we aren\u0026rsquo;t quite consultants, but still have to be the expert, data-driven decision maker. Data science is not a slow moving field, either, which leaves little space for pausing to reflect on how to write better code.\nI primarily work in a world that uses python, SQL, the standard GNU toolkit (bash, make, vim), and the usual host of data-sciency things that come with all that, like Jupyter and plotly. My posts will be largely targeted at an audience who intends to become more efficient with these tools, or to introduce those who want to become better coders, but aren\u0026rsquo;t sure where to start, to some of the tools that can improve your data science workflow. For about five years now, I\u0026rsquo;ve mentored Data Science team members from writing their first line of code to maintaining 100k \u0026ldquo;source lines of code\u0026rdquo; (SLOC) code bases2. I\u0026rsquo;ve received (and given) many questions prefaced with \u0026ldquo;this may be a stupid question, but\u0026hellip;\u0026rdquo;, and thought that it was about time I wrote down the answers for others to learn from.\nAs of writing, it\u0026rsquo;s February of 2022 and I still see Reddit comments telling new python programmers that requirements.txt is an acceptable form of project dependency management.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSeasoned programming veterans out there might scoff at how low 100k sounds, but for those accustomed to working mainly in Jupyter notebooks, this can be a daunting amount of code.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"26 February 2022","permalink":"/posts/my-first-post/","section":"Posts","summary":"Why create a new tech blog when so many great ones already exist?","title":"Objective"},{"content":" Table of Contents Goals Tangling Inspirations Header Custom Packages OS-specific Configuration Microsoft Windows macOS Linux Theme: ef-themes Gave up on Nord Messed up colors in TTY mode Emacs\u0026rsquo; Built-in Settings dabbrev: swap M-/ and C-M-/ Mode line eldoc Remember minibuffer history Colored output in eshell Recent files menu Fill-column Scroll bar Inhibit splash screen Window margins and fringe Automatically visit symlink sources Indent with spaces by default Render ASCII color escape codes Enable horizontal scrolling with mouse Window management Automatically update buffers when contents change on disk Highlight the line point is on Stop stupid bell Enable split-window dired copying Automatically create matching parens in programming modes Delete whitespace on save Don\u0026rsquo;t wrap lines Relative line numbers Delete region when we yank on top of it Enable mouse in terminal/TTY Compilation Tool bar Ignore risky .dir-locals.el Prefer rg and fd over grep and find Make dired human-readable Confirm when exiting Emacs Smooth scrolling Prefer aspell over ispell Backup and auto-save files Enable narrow-to-region Enable up/downcase-region Keybindings Keybound functions Expanded/better defaults C-c bindings Meta/Alt Modifications F5-F9 Super bindings Consulting completing-read Autocompletion Completion style: Orderless Nicer display of *Completions* Keybindings to interact with *Completions* Minibuffer completion with vertico and marginalia Completion at point with corfu Tramp Language-specific major modes Org-mode SQL Python Markdown AutoHotkey csv-mode Small tool configuration Embark Coterm mode Multiple cursors Visual fill column Magit Change or copy inner/outer eww - search engine and browser diff-hl GNU Plot change-inner Esup: startup time profiling Reloading Emacs Language Server Protocol (LSP) with eglot Start a server for emacsclient Don\u0026rsquo;t forget about these Footer Want to use it? Go ahead!\ngit clone --depth 1 https://github.com/renzmann/.emacs.d ~/.emacs.d All external dependency sources are explicitly included under the elpa/ directory, meaning it\u0026rsquo;s as simple as clone\u0026rsquo;n\u0026rsquo;go. Opening this document under my configuration looks like so:\nIf you prefer a prettier reading experience, check out this same document weaved into my website.\nGoals # I use all three of the major platforms, in both GUI and TTY mode. So this config is designed to work equally well for:\nplatform terminal GUI ssh + TTY Tramp Linux ✅ ✅ ✅ ✅ macOS ✅ ✅ ✅ ✅ Windows ❌ ✅ ❌ ✅ Once I figure out how to get colors working in Windows terminal, I\u0026rsquo;ll update this table. For now though, the 16 bit colors don\u0026rsquo;t react to my color theme, and so on Windows I rely singularly on GUI mode, rather than WSL or emacs inside Alacritty.\nTangling # My configuration is a single literate programming document, which is tangled into the standard init.el and supporting files. This is so I can keep track of all the crazy things I try and explain them inline with the final code I decide to include. Some platforms like GitHub can render this document in a limited way, but to see all the final configuration values I use you will likely have to view this document in Emacs itself.\nWhy use a literate document for my configuration? Basically, as I added more comments and reminders about what some line of code was doing, where I got it from, and why it might be commented out, the prose grew longer than the actual code, and so a change of medium felt prudent. In my case, that\u0026rsquo;s the venerable Org mode, which comes with Emacs and serves as a way to seamlessly weave commentary and code together.\nInspirations # Here\u0026rsquo;s where I put the typical quote about standing on one form of shoulders or another. I steal quite a lot from other, more qualified Emacs community contributors, such as:\nProtesilaos Stavrou Ramón Panadestein Mickey Petersen Header # To comply with the Emacs conventions for libraries, the tangled init.el must have the following header and footer:\n;;; init.el --- Robb\u0026#39;s Emacs configuration -*- lexical-binding: t -*- ;; Copyright (C) 2022 Robert Enzmann ;; Author: Robb Enzmann \u0026lt;robbenzmann@gmail.com\u0026gt; ;; Keywords: internal ;; URL: https://robbmann.io/ ;;; Commentary: ;; A fully fledged, reproducible Emacs configuration ;;; Code: Custom # I prefer having custom modify its own file. This next snippet ensures any package-install or custom edits go to custom.el.\n(setq custom-file (expand-file-name \u0026#34;custom.el\u0026#34; user-emacs-directory)) (when (file-exists-p custom-file) (load custom-file \u0026#39;noerror)) Packages # The initial cornerstone of every Emacs configuration is a decision on package management and configuration. Since use-package will have built-in support in a future Emacs version, I\u0026rsquo;m going to use that along with the built-in package.el. I don\u0026rsquo;t have much reason other than the stability of them being built-in for choosing them.\n(eval-when-compile (package-autoremove) (add-to-list \u0026#39;package-archives \u0026#39;(\u0026#34;melpa\u0026#34; . \u0026#34;https://melpa.org/packages/\u0026#34;) t) (package-install-selected-packages) (require \u0026#39;use-package)) There are also a few hand-made packages I keep around in a special .emacs.d/site-lisp directory.\n(add-to-list \u0026#39;load-path (expand-file-name \u0026#34;site-lisp/\u0026#34; user-emacs-directory)) OS-specific Configuration # Microsoft Windows # Windows, funnily enough, has some trouble registering the Windows key as a usable modifier for Emacs. In fact, s-l will never be an option, since it\u0026rsquo;s handled at the hardware level. I also add a few nice-to-haves, like setting the default shell to pwsh and explicitly pathing out aspell, which I always install with msys64.\n(when (memq system-type \u0026#39;(windows-nt cygwin ms-dos)) ;; Set a better font on Windows (set-face-attribute \u0026#39;default nil :font \u0026#34;Hack NF-12\u0026#34;) ;; Alternate ispell when we\u0026#39;ve got msys on Windows (setq ispell-program-name \u0026#34;aspell.exe\u0026#34;) ;; Set default shell to pwsh ;; (setq explicit-shell-file-name \u0026#34;pwsh\u0026#34;) ;; Enable use of Winkey as super (setq w32-pass-lwindow-to-system nil) (setq w32-lwindow-modifier \u0026#39;super) ; Left Windows key (setq w32-pass-rwindow-to-system nil) (setq w32-rwindow-modifier \u0026#39;super) ; Right Windows key ;; If we want to use a hotkey, we have to also register each ;; combination specifically, like this: (w32-register-hot-key [s-a]) (w32-register-hot-key [s-b]) (w32-register-hot-key [s-c]) (w32-register-hot-key [s-d]) (w32-register-hot-key [s-e]) (w32-register-hot-key [s-f]) (w32-register-hot-key [s-g]) (w32-register-hot-key [s-h]) (w32-register-hot-key [s-i]) (w32-register-hot-key [s-j]) (w32-register-hot-key [s-k]) ;; s-l can NEVER be registered as a key combination, since Windows ;; handles it at a much lower level. ;; (w32-register-hot-key [s-l]) (w32-register-hot-key [s-m]) (w32-register-hot-key [s-n]) (w32-register-hot-key [s-o]) (w32-register-hot-key [s-p]) (w32-register-hot-key [s-q]) (w32-register-hot-key [s-r]) (w32-register-hot-key [s-s]) (w32-register-hot-key [s-t]) (w32-register-hot-key [s-u]) (w32-register-hot-key [s-v]) (w32-register-hot-key [s-w]) (w32-register-hot-key [s-x]) (w32-register-hot-key [s-y]) (w32-register-hot-key [s-z])) macOS # Launching Emacs from the typical application launcher or command-space usually won\u0026rsquo;t capture any modifications to $PATH, typically handled in a file like ~/.profile or ~/.bashrc. So, the main configuration included here is from exec-path-from-shell.\n(when (eq system-type \u0026#39;darwin) ;; Uncomment this if we can\u0026#39;t install Hack Nerd font ;; (set-face-attribute \u0026#39;default nil :font \u0026#34;Menlo-14\u0026#34;) (set-face-attribute \u0026#39;default nil :font \u0026#34;Hack Nerd Font Mono-13\u0026#34;) (exec-path-from-shell-initialize)) Linux # Very little to do here. Emacs on Linux seems to \u0026ldquo;just work\u0026rdquo;.\n(when (eq system-type \u0026#39;gnu/linux) (set-face-attribute \u0026#39;default nil :font \u0026#34;Hack Nerd Font Mono-11\u0026#34;)) Theme: ef-themes # Prot\u0026rsquo;s themes have been reliably legible in nearly every situation. Now with his new ef-themes, they\u0026rsquo;re pretty, too! The ef-themes-headings variable creates larger, bolder headings when in Org-mode, and ef-themes-to-toggle allows me to quickly switch between preset light and dark themes depending on the ambient light of the room I\u0026rsquo;m in.\n(use-package ef-themes :demand t :bind (\u0026#34;C-c m\u0026#34; . ef-themes-toggle) :init (setq ef-themes-headings \u0026#39;((0 . (1.9)) (1 . (1.8)) (2 . (1.7)) (3 . (1.6)) (4 . (1.5)) (5 . (1.4)) ; absence of weight means `bold\u0026#39; (6 . (1.3)) (7 . (1.2)) (t . (1.1)))) (setq ef-themes-to-toggle \u0026#39;(ef-cherie ef-summer)) :config (load-theme \u0026#39;ef-cherie :no-confirm)) I LOVE these themes from ef-themes:\nLight ef-frost ef-light ef-summer Dark ef-cherie ef-trio-dark ef-winter I\u0026rsquo;ve mostly settled on ef-cherie, but sometimes switch to the others above.\nGave up on Nord # It\u0026rsquo;s worth mentioning that I\u0026rsquo;ve tried nord-theme a couple times and found that the legibility or contrast wasn\u0026rsquo;t quite good enough in some modes. Though I still employ Nord for my terminal config in Alacritty and Kitty, where it looks excellent. I also still actively use the nordfox theme in Neovim, which sports a beautiful TreeSitter integration.\nMessed up colors in TTY mode # In TTY mode, I use kitty. I have had trouble with dark blue or red themes in Alacritty, and on Windows terminal. There is probably some hacking I could do on my $TERM variable to try and sort that out, but since it just kinda works in Kitty for me, I haven\u0026rsquo;t spent too much time looking into it.\nEmacs\u0026rsquo; Built-in Settings # My settings for base Emacs. Assuming I ran with no plugins (ala emacs -Q), I would still set most of these by hand at one point or another.\ndabbrev: swap M-/ and C-M-/ # (use-package dabbrev ;; Swap M-/ and C-M-/ :bind ((\u0026#34;M-/\u0026#34; . dabbrev-completion) (\u0026#34;C-M-/\u0026#34; . dabbrev-expand)) ;; Other useful Dabbrev configurations. :custom (dabbrev-ignored-buffer-regexps \u0026#39;(\u0026#34;\\\\.\\\\(?:pdf\\\\|jpe?g\\\\|png\\\\)\\\\\u0026#39;\u0026#34;))) Mode line # It\u0026rsquo;s easy for the mode line to get cluttered once things like Flymake and eglot kick in. When I was starting out, I used to have these two settings:\n(setq display-battery-mode t display-time-day-and-date t) (display-time) After a while I noticed that I\u0026rsquo;m almost never running Emacs in a full screen where I can\u0026rsquo;t see the battery or date in the corner of my window manager, so they were just wasting mode line space. Nowadays I simply opt for column mode and a dimmed mode line in non-selected windows.\n(setq column-number-mode t mode-line-in-non-selected-windows t) eldoc # I find it very distracting when eldoc suddenly pops up and consumes a large part of the screen for docstrings in python.\n(setq eldoc-echo-area-use-multiline-p nil) Remember minibuffer history # Found this on a System Crafters video.\n(setq history-length 25) (savehist-mode 1) Colored output in eshell # Copy-pasted from a stack overflow question.\n(add-hook \u0026#39;eshell-preoutput-filter-functions \u0026#39;ansi-color-apply) Recent files menu # This enables \u0026ldquo;File -\u0026gt; Open Recent\u0026rdquo; from the menu bar, and consult-recent-file.\n(recentf-mode t) Fill-column # Regardless of whether we\u0026rsquo;re doing visual fill or hard fill, I like the default at around 80 characters, and I\u0026rsquo;ll manually change it per buffer if I want something different\n(setq-default fill-column 80) Scroll bar # I toggle this one on/off sometimes depending on how I feel and which OS I\u0026rsquo;m currently on.\n(scroll-bar-mode -1) Inhibit splash screen # When I was starting out, the OG GNU Splash was a super helpful screen. Lately I haven\u0026rsquo;t needed the reminder links as often, but I sometimes get back to it to with C-h C-a.\n(setq inhibit-splash-screen t) Window margins and fringe # This hunk adds some space around all sides of each window so that we get a clear space between the edge of the screen and the fringe. This helps src blocks look clean and well delineated for org-modern.\n(modify-all-frames-parameters \u0026#39;((right-divider-width . 40) (internal-border-width . 40))) (dolist (face \u0026#39;(window-divider window-divider-first-pixel window-divider-last-pixel)) (face-spec-reset-face face) (set-face-foreground face (face-attribute \u0026#39;default :background))) (set-face-background \u0026#39;fringe (face-attribute \u0026#39;default :background)) Automatically visit symlink sources # When navigating to a file that is a symlink, this automatically redirects us to the source file it\u0026rsquo;s pointing to.\n(setq find-file-visit-truename t) (setq vc-follow-symlinks t) Indent with spaces by default # For the most part I edit Python, SQL, Markdown, Org, and shell scripts. All of these favor spaces over tabs, so I prefer this as the default.\n(setq-default indent-tabs-mode nil) Render ASCII color escape codes # For files containing color escape codes, this provides a way to render the colors in-buffer.\n(defun renz/display-ansi-colors () (interactive) (require \u0026#39;ansi-color) (ansi-color-apply-on-region (point-min) (point-max))) Enable horizontal scrolling with mouse # From a helpful stackoverflow answer.\n(setq mouse-wheel-tilt-scroll t) Window management # From a Mickey Petersen article, this causes switch-to-buffer to open the selected buffer in the current window rather than switching windows, assuming both are open in the current frame. This is more frequently the behavior I intend when I\u0026rsquo;m trying to get a window to display a specific buffer.\n(unless (version\u0026lt; emacs-version \u0026#34;27.1\u0026#34;) (setq switch-to-buffer-obey-display-actions t)) Automatically update buffers when contents change on disk # Without setting global-auto-revert-mode, we have to remember to issue a revert-buffer or revert-buffer-quick (C-x x g by default) in case a file changed. Over Tramp, we still have to manually revert files when they\u0026rsquo;ve changed on disk.\n(global-auto-revert-mode) Highlight the line point is on # Add a faint background highlight to the line we\u0026rsquo;re editing.\n(add-hook \u0026#39;prog-mode-hook #\u0026#39;hl-line-mode) (add-hook \u0026#39;text-mode-hook #\u0026#39;hl-line-mode) (add-hook \u0026#39;org-mode-hook #\u0026#39;hl-line-mode) Stop stupid bell # This snippet has a special place in my heart, because it was the first two lines of elisp I wrote when first learning Emacs.\n;; Stop stupid bell (setq ring-bell-function \u0026#39;ignore) The bell is really, really annoying.\nEnable split-window dired copying # Do-What-I-Mean (DWIM) copying is for when two dired windows are open, and we want to copy something from one location to the other. By enabling dired-dwim-target, it auto-populates the minibuffer with the other dired window\u0026rsquo;s path when issuing a copy command with C.\n(setq dired-dwim-target t) Automatically create matching parens in programming modes # (add-hook \u0026#39;prog-mode-hook (electric-pair-mode t)) (add-hook \u0026#39;prog-mode-hook (show-paren-mode t)) Delete whitespace on save # I would also like to have a good-looking display for trailing whitespace and leading tabs like in my Neovim setup, but it has proven challenging to just narrow down to those two faces. In the interim, I toggle M-x whitespace-mode to check for mixed tabs, spaces, and line endings.\n(add-hook \u0026#39;before-save-hook \u0026#39;delete-trailing-whitespace) Don\u0026rsquo;t wrap lines # (setq-default truncate-lines t) (add-hook \u0026#39;eshell-mode-hook (toggle-truncate-lines nil)) Relative line numbers # For programming and prose/writing modes.\nUnfortunately, line numbers are displayed in the text area of the buffer, but org-modern uses the fringe to display source blocks. There\u0026rsquo;s no way to display them to the left of the fringe, so I\u0026rsquo;m careful about only turning on line numbers in modes that I think I\u0026rsquo;ll benefit from it. It\u0026rsquo;s been working pretty well in org-mode without the line numbers so far, since for each of the code blocks I can always use C-c ' to edit in prog-mode, where I do get line numbers.\n(add-hook \u0026#39;prog-mode-hook (lambda () (setq display-line-numbers \u0026#39;relative))) (add-hook \u0026#39;yaml-mode-hook (lambda () (setq display-line-numbers \u0026#39;relative))) (unless (display-graphic-p) (add-hook \u0026#39;text-mode-hook (lambda () (setq display-line-numbers \u0026#39;relative)))) Delete region when we yank on top of it # I just think that\u0026rsquo;s a funny sentence. Normally when yanking text with an active region, the region will remain and the yanked text is just inserted at point. I prefer the modern word processor behavior of replacing the selected text with the yanked content.\n(delete-selection-mode t) Enable mouse in terminal/TTY # (xterm-mouse-mode 1) Compilation # As new text appears, the default behavior is for it to spill off the bottom where we can\u0026rsquo;t see it. Instead, I prefer the window to scroll along with text as it appears\n(setq compilation-scroll-output t) Enable colors in the *compilation* buffer. Provided by a helpful stackoverflow answer.\n(defun renz/colorize-compilation-buffer () \u0026#34;Enable colors in the *compilation* buffer.\u0026#34; (require \u0026#39;ansi-color) (let ((inhibit-read-only t)) (ansi-color-apply-on-region (point-min) (point-max)))) (add-hook \u0026#39;compilation-filter-hook \u0026#39;renz/colorize-compilation-buffer) Tool bar # I usually leave the tool bar disabled\n(tool-bar-mode -1) The menu bar, on the other hand (menu-bar-mode), is very handy, and I don\u0026rsquo;t think I\u0026rsquo;ll ever disable it.\nIgnore risky .dir-locals.el # From an Emacs stackexchange answer.\n(advice-add \u0026#39;risky-local-variable-p :override #\u0026#39;ignore) Prefer rg and fd over grep and find # (when (executable-find \u0026#34;rg\u0026#34;) (setq grep-program \u0026#34;rg\u0026#34;)) (when (executable-find \u0026#34;fd\u0026#34;) (setq find-program \u0026#34;fd\u0026#34;)) Make dired human-readable # By default, dired uses bytes instead of \u0026ldquo;K\u0026rdquo;, \u0026ldquo;Mb\u0026rdquo;, or \u0026ldquo;G\u0026rdquo; for file sizes.\n(setq dired-listing-switches \u0026#34;-alFh\u0026#34;) ;; (setq-default dired-hide-details-mode t) Confirm when exiting Emacs # It\u0026rsquo;s very annoying when I\u0026rsquo;m working and suddenly I meant to do C-c C-x, but instead hit C-x C-c. This helps prevent that.\n(setq confirm-kill-emacs \u0026#39;yes-or-no-p) Smooth scrolling # Emacs 29 introduced smooth, pixel-level scrolling, which removes much of the \u0026ldquo;jumpiness\u0026rdquo; you see when scrolling past images.\n(if (version\u0026lt; emacs-version \u0026#34;29.0\u0026#34;) (pixel-scroll-mode) (pixel-scroll-precision-mode 1) (setq pixel-scroll-precision-large-scroll-height 35.0)) Prefer aspell over ispell # (when (executable-find \u0026#34;aspell\u0026#34;) (setq ispell-program-name \u0026#34;aspell\u0026#34;)) Backup and auto-save files # Keep all backup files in a temporary folder. At the moment I have some \u0026ldquo;file not found\u0026rdquo; errors popping up during auto-save on Windows. Once I debug that, I\u0026rsquo;ll uncomment the second part.\n(setq backup-directory-alist \u0026#39;((\u0026#34;.\u0026#34; . \u0026#34;~/.emacs.d/backups/\u0026#34;)) ;; auto-save-file-name-transforms ;; \u0026#39;((\u0026#34;.\u0026#34; ,temporary-file-directory t)) ) Enable narrow-to-region # (put \u0026#39;narrow-to-region \u0026#39;disabled nil) Enable up/downcase-region # (put \u0026#39;upcase-region \u0026#39;disabled nil) (put \u0026#39;downcase-region \u0026#39;disabled nil) Keybindings # In the unlikely event that something below is loaded incorrectly and causes initialization to stop, I like to have my basic key command loaded early, especially so that navigating to the error can happen more quickly.\nEmacs has some standards about where user-configured keys should go. Other non-standard modifications are marked as such.\nKeybound functions # Special utility functions that we\u0026rsquo;ll bind to user keys.\n(defun renz/--jump-section (dirname prompt extension) \u0026#34;For internal use: prompt for a file under `dirname\u0026#39; in the user emacs config site with matching `extension\u0026#39; regexp\u0026#34; (find-file (concat dirname (completing-read prompt (directory-files dirname nil extension))))) (setq renz/site-lisp-dir (expand-file-name \u0026#34;site-lisp/\u0026#34; user-emacs-directory)) (defun renz/jump-configuration () \u0026#34;Prompt for a .el file in my site-lisp folder, then go there.\u0026#34; (interactive) (renz/--jump-section renz/site-lisp-dir \u0026#34;Elisp config files: \u0026#34; \u0026#34;.*\\.el$\u0026#34;)) (defun renz/jump-org () \u0026#34;Prompt for an org file in my emacs directory, then go there.\u0026#34; (interactive) (renz/--jump-section renz/org-home \u0026#34;Org files: \u0026#34; \u0026#34;.*\\.org$\u0026#34;)) (defun renz/jump-init () (interactive) (find-file (expand-file-name \u0026#34;README.org\u0026#34; user-emacs-directory)) (consult-org-heading)) (defun renz/find-tag () \u0026#34;Use completing-read to navigate to a tag\u0026#34; (interactive) (xref-find-definitions (completing-read \u0026#34;Find tag: \u0026#34; tags-completion-table))) (defun renz/consult-grep () \u0026#34;Live grep using `rg\u0026#39; if found, otherwise `grep\u0026#39;\u0026#34; (interactive) (if (executable-find \u0026#34;rg\u0026#34;) (consult-ripgrep) (consult-grep))) Expanded/better defaults # These convenient chords allow for fast text replacement by holding C-M- and rapidly typing k and h in succession.\n(global-set-key (kbd \u0026#34;C-M-\u0026lt;backspace\u0026gt;\u0026#34;) \u0026#39;backward-kill-sexp) (global-set-key (kbd \u0026#34;C-M-h\u0026#34;) \u0026#39;backward-kill-sexp) The next line UNBINDS the suspend-frame keybinding. Accidentally minimizing on the GUI was frustrating as hell, so now I use C-x C-z if I really want to suspend the frame.\n(global-set-key (kbd \u0026#34;C-z\u0026#34;) #\u0026#39;zap-up-to-char) Hippie-expand is purported to be a better version of dabbrev, but I rather like the default behavior of dabbrev. I typically have hippie-expand on a dedicated key, and sometimes re-bind the default M-/ as well, depending on my current workflow.\n(global-set-key [remap dabbrev-expand] \u0026#39;hippie-expand) ibuffer is a strictly superior, built-in version of its counterpart.\n(global-set-key [remap list-buffers] \u0026#39;ibuffer) The most common situation where I\u0026rsquo;m running flymake would be for spelling in prose, or diagnostics from a language server. In either case, I like having next/previous on easy to reach chords.\n(with-eval-after-load \u0026#39;flymake (define-key flymake-mode-map (kbd \u0026#34;M-n\u0026#34;) \u0026#39;flymake-goto-next-error) (define-key flymake-mode-map (kbd \u0026#34;M-p\u0026#34;) \u0026#39;flymake-goto-prev-error)) When using isearch to jump to things, it\u0026rsquo;s sometimes convenient to re-position point on the opposite side of where the search would normally put it. E.g. when using C-r, but we want point to be at the end of the word when we\u0026rsquo;re done. Provided by a stack overflow answer.\n(define-key isearch-mode-map (kbd \u0026#34;\u0026lt;C-return\u0026gt;\u0026#34;) (defun isearch-done-opposite (\u0026amp;optional nopush edit) \u0026#34;End current search in the opposite side of the match.\u0026#34; (interactive) (funcall #\u0026#39;isearch-done nopush edit) (when isearch-other-end (goto-char isearch-other-end)))) C-c bindings # C-c \u0026lt;letter\u0026gt; is always free for users. It may seem like overkill how I set a header for each possible C-c combination, but it\u0026rsquo;s incredibly handy when I want to jump directly to one of these headings while in another buffer. See e.g. renz/jump-init, which allows me to narrow in on a particular key I\u0026rsquo;d like to bind by leveraging completing-read. If a C-c \u0026lt;letter\u0026gt; combination is missing as a header, then I\u0026rsquo;m probably using it in a :bind statement with use-package somewhere else.\nC-c b scroll-bar-mode # ;; (global-set-key (kbd \u0026#34;C-c a\u0026#34;) #\u0026#39;) (global-set-key (kbd \u0026#34;C-c b\u0026#34;) #\u0026#39;scroll-bar-mode) C-c d jump to a tag # (global-set-key (kbd \u0026#34;C-c d\u0026#34;) #\u0026#39;renz/find-tag) C-c e # ;; (global-set-key (kbd \u0026#34;C-c e\u0026#34;) #\u0026#39;) C-c f hippie-expand # (global-set-key (kbd \u0026#34;C-c f\u0026#34;) #\u0026#39;hippie-expand) C-c g find file at point # (global-set-key (kbd \u0026#34;C-c g\u0026#34;) #\u0026#39;ffap) ; inspired by vim `gf` C-c i jump to a header in my configuration # (global-set-key (kbd \u0026#34;C-c i i\u0026#34;) #\u0026#39;renz/jump-init) (global-set-key (kbd \u0026#34;C-c i l\u0026#34;) #\u0026#39;renz/jump-configuration) C-c j Toggle window split # Toggling windows from vertical to horizontal splits and vice-versa.\n(defun toggle-window-split () (interactive) (if (= (count-windows) 2) (let* ((this-win-buffer (window-buffer)) (next-win-buffer (window-buffer (next-window))) (this-win-edges (window-edges (selected-window))) (next-win-edges (window-edges (next-window))) (this-win-2nd (not (and (\u0026lt;= (car this-win-edges) (car next-win-edges)) (\u0026lt;= (cadr this-win-edges) (cadr next-win-edges))))) (splitter (if (= (car this-win-edges) (car (window-edges (next-window)))) \u0026#39;split-window-horizontally \u0026#39;split-window-vertically))) (delete-other-windows) (let ((first-win (selected-window))) (funcall splitter) (if this-win-2nd (other-window 1)) (set-window-buffer (selected-window) this-win-buffer) (set-window-buffer (next-window) next-win-buffer) (select-window first-win) (if this-win-2nd (other-window 1)))))) (global-set-key (kbd \u0026#34;C-c j\u0026#34;) #\u0026#39;toggle-window-split) C-c k kill all but one space # (global-set-key (kbd \u0026#34;C-c k\u0026#34;) #\u0026#39;just-one-space) C-c q replace regexp # (global-set-key (kbd \u0026#34;C-c q\u0026#34;) #\u0026#39;replace-regexp) C-c s shell # (global-set-key (kbd \u0026#34;C-c s s\u0026#34;) #\u0026#39;shell) (global-set-key (kbd \u0026#34;C-c s e\u0026#34;) #\u0026#39;eshell) (global-set-key (kbd \u0026#34;C-c s t\u0026#34;) #\u0026#39;term) C-c t # ;; (global-set-key (kbd \u0026#34;C-c t\u0026#34;) #\u0026#39;) C-c u Consult grep/rg # (global-set-key (kbd \u0026#34;C-c u\u0026#34;) #\u0026#39;renz/consult-grep) C-c w # (global-set-key (kbd \u0026#34;C-c w\u0026#34;) #\u0026#39;whitespace-mode) C-c x # ;; (global-set-key (kbd \u0026#34;C-c x\u0026#34;) #\u0026#39;) C-c z # ;; (global-set-key (kbd \u0026#34;C-c z\u0026#34;) #\u0026#39;) C-c Other bindings # (global-set-key (kbd \u0026#34;C-c ;\u0026#34;) #\u0026#39;comment-line) ; TTY-friendly (global-set-key (kbd \u0026#34;C-c \u0026lt;DEL\u0026gt;\u0026#34;) #\u0026#39;backward-kill-sexp) ;; TTY-frindly (global-set-key (kbd \u0026#34;C-c \u0026lt;SPC\u0026gt;\u0026#34;) #\u0026#39;mark-sexp) ;; TTY-friendly Meta/Alt Modifications # (with-eval-after-load \u0026#39;dired (define-key dired-mode-map (kbd \u0026#34;M-S-j\u0026#34;) \u0026#39;dired-goto-file)) F5-F9 # Like the C-c \u0026lt;letter\u0026gt; bindings, these are reserved for users. In practice, even though there are few of these keys, I tend to forget which is which. So I wind up using things bound to my C-c keymaps instead, since they come from a natural, nested language.\n(global-set-key (kbd \u0026#34;\u0026lt;f5\u0026gt;\u0026#34;) #\u0026#39;compile) (global-set-key (kbd \u0026#34;M-\u0026lt;f5\u0026gt;\u0026#34;) #\u0026#39;recompile) ;; (global-set-key (kbd \u0026#34;\u0026lt;f6\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;M-\u0026lt;f6\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;\u0026lt;f7\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;M-\u0026lt;f7\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;\u0026lt;f8\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;M-\u0026lt;f8\u0026gt;\u0026#34;) #\u0026#39;) ;; (global-set-key (kbd \u0026#34;\u0026lt;f9\u0026gt;\u0026#34;) #\u0026#39;vterm) (global-set-key (kbd \u0026#34;M-\u0026lt;f9\u0026gt;\u0026#34;) #\u0026#39;eshell) (global-set-key (kbd \u0026#34;S-\u0026lt;f9\u0026gt;\u0026#34;) #\u0026#39;ansi-term) (global-set-key (kbd \u0026#34;s-\u0026lt;f9\u0026gt;\u0026#34;) #\u0026#39;shell) Super bindings # See the Microsoft Windows section for some hackery required to get these working on their operating system.\n(global-set-key (kbd \u0026#34;s-c\u0026#34;) #\u0026#39;kill-ring-save) (global-set-key (kbd \u0026#34;s-q\u0026#34;) #\u0026#39;save-buffers-kill-terminal) (global-set-key (kbd \u0026#34;s-s\u0026#34;) #\u0026#39;save-buffer) (global-set-key (kbd \u0026#34;s-t\u0026#34;) #\u0026#39;tab-new) (global-set-key (kbd \u0026#34;s-v\u0026#34;) #\u0026#39;yank) Consulting completing-read # Consult forms a large foundation of my workflow. It provides a strictly superior experience switching between buffers, performing grep or rg with live results as you type, and scanning through a document for lines matching an expression with consult-line.\n(use-package consult :bind( ;; C-x bindings (ctl-x-map) (\u0026#34;C-x M-:\u0026#34; . consult-complex-command) ;; orig. repeat-complex-command (\u0026#34;C-x b\u0026#34; . consult-buffer) ;; orig. switch-to-buffer (\u0026#34;C-x 4 b\u0026#34; . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window (\u0026#34;C-x 5 b\u0026#34; . consult-buffer-other-frame) ;; orig. switch-to-buffer-other-frame (\u0026#34;C-x r b\u0026#34; . consult-bookmark) ;; orig. bookmark-jump (\u0026#34;C-x p b\u0026#34; . consult-project-buffer) ;; orig. project-switch-to-buffer ;; Other custom bindings (\u0026#34;M-y\u0026#34; . consult-yank-pop) ;; orig. yank-pop (\u0026#34;\u0026lt;help\u0026gt; a\u0026#34; . consult-apropos) ;; orig. apropos-command (\u0026#34;C-c r\u0026#34; . consult-recent-file) ;; M-g bindings (goto-map) (\u0026#34;M-g e\u0026#34; . consult-compile-error) (\u0026#34;M-g f\u0026#34; . consult-flymake) ;; Alternative: consult-flycheck (\u0026#34;M-g g\u0026#34; . consult-goto-line) ;; orig. goto-line (\u0026#34;M-g M-g\u0026#34; . consult-goto-line) ;; orig. goto-line (\u0026#34;M-g o\u0026#34; . consult-outline) ;; Alternative: consult-org-heading (\u0026#34;M-g m\u0026#34; . consult-mark) (\u0026#34;M-g k\u0026#34; . consult-global-mark) (\u0026#34;M-g i\u0026#34; . consult-imenu) (\u0026#34;M-g I\u0026#34; . consult-imenu-multi) ;; M-s bindings (search-map) (\u0026#34;M-s d\u0026#34; . consult-find) (\u0026#34;M-s D\u0026#34; . consult-locate) (\u0026#34;M-s g\u0026#34; . consult-grep) (\u0026#34;M-s G\u0026#34; . consult-git-grep) (\u0026#34;M-s r\u0026#34; . consult-ripgrep) (\u0026#34;M-s l\u0026#34; . consult-line) (\u0026#34;M-s L\u0026#34; . consult-line-multi) (\u0026#34;M-s m\u0026#34; . consult-multi-occur) (\u0026#34;M-s k\u0026#34; . consult-keep-lines) (\u0026#34;M-s u\u0026#34; . consult-focus-lines) ;; Isearch integration (\u0026#34;M-s e\u0026#34; . consult-isearch-history) :map isearch-mode-map (\u0026#34;M-e\u0026#34; . consult-isearch-history) ;; orig. isearch-edit-string (\u0026#34;M-s e\u0026#34; . consult-isearch-history) ;; orig. isearch-edit-string (\u0026#34;M-s l\u0026#34; . consult-line) ;; needed by consult-line to detect isearch (\u0026#34;M-s L\u0026#34; . consult-line-multi) ;; needed by consult-line to detect isearch ;; Minibuffer history :map minibuffer-local-map (\u0026#34;M-s\u0026#34; . consult-history) ;; orig. next-matching-history-element (\u0026#34;M-r\u0026#34; . consult-history)) ;; orig. previous-matching-history-element ;; Enable automatic preview at point in the *Completions* buffer. This is ;; relevant when you use the default completion UI. :hook (completion-list-mode . consult-preview-at-point-mode) :init ;; Optionally configure the register formatting. This improves the register ;; preview for `consult-register\u0026#39;, `consult-register-load\u0026#39;, ;; `consult-register-store\u0026#39; and the Emacs built-ins. (setq register-preview-delay 0.5 register-preview-function #\u0026#39;consult-register-format) ;; Optionally tweak the register preview window. ;; This adds thin lines, sorting and hides the mode line of the window. (advice-add #\u0026#39;register-preview :override #\u0026#39;consult-register-window) ;; Use Consult to select xref locations with preview (setq xref-show-xrefs-function #\u0026#39;consult-xref xref-show-definitions-function #\u0026#39;consult-xref) ) Autocompletion # Emacs offers incredible depth and freedom when configuring methods that automatically complete text. There are actually two things that \u0026ldquo;autocompletion\u0026rdquo; can refer to in Emacs:\nMinibuffer completion Completion at point Emacs on its own does not have a nice pop-up-menu like Vim for completing text at point. For both the minibuffer and completion-at-point it uses a special buffer called *Completions*, from which we can see (and optionally select) a completion from potential candidates. It only updates when issuing a command, such as hitting TAB, rather than updating live as we type, which makes it a bit clunky compared to what we see in modern editors. We will lean on some external packages to remedy this, but before getting to that we have two orders of business:\nSetting the completion style Enhancing the behavior of the default *Completions* buffer and how we can interact with it. Completion style: Orderless # For both the minibuffer and completion-at-point, I use the same completion style. Completion style is the method of assigning completion candidates to a given input string. flex is the built-in \u0026ldquo;fuzzy\u0026rdquo; completion style, familiar to us from symbol completion in IDEs and VSCode\u0026rsquo;s command palette. basic functions much like your default TAB-complete at a Bash shell.\n(setq completion-styles \u0026#39;(flex basic partial-completion emacs22)) I\u0026rsquo;ve found the orderless completion style especially well-suited to Emacs. It allows me to type short strings that can match the symbol I\u0026rsquo;m looking for in any order. In Emacs, I may not know if I\u0026rsquo;m looking for package-list or list-packages. In either case, I can just type \u0026ldquo;pack lis\u0026rdquo; in the minibuffer to find the correct one.\n(use-package orderless :config (add-to-list \u0026#39;completion-styles \u0026#39;orderless) :custom (completion-category-overrides \u0026#39;((file (styles basic partial-completion))))) Nicer display of *Completions* # With the completion style set, we have to now configure the interfaces for displaying candidates as we type. The natural place to start would be the built-in *Completions* buffer. First, I want candidates displayed as a single, vertical list.\n(setq completions-format \u0026#39;one-column) Also, when using the built-in completion-at-point, the *Completions* buffer can sometimes take up the whole screen when there are a lot of candidates. Setting this prevents that:\n(temp-buffer-resize-mode) (setq temp-buffer-max-height 20) Live *Completions* buffer # An interesting idea by oantolin. Given how modest in scope it is, and how close to Vanilla Emacs it stays, I might actually try it sometime.\nKeybindings to interact with *Completions* # If there is a convenient way to interact with the *Completions* buffer from a buffer with default key bindings, I am not aware of it. Because of this, I set a few convenience functions for navigating to, selecting, and closing the buffer in the case I do need to use it.\n(defun renz/completion-accept () \u0026#34;Expand current text to first completion result\u0026#34; (interactive) ;; FIXME In python REPL, if we go back inside a symbol and edit it ;; to narrow the candidate list, then accept something with ;; this function, the trailing text isn\u0026#39;t erased (switch-to-completions) (choose-completion)) (defun renz/jump-completion () \u0026#34;Jump to second completion.\u0026#34; (interactive) (switch-to-completions) (next-completion 1)) (defun renz/completion-kill-completion-buffer () \u0026#34;Close the *Completions* buffer without switching to it\u0026#34; (interactive) (kill-buffer \u0026#34;*Completions*\u0026#34;)) Much like Vim\u0026rsquo;s built-in completion with the pop-up menu, I set C-n and C-p as a way to select completion candidates out of the *Completions* buffer.\n(define-key completion-in-region-mode-map (kbd \u0026#34;C-n\u0026#34;) \u0026#39;renz/jump-completion) (define-key completion-list-mode-map (kbd \u0026#34;C-n\u0026#34;) \u0026#39;next-completion) (define-key completion-list-mode-map (kbd \u0026#34;C-p\u0026#34;) \u0026#39;previous-completion) For a while, I thought keys like RET, TAB, and similar would be intuitive candidates for accepting completion candidates. That turned out to be a problem because there\u0026rsquo;s a good chance you\u0026rsquo;ll mess up required functionality in shell, minibuffer, and related modes. So, instead, I opt for the similar C-j.\n(define-key completion-in-region-mode-map (kbd \u0026#34;C-j\u0026#34;) \u0026#39;renz/completion-accept) (define-key completion-list-mode-map (kbd \u0026#34;C-j\u0026#34;) \u0026#39;choose-completion) Minibuffer completion with vertico and marginalia # It\u0026rsquo;s worth noting that the fido-vertical built-in is pretty good, but I had issues with micro-freezes in some situations. vertico, on the other hand, has been lightning quick, and has intuitive keybindings that don\u0026rsquo;t require any futzing. Especially in the case where I\u0026rsquo;m looking to tab-complete things like C-x C-f /ssh:\u0026lt;thing\u0026gt;.\n(use-package vertico :config (vertico-mode) (vertico-buffer-mode -1) (define-key vertico-map \u0026#34;\\M-q\u0026#34; #\u0026#39;vertico-quick-insert) (define-key vertico-map \u0026#34;\\C-q\u0026#34; #\u0026#39;vertico-quick-exit) (vertico-multiform-mode) (setq vertico-multiform-categories \u0026#39;((consult-grep buffer)))) Combining vertico\u0026rsquo;s forces with marginalia creates a lovely minibuffer completion experience that rivals (or even beats) modern IDE and VSCode command palettes. marginalia adds a short, context-aware description next to completion candidates in the minibuffer. For instance, using C-h f will show me if a function is already bound to a key, and give me the top-level description of the function, without requiring me to actually open the *Help* buffer.\n(use-package marginalia :config (marginalia-mode)) For some eye candy, I could add some all-the-icons goodies as well.\n(use-package all-the-icons-completion :if (display-graphic-p) :after (marginalia all-the-icons) :hook (marginalia-mode . all-the-icons-completion-marginalia-setup) :init (all-the-icons-completion-mode)) Completion at point with corfu # For completion-at-=point suggestions, I like corfu a lot. It\u0026rsquo;s philosophy is to stick as close as possible to the native Emacs internal API as possible, without reinventing the wheel. In my experience, this has meant far fewer integration troubles with other packages. It uses child frames for displaying the completion candidates, however, which means we need a separate corfu-terminal extension for it to work in TTY mode. While use-package has the :unless and :if keywords, I seem to have trouble getting them to actually work with display-graphic-p, and the official instructions with window-system wasn\u0026rsquo;t working for me. Hence, it\u0026rsquo;s wrapped in an unless block.\nI\u0026rsquo;ve also enabled the TNG (Tab-n-go) style of completion, as laid out in corfu\u0026rsquo;s README.\n(unless (display-graphic-p) (use-package corfu-terminal :config (corfu-terminal-mode +1))) (use-package corfu :demand t :custom (corfu-cycle t) ;; Enable cycling for `corfu-next/previous\u0026#39; (corfu-preselect-first nil) ;; Disable candidate preselection :bind (:map corfu-map (\u0026#34;M-SPC\u0026#34; . corfu-insert-separator) (\u0026#34;TAB\u0026#34; . corfu-next) ([tab] . corfu-next) (\u0026#34;S-TAB\u0026#34; . corfu-previous) ([backtab] . corfu-previous)) :config (defun corfu-enable-always-in-minibuffer () \u0026#34;Enable Corfu in the minibuffer if Vertico/Mct are not active.\u0026#34; (unless (or (bound-and-true-p mct--active) (bound-and-true-p vertico--input)) ;; (setq-local corfu-auto nil) ;; Enable/disable auto completion (setq-local corfu-echo-delay nil ;; Disable automatic echo and popup corfu-popupinfo-delay nil) (corfu-mode 1))) (defun corfu-send-shell (\u0026amp;rest _) \u0026#34;Send completion candidate when inside comint/eshell.\u0026#34; (cond ((and (derived-mode-p \u0026#39;eshell-mode) (fboundp \u0026#39;eshell-send-input)) (eshell-send-input)) ((and (derived-mode-p \u0026#39;comint-mode) (fboundp \u0026#39;comint-send-input)) (comint-send-input)))) (setq corfu-auto t corfu-auto-delay 0.0 corfu-quit-no-match \u0026#39;separator) (add-hook \u0026#39;minibuffer-setup-hook #\u0026#39;corfu-enable-always-in-minibuffer 1) (advice-add #\u0026#39;corfu-insert :after #\u0026#39;corfu-send-shell) (global-corfu-mode)) There are some cases over Tramp, however, where corfu will case some performance issues. Especially in the case where some folders under the / root might be mounted over a network. In that case, I sometimes call this renz/disable-corfu-remote, which only disables corfu in the current buffer if it\u0026rsquo;s being handled by Tramp.\n(defun renz/disable-corfu-remote () (when (and (fboundp \u0026#39;corfu-mode) (file-remote-p default-directory)) (corfu-mode -1))) Finally, Emacs uses M-TAB, or the equivalent C-M-i for completion-at-point. I\u0026rsquo;d much prefer to just use the easier and more intuitive TAB.\n(setq tab-always-indent \u0026#39;complete) Tramp # Tramp (Transparent Remote Access Multiple Protocol) allows us to access files on a remote machine, and edit them locally. This is great for simple changes or quickly testing out some Python on a VM somewhere. It isn\u0026rsquo;t as snappy as using the TTY version or an X-forwarded Emacs from the server directly, so if I can set up Emacs remotely, I usually do. When I don\u0026rsquo;t want to or don\u0026rsquo;t have the time, Tramp is a godsend. There are, however, many foibles to guard against, particularly with how interacts with version control and .dir-locals. The Tramp manual (distributed with Emacs) recommends adjusting these for some speed improvements:\n(use-package tramp :config (setq vc-handled-backends \u0026#39;(Git) file-name-inhibit-locks t tramp-inline-compress-start-size 1000 tramp-copy-size-limit 10000 tramp-verbose 1)) eglot is actively working on an issue related to timers causing a \u0026ldquo;Forbidden reentrant call of Tramp\u0026rdquo; message and freezing. In the meantime, this setting was recommended.\n(setq tramp-use-ssh-controlmaster-options nil) For some time I was having a lot of trouble with prohibitive slowness over Tramp, and after careful scrutiny of the logs on (I believe) tramp-verbose 6, I found out that enabling remote dir-locals was causing a huge bottleneck. On every operation it would trace up the filesystem tree back to the root directory, scanning for a .dir-locals file. Since some of the drives were network-mounted, this caused thousands of network calls per file operation, obviously slowing things down a lot. Because of this, I\u0026rsquo;ve opted to simply disable .dir-locals over Tramp entirely, since I don\u0026rsquo;t really use it much, if at all.\n;; (setq enable-remote-dir-locals t) When using conda, I keep a special conda environment named robbmann for locally-installed and managed command line utilities. Sometimes I link these over to .local/bin, and other times I forget. For the latter case, I tend to include it in a lot of my PATH-setting situations.\n(add-to-list \u0026#39;tramp-remote-path \u0026#34;~/.local/bin\u0026#34;) (add-to-list \u0026#39;tramp-remote-path \u0026#34;~/.conda/envs/robbmann/bin\u0026#34;) Disabling VC does seem to speed things up a little, but it\u0026rsquo;s not an acceptable thing to put in, since I so frequently use VC over tramp. Fully disabling VC would include this snippet:\n(remove-hook \u0026#39;find-file-hook \u0026#39;vc-find-file-hook) (setq vc-ignore-dir-regexp (format \u0026#34;\\\\(%s\\\\)\\\\|\\\\(%s\\\\)\u0026#34; vc-ignore-dir-regexp tramp-file-name-regexp)) Additionally, these came up as other potential options from the doom-emacs issues, which I do not currently include.\n(setq tramp-default-method \u0026#34;scp\u0026#34;) (setq projectile--mode-line \u0026#34;Projectile\u0026#34;) I often need to set these in ~/.ssh/config for TRAMP to speed up\nHost * ControlMaster auto ControlPath ~/.ssh/master-%h:%p ControlPersist 10m ForwardAgent yes ServerAliveInterval 60 Language-specific major modes # Org-mode # (setq renz/org-home \u0026#34;~/org/\u0026#34;) (setq org-confirm-babel-evaluate nil) (setq org-edit-src-content-indentation 0) I use consult-org-heading for jumping between headers now, so I no longer tangle this line into my config.\n(setq org-goto-interface \u0026#39;outline-path-completion) When displaying images, I usually like to resize them to a comfortable width, which the following enables.\n(setq org-image-actual-width nil) I often want to kill and paste entire src blocks at a time, along with their results. For a time, I included the following command:\n(defun renz/org-kill-src-block () \u0026#34;Kill the src block around point, if applicable.\u0026#34; (interactive) (org-babel-remove-result) (org-mark-element) (kill-region nil nil t)) However, this won\u0026rsquo;t add the contents of the #+RESULTS: block to the kill-ring, which meant I confused myself often. Instead, I\u0026rsquo;ve found that simply doing M-h M-h if there\u0026rsquo;s a result block, or simply M-h if there isn\u0026rsquo;t one, followed by either M-w or C-w, depending on whether I want to save or kill, is perfectly fast enough.\nI also use org-mode for writing my blog. With a little help from an article we have exporting to Hugo-specific markdown. Without the export, Hugo can read Org files okay-ish, but you wind up missing some nice QoL features, like header links.\n(use-package ox-hugo) org-mode provides org-babel-tangle-jump-to-org, which jumps back to an Org source file from within the tangled code. renz/org-babel-tangle-jump-to-src, defined below, does the opposite - given the Org source file and point inside a src block, it jumps to the location of the tangled code. Provided by a helpful stackoverflow answer.\n(defun renz/org-babel-tangle-jump-to-src () \u0026#34;The opposite of `org-babel-tangle-jump-to-org\u0026#39;. Jumps at tangled code from org src block.\u0026#34; (interactive) (if (org-in-src-block-p) (let* ((header (car (org-babel-tangle-single-block 1 \u0026#39;only-this-block))) (tangle (car header)) (lang (caadr header)) (buffer (nth 2 (cadr header))) (org-id (nth 3 (cadr header))) (source-name (nth 4 (cadr header))) (search-comment (org-fill-template org-babel-tangle-comment-format-beg `((\u0026#34;link\u0026#34; . ,org-id) (\u0026#34;source-name\u0026#34; . ,source-name)))) (file (expand-file-name (org-babel-effective-tangled-filename buffer lang tangle)))) (if (not (file-exists-p file)) (message \u0026#34;File does not exist. \u0026#39;org-babel-tangle\u0026#39; first to create file.\u0026#34;) (find-file file) (beginning-of-buffer) (search-forward search-comment))) (message \u0026#34;Cannot jump to tangled file because point is not at org src block.\u0026#34;))) Now we configure org-mode itself. For a while I was trying (setq org-startup-indented t) t get indentation under each header, but this was interfering with the beautification features from org-modern. Preferring the latter over the former, I\u0026rsquo;ve removed the org-startup-indented call.\n(use-package org :hook ((org-mode . (lambda () (progn (add-hook \u0026#39;after-save-hook #\u0026#39;org-babel-tangle :append :local) (add-hook \u0026#39;org-babel-after-execute-hook #\u0026#39;renz/display-ansi-colors)))) ) :bind ((\u0026#34;C-c o a\u0026#34; . org-agenda) (\u0026#34;C-c o b d\u0026#34; . org-babel-detangle) (\u0026#34;C-c o b o\u0026#34; . org-babel-tangle-jump-to-org) (\u0026#34;C-c o b s\u0026#34; . renz/org-babel-tangle-jump-to-src) (\u0026#34;C-c o j\u0026#34; . consult-org-heading) (\u0026#34;C-c o k\u0026#34; . org-babel-remove-result) (\u0026#34;C-c o o\u0026#34; . renz/jump-org) (\u0026#34;C-c o w\u0026#34; . renz/org-kill-src-block) (\u0026#34;C-c o y\u0026#34; . ox-clip-image-to-clipboard)) :config (add-to-list \u0026#39;org-modules \u0026#39;org-tempo) (org-babel-do-load-languages \u0026#39;org-babel-load-languages \u0026#39;((emacs-lisp . t) (python . t) (sql . t) (shell . t) (fortran . t) (julia . t) ;; (jupyter . t) (scheme . t) (haskell . t) (lisp . t) (clojure . t) (C . t) (org . t) (gnuplot . t) (awk . t) (latex . t))) ;; Outside the typical TODO/DONE states, I like to use DEAD as an indicator ;; that something is fully blocked, but not done. (setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;DEAD\u0026#34; \u0026#34;DONE\u0026#34;))) (setq org-agenda-files \u0026#39;(\u0026#34;~/.emacs.d/org/work.org\u0026#34;) org-hugo-front-matter-format \u0026#34;yaml\u0026#34;)) ob-async adds asynchronous source block execution to some modes that otherwise wouldn\u0026rsquo;t have it.\n(use-package ob-async :config (add-hook \u0026#39;ob-async-pre-execute-src-block-hook #\u0026#39;(lambda () (require \u0026#39;ob-sql-mode) (require \u0026#39;hive2))) ;; Python has its own =:async yes= header argument we can use, so there\u0026#39;s no ;; need to include it with ~ob-async~. (setq ob-async-no-async-languages-alist \u0026#39;(\u0026#34;python\u0026#34;)) ;; I\u0026#39;m having trouble rembering why I added this following line, except that I ;; belive it has something to do with exporting to HTML with syntax ;; highlighting. (setq org-html-htmlize-output-type \u0026#39;css)) org-modern # A lovely look for org-mode by minad.\n(use-package org-modern :after org :config (setq ;; Edit settings org-auto-align-tags nil org-tags-column 0 org-catch-invisible-edits \u0026#39;show-and-error org-special-ctrl-a/e t org-insert-heading-respect-content t ;; Org styling, hide markup etc. org-hide-emphasis-markers t org-pretty-entities t org-ellipsis \u0026#34;…\u0026#34; ;; Agenda styling org-agenda-tags-column 0 org-agenda-block-separator ?─ org-agenda-time-grid \u0026#39;((daily today require-timed) (800 1000 1200 1400 1600 1800 2000) \u0026#34; ┄┄┄┄┄ \u0026#34; \u0026#34;┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄\u0026#34;) org-agenda-current-time-string \u0026#34;⭠ now ─────────────────────────────────────────────────\u0026#34;) (if (display-graphic-p) (setq org-modern-table t) (setq org-modern-table nil)) (global-org-modern-mode)) SQL # (defun renz/sql-mode-hook () (setq tab-width 4) (setq sqlformat-command \u0026#39;sql-formatter)) (defvar renz/sql-indentation-offsets-alist \u0026#39;((syntax-error sqlind-report-sytax-error) (in-string sqlind-report-runaway-string) (comment-continuation sqlind-indent-comment-continuation) (comment-start sqlind-indent-comment-start) (toplevel 0) (in-block +) (in-begin-block +) (block-start 0) (block-end 0) (declare-statement +) (package ++) (package-body 0) (create-statement +) (defun-start +) (labeled-statement-start 0) (statement-continuation +) (nested-statement-open sqlind-use-anchor-indentation +) (nested-statement-continuation sqlind-use-previous-line-indentation) (nested-statement-close sqlind-use-anchor-indentation) (with-clause sqlind-use-anchor-indentation) (with-clause-cte +) (with-clause-cte-cont ++) (case-clause 0) (case-clause-item sqlind-use-anchor-indentation +) (case-clause-item-cont sqlind-right-justify-clause) (select-clause 0) (select-column sqlind-indent-select-column) (select-column-continuation sqlind-indent-select-column +) (select-join-condition ++) (select-table sqlind-indent-select-table) (select-table-continuation sqlind-indent-select-table +) (in-select-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (insert-clause 0) (in-insert-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (delete-clause 0) (in-delete-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator) (update-clause 0) (in-update-clause sqlind-lineup-to-clause-end sqlind-right-justify-logical-operator))) (defun renz/sql-indentation-offsets () (setq sqlind-indentation-offsets-alist renz/sql-indentation-offsets-alist) (setq sqlind-basic-offset 4)) (add-hook \u0026#39;sqlind-minor-mode-hook #\u0026#39;renz/sql-indentation-offsets) (add-hook \u0026#39;sql-mode-hook #\u0026#39;renz/sql-mode-hook) (add-hook \u0026#39;sql-mode-hook \u0026#39;sqlup-mode) (add-hook \u0026#39;sql-mode-hook \u0026#39;sqlind-minor-mode) (add-hook \u0026#39;sql-interactive-mode-hook \u0026#39;sqlup-mode) (use-package hive2 :after (sql) :mode (\u0026#34;\\\\.hql\u0026#34; . sql-mode)) (use-package ob-sql-mode :after (sql)) TODO sql-formatter\nI\u0026rsquo;ve modified sqlformat for use with sql-formatter, but I need to find a way to pass in a JSON of configuration values to the command line interface when we call it.\n(use-package sqlformat :after (sql)) Python # The M-x compile feature does not recognize or parse pyright error messages out of the box, so I add that support myself. Here\u0026rsquo;s an example error message:\n/home/robb/tmp/errors.py/ /home/robb/tmp/errors.py:1:1 - error: \u0026#34;foo\u0026#34; is not defined (reportUndefinedVariable) /home/robb/tmp/errors.py:1:1 - warning: Expression value is unused (reportUnusedExpression) /home/robb/tmp/errors.py:4:12 - error: Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; Operator \u0026#34;+\u0026#34; not supported for types \u0026#34;str\u0026#34; and \u0026#34;Literal[1]\u0026#34; (reportGeneralTypeIssues) 2 errors, 1 warning, 0 informations To get the basic M-g M-n and M-g M-p navigation working, we just need a regex to parse file name, line, and column number.\n(with-eval-after-load \u0026#39;compile (add-to-list \u0026#39;compilation-error-regexp-alist-alist \u0026#39;(pyright \u0026#34;^[[:blank:]]+\\\\(.+\\\\):\\\\([0-9]+\\\\):\\\\([0-9]+\\\\).*$\u0026#34; 1 2 3)) (add-to-list \u0026#39;compilation-error-regexp-alist \u0026#39;pyright)) It would be nice if we could also capture the \\\\(error\\\\|warning\\\\) part as \u0026ldquo;KIND\u0026rdquo;, but I\u0026rsquo;m struggling to get it working.\nAnother nice vanilla feature of python-mode is M-x python-check, which runs a pre-specified linter. Setting that to mypy or pyright if either of those programs exist is a small time saver.\n(use-package python :config (if (executable-find \u0026#34;mypy\u0026#34;) (setq python-check-command \u0026#34;mypy\u0026#34;)) (if (executable-find \u0026#34;pyright\u0026#34;) (setq python-check-command \u0026#34;pyright\u0026#34;)) (add-hook \u0026#39;python-mode-hook #\u0026#39;blacken-mode)) At one point, I ran into something similar to this elpy issue on Windows. The culprit was \u0026ldquo;App Execution Aliases\u0026rdquo; with python and python3 redirecting to the windows store. Using this fixed it:\nwinkey -\u0026gt; Manage app execution aliases -\u0026gt; uncheck python and python3 Also on Windows - a pip install of pyreadline3 is required to make tab-completion work at all. It provides the readline import symbol.\nVirtualenvs require .dir-locals.el to have something like:\n((python-mode . ((python-shell-virtualenv-root . \u0026#34;/path/to/my/.venv\u0026#34;)))) However, this only operates on `run-python\u0026rsquo; shells.\npyvenv solves the otherwise very annoying problem of getting external tools like `compile\u0026rsquo; and `eshell\u0026rsquo; to also use our virtual environment\u0026rsquo;s python. I may still use .dir-locals.el to set things like the python-check-command on a per-project basis, though. I don\u0026rsquo;t use pyvenv much now though, since the vast majority of my development time is spent over Tramp, which pyvenv does not support. When I did, the code looked a bit like this:\n(when (package-installed-p \u0026#39;pyvenv) (pyvenv-mode) ;; (add-hook \u0026#39;pyvenv-post-activate-hooks \u0026#39;pyvenv-restart-python) ;; (pyvenv-tracking-mode) ;; (setenv \u0026#34;WORKON_HOME\u0026#34; \u0026#34;~/.conda/envs\u0026#34;) ) For a while, it looks like Emacs was trying out something called semantic-mode, which looks a lot like a precursor to what we now know as the Language Server Protocol. Enabling it was done through adding the semantic-mode hook to your language\u0026rsquo;s major mode hook:\n(add-hook \u0026#39;python-mode-hook \u0026#39;semantic-mode) Don\u0026rsquo;t mark the check command and virtualenv variables as unsafe.\n(put \u0026#39;python-check-command \u0026#39;safe-local-variable #\u0026#39;stringp) (put \u0026#39;python-shell-virtualenv-root \u0026#39;safe-local-variable #\u0026#39;stringp) To have eglot always start up for a python buffer, we would tangle this line into init.el. However, this can cause a significant loading delay over Tramp, and I would prefer snappy, simple access with LSP provided on an as-needed basis.\n(add-hook \u0026#39;python-mode-hook \u0026#39;eglot-ensure) Eventually, I would like to try the emacs-jupyter package to interface with Jupyter kernels from org-mode.\npyrightconfig.json, Tramp, and eglot # The most consistent way to get eglot to properly configure the python virtual environment with pyright is to have a static file at the root of the project, called pyrightconfig.json. I wrote a short plugin that allows me to select a directory using completing-read and have Emacs write the content of pyrightconfig.json based on what I selected, in the appropriate directory.\n(use-package pyrightconfig :after (python)) Configuring pyright this way rather than \u0026ldquo;activating\u0026rdquo; an environment through Emacs (ala pythonic-activate or similar) means we can be running the language server in more than one project at a time, each pointing to its respective virtual environment.\nblacken # Formatting a buffer with black has never been easier!\n(use-package blacken :bind (\u0026#34;C-c p\u0026#34; . blacken-mode) :after (python)) Markdown # Some folks like to write markdown without hard line breaks. When viewing those documents, I can use the renz/md-hook to view it as if there were line breaks in it.\n(defun renz/md-hook () (visual-fill-column-mode) (setq-local fill-column 80)) (use-package markdown-mode ;; :config ;; (add-hook \u0026#39;markdown-mode-hook #\u0026#39;renz/md-hook) ) (use-package poly-markdown :after (markdown-mode)) Code syntax in Markdown # Enable syntax highlighting within code fences for markdown\n(use-package poly-mode :mode (\u0026#34;\\\\.md\u0026#34; . poly-markdown-mode)) AutoHotkey # (use-package ahk-mode :mode \u0026#34;\\\\.ahk\\\\\u0026#39;\u0026#34;) csv-mode # Handy for viewing data quickly.\n(use-package csv-mode :mode \u0026#34;\\\\.csv\\\\\u0026#39;\u0026#34;) Small tool configuration # Most of these are third party installs that require only a little configuration, and don\u0026rsquo;t warrant a big top-level header.\nEmbark # https://github.com/oantolin/embark\n(use-package embark :bind ((\u0026#34;C-.\u0026#34; . embark-act) (\u0026#34;C-\\\\\u0026#34; . embark-dwim) (\u0026#34;C-h B\u0026#34; . embark-bindings)) :init ;; Optionally replace the key help with a completing-read interface ;; (setq prefix-help-command #\u0026#39;embark-prefix-help-command) :config ;; Hide the mode line of the Embark live/completions buffers (add-to-list \u0026#39;display-buffer-alist \u0026#39;(\u0026#34;\\\\`\\\\*Embark Collect \\\\(Live\\\\|Completions\\\\)\\\\*\u0026#34; nil (window-parameters (mode-line-format . none))))) (use-package embark-consult :hook (embark-collect-mode . consult-preview-at-point-mode)) Coterm mode # Adds the ability to use TUI programs in shell mode.\n(coterm-mode) Multiple cursors # A bit like multi-cursor for Jupyter or VSCode, but with a lot of configurable flexibility.\n(use-package multiple-cursors :config (global-unset-key (kbd \u0026#34;M-\u0026lt;down-mouse-1\u0026gt;\u0026#34;)) (global-set-key (kbd \u0026#34;M-\u0026lt;mouse-1\u0026gt;\u0026#34;) \u0026#39;mc/add-cursor-on-click)) Visual fill column # For visual lines, this adds line breaks at the fill-column value. Especially useful for prose that is meant to be copied to other mediums, such as email or word.\n(use-package visual-fill-column :config (add-hook \u0026#39;visual-line-mode-hook #\u0026#39;visual-fill-column-mode)) Magit # The one and only.\n(use-package magit) As a reminder - when using pre-commit hooks it may take a while for the hooks to install. Magit will asynchronously kick off that process, and we can check on it with $. The built-in `vc` is synchronous, and will block Emacs entirely until it\u0026rsquo;s done. So some of the performance hit from using Magit is well worth it in situations like that.\nChange or copy inner/outer # (use-package change-inner :bind ((\u0026#34;C-c c i\u0026#34; . change-inner) (\u0026#34;C-c c o\u0026#34; . change-outer) (\u0026#34;C-c y i\u0026#34; . copy-inner) (\u0026#34;C-c y o\u0026#34; . copy-outer))) eww - search engine and browser # Ecosia requires JavaScript, unfortunately.\n(use-package eww :config (setq eww-search-prefix \u0026#34;https://duckduckgo.com/html/?q=\u0026#34;)) diff-hl # Adds highlighting to the fringe to see what\u0026rsquo;s been added, deleted, or modified from git\u0026rsquo;s perspective.\n(use-package diff-hl :bind (\u0026#34;C-c v\u0026#34; . diff-hl-mode)) Another option (which I haven\u0026rsquo;t really looked at) is git-gutter-fringe.\nGNU Plot # Scientific plotting - the old fashioned way!\n(use-package gnuplot :after (org)) change-inner # Modeled after Vim\u0026rsquo;s ci, ca, yi, and ya commands, these let us yank or kill text within a \u0026ldquo;surrounding\u0026rdquo; delimiter, such as \u0026quot;\u0026quot; or ().\n(use-package change-inner :bind ((\u0026#34;C-c c i\u0026#34; . change-inner) (\u0026#34;C-c c o\u0026#34; . change-outer) (\u0026#34;C-c y i\u0026#34; . yank-inner) (\u0026#34;C-c y o\u0026#34; . yank-outer))) Esup: startup time profiling # esup is a tool for profiling the startup time of Emacs. This snippet is a work around of a bug where esup tries to step into the byte-compiled version of `cl-lib\u0026rsquo;, and fails horribly: https://github.com/jschaf/esup/issues/85\n(use-package esup :bind (\u0026#34;C-c x p\u0026#34;) :config (setq esup-depth 0)) Reloading Emacs # Often used when changing up my init.el.\n(use-package restart-emacs :bind (\u0026#34;C-c x r\u0026#34; . restart-emacs)) Language Server Protocol (LSP) with eglot # (use-package eglot :bind ((\u0026#34;C-c l c\u0026#34; . eglot-reconnect) (\u0026#34;C-c l d\u0026#34; . flymake-show-buffer-diagnostics) (\u0026#34;C-c l f f\u0026#34; . eglot-format) (\u0026#34;C-c l f b\u0026#34; . eglot-format-buffer) (\u0026#34;C-c l l\u0026#34; . eglot) (\u0026#34;C-c l r n\u0026#34; . eglot-rename) (\u0026#34;C-c l s\u0026#34; . eglot-shutdown))) Code block syntax highlighting for HTML export # (use-package htmlize :after (org)) Copying images out of org-babel # Offers two functions:\nox-clip-formatted-copy ox-clip-image-to-clipboard (use-package ox-clip :after org) Start a server for emacsclient # (server-start) Don\u0026rsquo;t forget about these # There are several other interesting options that I haven\u0026rsquo;t tried out yet, including:\norg-download math-delimiters oantolin/placeholder emacs-eaf/emacs-application-framework \u0026lt;\u0026mdash; big hassle multiple-cursors notmuch for email Footer # Thank you for reading \u0026rsquo;till the end or for being interested on how to end an Emacs package. So that\u0026rsquo;s it, let\u0026rsquo;s gracefully finish tangling everything:\n(provide \u0026#39;init.el) ;;; init.el ends here ","date":"1 January 0001","permalink":"/emacsd/","section":"","summary":"Table of Contents Goals Tangling Inspirations Header Custom Packages OS-specific Configuration Microsoft Windows macOS Linux Theme: ef-themes Gave up on Nord Messed up colors in TTY mode Emacs\u0026rsquo; Built-in Settings dabbrev: swap M-/ and C-M-/ Mode line eldoc Remember minibuffer history Colored output in eshell Recent files menu Fill-column Scroll bar Inhibit splash screen Window margins and fringe Automatically visit symlink sources Indent with spaces by default Render ASCII color escape codes Enable horizontal scrolling with mouse Window management Automatically update buffers when contents change on disk Highlight the line point is on Stop stupid bell Enable split-window dired copying Automatically create matching parens in programming modes Delete whitespace on save Don\u0026rsquo;t wrap lines Relative line numbers Delete region when we yank on top of it Enable mouse in terminal/TTY Compilation Tool bar Ignore risky .","title":"My Literate .emacs.d"}]